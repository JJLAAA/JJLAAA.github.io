<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="TS 学习笔记TS是什么 官方文档，多用多看 js的超集，构建于js之上的一种语言 在js的基础上引入类型系统等不错的特性，其中包括js的新特性（ES6或之后的） 在开发过程中 vscode就会提示错误，而不是在运行时从控制台发现错误 ts的编译器会自动将js新特性编译成即使在旧版本的浏览器中也支持运行的js代码，取代了babel的功能 js是动态类型语言，其变量的数据类型是在运行时确定的，而ts">
<meta property="og:type" content="article">
<meta property="og:title" content="ts学习笔记">
<meta property="og:url" content="http://example.com/2021/07/11/ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Long March">
<meta property="og:description" content="TS 学习笔记TS是什么 官方文档，多用多看 js的超集，构建于js之上的一种语言 在js的基础上引入类型系统等不错的特性，其中包括js的新特性（ES6或之后的） 在开发过程中 vscode就会提示错误，而不是在运行时从控制台发现错误 ts的编译器会自动将js新特性编译成即使在旧版本的浏览器中也支持运行的js代码，取代了babel的功能 js是动态类型语言，其变量的数据类型是在运行时确定的，而ts">
<meta property="og:locale">
<meta property="og:image" content="http://images.demoli.xyz/20210103143843.png">
<meta property="og:image" content="http://images.demoli.xyz/20210103143927.png">
<meta property="og:image" content="http://images.demoli.xyz/20210103144849.png">
<meta property="og:image" content="http://images.demoli.xyz/20210106205018.png">
<meta property="article:published_time" content="2021-07-11T07:05:28.000Z">
<meta property="article:modified_time" content="2021-07-11T07:32:06.716Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="typeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://images.demoli.xyz/20210103143843.png">

<link rel="canonical" href="http://example.com/2021/07/11/ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>ts学习笔记 | Long March</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Long March</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Long March">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ts学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:05:28 / Modified: 15:32:06" itemprop="dateCreated datePublished" datetime="2021-07-11T15:05:28+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="TS-学习笔记"><a href="#TS-学习笔记" class="headerlink" title="TS 学习笔记"></a>TS 学习笔记</h1><h2 id="TS是什么"><a href="#TS是什么" class="headerlink" title="TS是什么"></a>TS是什么</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs">官方文档</a>，多用多看</li>
<li>js的超集，构建于js之上的一种语言</li>
<li>在js的基础上引入类型系统等不错的特性，其中包括js的新特性（ES6或之后的）<ul>
<li>在开发过程中 vscode就会提示错误，而不是在运行时从控制台发现错误</li>
<li>ts的编译器会自动将js新特性编译成即使在旧版本的浏览器中也支持运行的js代码，取代了babel的功能</li>
<li><strong>js是动态类型语言，其变量的数据类型是在运行时确定的，而ts是静态类型语言，其类型在开发时就已经确定了，不会在运行时变动</strong></li>
</ul>
</li>
<li>ts不仅仅是一种语言，也可以视作是一个工具，可以将ts编译为js，以运行在browser或者nodejs中<ul>
<li>因此最终运行的还是js，所以ts的所有能力不能超出js所能提供的范围，ts只是在js之上引入了一些优秀特性，由编译器将这些特性转化为相对复杂的js代码</li>
<li>使用<code>npm install typescript -g</code>安装typescript支持，也会自动安装typescript的编译器</li>
<li>执行<code>tsc xx.ts</code>即可完成将ts编译为js<ul>
<li><strong>如果在开发中，IDE报错，但是并没有处理，而是直接编译，最终可以得到编译好的js，但是编译过程会报错</strong></li>
</ul>
</li>
<li>ts编译器提供了丰富的可配置选项</li>
</ul>
</li>
<li>ts不仅引入类型系统，还引入了接口，泛型以及元编程的概念（修饰器）</li>
<li>VSCode等现代IDE有了ts加持后，甚至可以在非ts的代码编辑中进行类型相关的智能的提示</li>
<li><strong>ts的类型系统只在编译时支持，在运行时是不会支持的，因为并没有支持ts运行的执行引擎，只有支持js运行的执行引擎</strong></li>
<li><strong>ts是开发、编译时的类型检查，而js是运行时的类型检查</strong></li>
</ul>
<span id="more"></span>

<h2 id="Demo引入"><a href="#Demo引入" class="headerlink" title="Demo引入"></a>Demo引入</h2><ul>
<li><p>简单的加法器，具体注释参考源码</p>
</li>
<li><p>如果使用js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> num2 !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Incorrect input!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有错误</p>
<ul>
<li>加法运算符对于js的字符串来说是字符串拼接，对于number类型才是加法运算，然而value属性是string类型</li>
</ul>
</li>
<li><p>修改错误</p>
<ul>
<li><p>添加<code>+</code>转换类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>如果使用ts</p>
<ul>
<li><p>IDE提示出错</p>
<ul>
<li><p><code>Property &#39;value&#39; does not exist on type &#39;HTMLElement&#39;</code>，HTMLElement对象未必有value属性，只有inputElement有此属性，ts要求我们确认input1与input2的属性，经过确认，二者是HtmlInputElement属性，有value属性，为表确认，使用<code>typecasting</code>标识</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在函数声明中，我们想明确，参数应该是number类型，而不是string类型，同样做好声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: number, num2: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此时，下边的函数调用处果然出错，value属性是string，不是要求的number，因此使用<code>+</code>转换类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting 类型断言</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: number, num2: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>此时，IDE不再提示错误，查看编译后的js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">var</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以发现实际上与我们自己写的并无太大差异，<strong>ts正是使用这种明确的类型检查与声明确认的形式迫使开发者检查并声明类型，解决了其中的逻辑问题，但是最后的实现实际上可能比较简单，重点是发现并解决逻辑问题（即<code>+</code>的使用)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改错误</p>
</li>
<li><p>运行无错误</p>
</li>
</ul>
</li>
</ul>
<h2 id="开发前的设置"><a href="#开发前的设置" class="headerlink" title="开发前的设置"></a>开发前的设置</h2><ol>
<li><p>ts的学习是依托于前端环境的，所以需要有html文件，然后引入js文件，但是每次修改都需要在浏览器刷新看效果，比较麻烦，所以需要安装<code>lite-server</code>依赖，可以开启一个服务器，并监听文件变动，一旦变动会自动刷新执行更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在项目目录</span></span><br><span class="line">npm init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 安装依赖</span></span><br><span class="line">npm install --save-dev lite-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 修改配置文件 package.json，在scripts节点添加： <span class="string">&quot;start&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,随后执行：</span></span><br><span class="line">npm start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会自动server本目录下的index.html到localhost:3000</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项<strong>name length这样的变量名,会提示重复定义,这是因为<a target="_blank" rel="noopener" href="https://github.com/Microsoft/vscode/issues/22436">https://github.com/Microsoft/vscode/issues/22436</a></strong></p>
</li>
<li><p>安装debugger for Chrome可以在vscode而不是Chrome的dev tools中进行调试，start debugging，并将配置文件进行如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Chrome against localhost&quot;</span>,</span><br><span class="line">            <span class="comment">// 此处改为lite-server运行的3000端口</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;webRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意配置ts配置文件中的sourceMap为true</strong></li>
<li><strong>此扩展应该也可以进行nodejs的debug！！！</strong></li>
</ul>
</li>
</ol>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ol>
<li><p>ts支持的js原生类型：</p>
<ol>
<li><p>boolean</p>
<ol>
<li>true、false</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p>number</p>
<ol>
<li>所有的数字类型都归纳为number，没有Integer或float、double等<ol>
<li>实际上所有的number类型默认被视作float类型，因此5===5.0 为true</li>
</ol>
</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p>string</p>
<ol>
<li>使用””、’’、``定义都可<ol>
<li>最后一个是ES6中引入的，可以创建模板字符串</li>
</ol>
</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p><strong>type inference机制</strong>，也就是类型猜测机制（可以将鼠标移动到变量处查看其类型）</p>
<ol>
<li><p>const类型：固定不变的类型 （由初始值确定），固定不变的值，<strong>实际上就是字面量类型</strong></p>
</li>
<li><p>var、let：固定不变的类型（由初始值确定），值可以变动，但是<strong>初始化之后，此变量就已经与与推测的类型绑定，再赋予其他类型的值的时候会报错</strong>，<strong>如果只声明不初始化，也不显示指定类型，默认指定为any类型</strong>，如下所言：</p>
</li>
<li><p><strong>若只声明而不进行初始化，则建议显式声明类型<code>let number1: number;</code>，否则变量是any类型，就失去了类型机制的检查作用（注意此处说的类型检查是失去了对此any类型的变量进行赋值时的类型检查，当any类型的变量被赋值到其他变量的时候，是会有类型检查的，详见any部分的说明）</strong></p>
</li>
<li><p>若使用<code>:</code>显式指定了类型则使用指定的类型而不是推测的类型</p>
</li>
<li><p>使用原则</p>
<ol>
<li><p>除了初始化的场景，还有诸多场景中，类型猜测机制都会其作用，很强大，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;    <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,    <span class="attr">age</span>: <span class="number">23</span>,    <span class="attr">hobbies</span>: [<span class="string">&#x27;study&#x27;</span>, <span class="string">&#x27;game&#x27;</span>]&#125;;<span class="comment">// console.log(person) for (let hobby of person.hobbies) &#123;    // hobby为string类型    console.log(hobby.toUpperCase());&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>应当可以这么认为，只有类型猜测机制无法作用的地方需要显式指定类型，比如函数参数和函数类型以及变量只声明而不初始化的场景；以及开发者明确需要进行类型限制的场景（不能靠猜，要明确确定，只有进行显式的初始化的时候是明确类型的，但是如果是间接初始化的时候，并不清楚所赋值的类型，此时必须显式指定变量的类型才行（其实类似于函数形参的使用场景）），ts能自动推测并给予必要的类型检查</strong></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Object类型表示<strong>非原始类型</strong>,所谓的非原始类型就是指除了undefined null symbol string number boolean 之外的类型</p>
<ol>
<li>object类型的类型声明是这样的<code>let obj:&#123;a:number;c:string&#125; = &#123;a:12,c:&quot;李佳&quot;&#125;</code><ol>
<li>可以<code>let obj:object = &#123;a:12,c:&quot;李佳&quot;&#125;</code>，但是如此写的话会丢失object的细节，ts也不知道obj变量的具体的属性有哪些<ol>
<li> <strong>因此导致使用<code>.</code>索引属性名时，IDE不会有明确的属性名提示</strong></li>
<li> <strong>因此导致即便索引了确实存在的属性名也会报错</strong></li>
</ol>
</li>
<li> <strong>object的精确类型的形式不是一个js object实例，并且分隔号是<code>;</code>不是<code>,</code>（虽然用<code>,</code>好像也可以）</strong></li>
</ol>
</li>
<li> Object类型也支持<code>type inference</code>，<strong>并且类型推测得到的是精确地类型而不是objecct</strong></li>
<li> 关于Symbol类型，参考<a target="_blank" rel="noopener" href="https://typescript.bootcss.com/symbols.html">官网</a></li>
</ol>
</li>
<li><p>Array  数组(有两种定义方式，其实对应两种数组的类型表达)，<strong>补补基础：js中的数组可以混合存储多种类型的数据</strong></p>
<ol>
<li><p>let list: <strong>元素类型[]</strong> = […] 比如: <code>let list: number[] = [1,2,3,4]</code></p>
<ol>
<li><p>type: number[]</p>
</li>
<li><p>混合数组类型： (number|string)[] （<strong>联合类型的数组，注意联合类型本身应与中括号用小括号隔离</strong>）</p>
<ol>
<li><p>当然此处也可以灵活使用any类型，但是谨慎使用any，因为使用any会使代码退化到js </p>
</li>
<li><p>混合类型的数组的类型推断就是联合类型的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const array: (string | number | boolean | Date)[]const array = [1,&#x27;&#x27;,true,new Date()]; </span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>使用数组泛型 let list:Array&lt;元素类型&gt; = […] 比如: <code>let list: Array&lt;number&gt; = [1,2,3]</code></p>
<ol>
<li>type: Array<number></li>
<li><strong>泛型也可以是联合类型</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>元组 Tuple （元组类型以下的类型都不是js原生支持的类型，而是ts引入的类型）</p>
<ol>
<li><p>元组类型与Array的区别与相似之处在于：</p>
<ol>
<li><strong>元组指定特定的长度与特定的类型（位置对应）</strong></li>
<li><strong>元组的使用场景显然是要求对于数据结构要求比较严格的场景中</strong></li>
<li>元组对于元素的访问方式与数组是一样的</li>
<li><strong>元组类型本质上与数组类型一样，其相关的限制实际上是ts添加的，但是编译成的js中元组实际上就是数组</strong></li>
</ol>
</li>
<li><p>如果直接初始化，ts的类型推测并不能区分出Array（或者是联合类型的Array）与元组，所以一般需要显式设定元组类型，如下案例所示</p>
<ol>
<li>联合类型的type是：<code>(string|number)[]</code></li>
<li>元组的类型是：<code>[string, number]</code></li>
</ol>
</li>
<li><p><strong>元组的使用中有一些坑</strong>，即对于元组与联合类型的数组的区分不是很强：</p>
<ol>
<li><p>元组的长度限制仅限于初始化，如果使用push方法，并不会有限制（仅有类型上的限制，但是没有元组长度的限制）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [number,string] = [<span class="number">1</span>,<span class="string">&#x27;123&#x27;</span>];tuple[<span class="number">0</span>] ++ ;tuple.push(<span class="string">&#x27;2&#x27;</span>);<span class="comment">// [2,&#x27;123&#x27;,&#x27;2&#x27;]console.log(tuple)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Enum 枚举</p>
<ol>
<li><p>枚举的含义实际上就是一个从0开始编号数组,数组里的每一个值都有自己的名字,可通过名字获得值,也可以通过值获得名字</p>
</li>
<li><p>默认从0开始编号,但是也可以自己指定（通过制定第一个成员的值即可）</p>
</li>
<li><p>注意枚举中中的各个项的本质就是被编号的几个全局Enum类型常量</p>
</li>
<li><p><strong>实际上是在创建自定义的类型（通过鼠标查看是，其类型不是enum二十自定义的名字），所以此变量应该首字母大写</strong></p>
<ol>
<li> <strong>除了自定义的enum类型名应该首字母大写，类型中定义的常量应该全部大写</strong></li>
<li> 设置定义的enum常量的值也可以是string，并且可以混用，enum的本质就是一个有实际意义的label而已</li>
<li> 如下的案例涉及到了enum常量与其对应的值的相互索引，注意不是位置索引（本来也不是数组），是内容索引</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;RED = <span class="number">1</span>,GREEN=<span class="number">3</span>,BLUE&#125;<span class="built_in">console</span>.log(Color[<span class="number">4</span>]) <span class="comment">// BLUEconsole.log(Color.red) // 1</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Any</p>
<ol>
<li><p>足够灵活，但谨慎使用</p>
</li>
<li><p>Any类型的变量不会在编译阶段被类型检查,适用的情况包括<code>用户输入,第三方代码库,现阶段不清楚的变量类型</code>，<strong>除以上三种情况，其他情况应该禁止使用any类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果指定any类型，下边可以索引任何属性，哪怕是不存在，也不会报错，因为不会对person的相关操作执行类型检查const person:any = &#123;    name: &#x27;lee&#x27;,    age: 23,    hobbies: [&#x27;study&#x27;, &#x27;game&#x27;],    role: Role.ADMIN&#125;;console.log(person.role);</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>如果实在不知道用哪个类型就用unknown类型即可，不推荐用any</strong></p>
</li>
<li><p><strong>any类型的变量只是在对自身进行赋值的时候，没有类型检查，可以赋予任意类型的值，但是当其被用作赋值给其他变量时：</strong></p>
<ol>
<li><p><strong>一旦对any类型的变量赋值，变量的类型就自动迁移到对应的值的类型（也属于类型猜测机制），并且当次变量被赋予到其他变量时进行对应的类型检查</strong></p>
</li>
<li><p><strong>如果any类型的变量只声明，而没有进行赋值初始化，当其被赋值到其他变量时，其类型自动转为undefined</strong></p>
</li>
<li><p>只在被用到时发生自动类型转换，其余场景自动从特定的类型转化为any</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时为any类型let userName;// 此时为any类型userName = &#x27;jia&#x27;;// 此时为any类型userName = true;// 此时为boolean类型 报错let var2:string = userName;// 此时为any类型userName = &quot;23&quot;;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>在从数据库或者前后端获取数据的时候，一般数据的类型都是type类型，此时并没有有效的类型支持，但是如果有预先设定好的数据格式，作为开发者，应该告诉ts具体的数据格式，从而协助ts为开发者提供更好的类型支持，并且如果数据格式比较复杂，可以只声明开发用到的属性结构，保持兼容即可（参考Google Map项目）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RequestHandler&#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;<span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&#x27;../models/Todo&#x27;</span>;<span class="keyword">const</span> TODOS: Todo[] = [];<span class="keyword">export</span> <span class="keyword">const</span> getTodoListHandler:RequestHandler = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;    <span class="comment">// 自定义前端传来的数据结构为&#123;text: string&#125;     const text = (req.body as &#123;text: string&#125;).text;    let todo = new Todo(Math.random().toString(), text);&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Union联合类型</p>
<ol>
<li><p>此类型适用在函数参数等需要满足多个可选类型的变量定义中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">var1: number|string, var2: number|string</span>) </span>&#123;		<span class="comment">// 不得不引入运行时类型检查，实际上此运行时类型判断即为ts的特性之一 type guard    if (typeof var1 === &#x27;number&#x27; &amp;&amp; typeof var2 === &#x27;number&#x27;) &#123;        // 如果直接相加，会报错，因为ts只检测到了对Union类型使用+，而不会探究Union内部的类型，所以        // 暂时引入类型判断(type guard)        return var1 + var2;    &#125; else &#123;        // 可以对Union类型使用toString 方法，因为不管其到底是Union内部的哪一种类型，都有此方法        return var1.toString() + var2.toString()    &#125;    &#125;console.log(add(1, 2));console.log(add(&#x27;李&#x27;, &#x27;佳&#x27;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意上述的运行时的类型判断即为type guard，<strong>应是对于ts的开始时类型检查的补充，使得ts应对联合类型这样的复杂类型时，能够保证进行精准的类型分类，对于不同的具体类型，执行具体的差异化的操作</strong></p>
<ul>
<li><p>除了使用typeof进行类型检查外（<strong>适用于对于基础类型的检查</strong>），还有以下的进行type guard的方法（<strong>实际上使用typeof只能判断string number boolean这几个基础类型，其余的类型（包括自定义类型）只能识别为object，而无法得知具体细节，比如属性等</strong>）</p>
<ul>
<li><p>if in （普通的type(object字面量)或者interface或者class）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Admin = &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;type Employee = &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;type Combainable = Admin | Employee;<span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">p: Combainable</span>) </span>&#123;    <span class="comment">// 共有属性    console.log(p.name);    // type guard    // ts检查到此判断后，认识到当运行到此if中时，Comabinable类型的实例p一定是Admin类型，并拥有属性privileges   // 需要注意的是，此属性字符串即便写错了也会被检查出来，因为不允许任意写，一定必须是Combainable类型中可能存在的属性之一    if (&#x27;privileges&#x27; in p) &#123;        console.log(p.privileges);    &#125;    &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>instanceof （仅对于class来说）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;    drive () &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;the car is driving&#x27;</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Truck</span> </span>&#123;    drive () &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;the car is driving&#x27;</span>);    &#125;    loadCargo (amount: number) &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;amount loading: &#x27;</span> + amount);    &#125;&#125;type Vechile = Car | Truck;<span class="keyword">let</span> car = <span class="keyword">new</span> Car();<span class="keyword">let</span> truck = <span class="keyword">new</span> Truck();<span class="function"><span class="keyword">function</span> <span class="title">useVechile</span> (<span class="params">v: Vechile</span>) </span>&#123;    v.drive();    <span class="comment">// class中的方法也可以使用if-in的方式判断    // if (&#x27;loadCargo&#x27; in v) &#123;    //     v.loadCargo(12);    // &#125;    // 但是更优雅的方式是使用instanceof    if (v instanceof Truck) &#123;        v.loadCargo(13);    &#125;&#125;useVechile(car);useVechile(truck);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof是typeof的升级版，可以使用自定义class判断，但是仅限于class，因为实际上<strong>无论是typeof还是instanceof都是在js的运行时环境中使用的，ts并不能使用其进行类型检查，只是使用type guard将类型检查转移到了运行时，在js中instanceof的工作原理是使用构造器函数进行匹配，因此在ts中只能使用class（编译成的js中使用构造器函数实现class）而不能使用interface进行类型检查（因为interface是完全的ts概念，不会在js中以任何形式体现）</strong></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000730982">typeof与instanceof的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><p>type guard除了上述的几种类型外，还有一个特殊的方式，就是<strong>Discriminated Unions（可辨识类型）</strong></p>
<ul>
<li><p>对于interface与class都可用，与if-in相比的进步在于，不用写一堆类型的字符串名字，容易写错</p>
</li>
<li><p>本质上就是在多个interface或者class内部定义一个相同的属性，此属性用来描述此类型（类型的字面量名字），可以使用此属性来分辨类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;    <span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>;    flyingSpeed: number;&#125;interface Horse &#123;    <span class="attr">type</span>: <span class="string">&#x27;horse&#x27;</span>;    runningSpeed: number;&#125;type Animal = Bird | Horse;<span class="function"><span class="keyword">function</span> <span class="title">animalRun</span> (<span class="params">a: Animal</span>) </span>&#123;    <span class="keyword">switch</span> (a.type) &#123;        <span class="keyword">case</span> <span class="string">&#x27;bird&#x27;</span> :            <span class="built_in">console</span>.log(<span class="string">&#x27;bird flying speed: &#x27;</span> + a.flyingSpeed);            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="string">&#x27;horse&#x27;</span>:            <span class="built_in">console</span>.log(<span class="string">&#x27;horse running speed:&#x27;</span> + a.runningSpeed);            <span class="keyword">break</span>;    &#125;&#125;animalRun(&#123;<span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>, <span class="attr">flyingSpeed</span>: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>type属性实际上会和对应的类型在ts层面绑定，当使用type属性的时候，只会提示Bird或Horse</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>literal type 也就是字面量类型</p>
<ol>
<li><p>最常见的字面量类型就是使用const定义的变量的类型，这样的常量的类型不是<code>const</code>，而是常量对应的字面量</p>
</li>
<li><p><strong>字面量类型一般与连个类型共同使用，因为如果只是有一个可选常量的话，硬编码即可，或者有比较多的可选常量的话，理应选择enum</strong></p>
</li>
<li><p>在下面的案例中，假设要定义以何种格式返回结果（number or string）（换种说法就是引入返回类型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">var1: number | string, var2: number | string, resultFormat:<span class="string">&#x27;as number&#x27;</span>| <span class="string">&#x27;as string&#x27;</span></span>) </span>&#123;  <span class="keyword">let</span> result;  <span class="keyword">if</span> (<span class="keyword">typeof</span> var1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> var2 === <span class="string">&quot;number&quot;</span>) &#123;    result = var1 + var2;  &#125; <span class="keyword">else</span> &#123;    result = var1.toString() + var2.toString();  &#125;  <span class="keyword">if</span> (resultFormat === <span class="string">&#x27;as string&#x27;</span>) &#123;      <span class="keyword">return</span> result.toString();  &#125; <span class="keyword">else</span> &#123;    <span class="keyword">return</span> + result;  &#125;&#125;<span class="comment">// 3console.log(add(1, 2, &#x27;as string&#x27;));// 12console.log(add(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;as number&#x27;));// 李佳console.log(add(&quot;李&quot;, &quot;佳&quot;, &#x27;as string&#x27;));</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型别名</p>
<ol>
<li>部分类型的名字比较长，可以设置类型别名：<code>type $&#123;自定义类型名&#125;= $&#123;其他类型&#125;</code>，例如：<code>type Combinable = number |string</code></li>
</ol>
</li>
<li><p>void（<strong>函数返回值类型的引入</strong>）</p>
<ol>
<li>ts同样可以使用type inference推测出函数的返回值，也可以使用如下方式显式指定，但是还是同样的道理，如无必要，尽量使用type inference机制</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>void类型的变量只能被赋值为null或者undefined</p>
</li>
<li><p><strong>比较神奇的一点是：当尝试打印void返回值类型的函数的返回值的时候会得到undefined值</strong></p>
</li>
<li><p>函数无返回值的时候通常用void类型做返回值类型</p>
</li>
<li><p>实际上也可以使用undefined作为函数返回值类型，但与void的含义不同，前者表示返回一个空值，后者表示不返回任何东西，<strong>或者说可以在函数体返回任意值，但是函数外部不会接收到此返回值也不在意返回值是什么（这个描述仅在返回值是void的情况下成立，在返回值是void与其他类型的联合类型的情况下不成立）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFormat</span> (<span class="params">num: number</span>):<span class="title">undefined</span> </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;The result is &#x27;</span> + num);    <span class="comment">// 没有这一句就会报错    return;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);    return;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);    return num;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);&#125;// error 只能无return或return;或return number类型数据，而不是其他类型的数据function printFormat (num: number): void|number  &#123;    console.log(&#x27;The result is &#x27; + num);  	return &#x27;hello&#x27;;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>null 同undefined</p>
</li>
<li><p>undefined</p>
<ol>
<li><strong>null和undefined是所有类型的子类型,可以赋值给所有类型的变量,但是当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自所属的同名类型。</strong></li>
</ol>
</li>
<li><p>Function函数类型</p>
<ol>
<li><p>这里涉及到函数编程的概念，函数本身可以被当做值赋予给某变量（或者是用在回调函数中），正因如此，在ts的类型系统中需要引入函数类型这一概念</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;<span class="function"><span class="keyword">function</span> <span class="title">printFormat</span> (<span class="params">num: number</span>):<span class="title">undefined</span> </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;The result is &#x27;</span> + num);    <span class="keyword">return</span>;&#125;printFormat(add(<span class="number">1</span>, <span class="number">2</span>));<span class="keyword">let</span> var1 = add;printFormat(var1(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>和Object类型一样，function类型可以使用<code>Function</code>（大写）指定，也可以明确指定函数的函数声明（参数）+返回值类型作为其函数类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;<span class="comment">// 注意使用箭头分隔返回值类型，类似于箭头函数的形式，参数列表中的参数名任意// 表示var1变量可以接受任意的有两个number类型的参数并且返回number类型的值的函数let var1: (a: number, b: number) =&gt; number = add;</span></span><br></pre></td></tr></table></figure></li>
<li><p>回调函数的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要随便使用关键字，比如var做参数名function addAndHandle (n1: number, n2: number, cb:(n: number) =&gt; void) &#123;    const result = n1 + n2;    cb(result);&#125;// 使用箭头函数addAndHandle(1, 2, (n) =&gt; &#123;    console.log(&#x27;result is &#x27; + n);&#125;);</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>unknown类型</p>
<ol>
<li><p>常用在接受用户输入，在赋值的操作上与any类型类似，可以为any类型的变量赋予任意类型的值，但是与any不同的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo:unknown;<span class="keyword">let</span> userName;userInfo = <span class="number">12</span>;userInfo = <span class="string">&#x27;lee&#x27;</span>;userName = <span class="string">&#x27;jia&#x27;</span>;<span class="keyword">let</span> var2:string = userName;<span class="comment">// Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;var2 = userInfo;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以发现any类型的变量可以赋值给特定类型的变量（<strong>如果any类型的变量之前做赋值的时候已经前移到了此特定的类型中</strong>），但是对于unknown类型的变量，因为不确定变量，所以肯定不能随意给特定类型的变量赋值</li>
</ul>
</li>
<li><p>相对于any类型，当不明确类型的时候更推荐使用unknown类型：</p>
<ol>
<li><p>unknown类型有更明确的类型检查，而不是完全不检查</p>
</li>
<li><p>可以加入额外的类型判断机制，以对unknown进行下一步的操作，目的更明确，行为也更安全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo:unknown;<span class="keyword">let</span> userName;userInfo = <span class="number">12</span>;<span class="comment">// userInfo = &#x27;lee&#x27;;userName = &#x27;jia&#x27;;let var2:string = userName;if (typeof userInfo === &#x27;string&#x27;) &#123;    var2 = userInfo;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>never类型</p>
<ol>
<li><p>表示永远不存在的值的类型</p>
</li>
<li><p>never常做函数的返回值类型,使用的依据是:<strong>返回never的函数必须存在无法达到的终点</strong></p>
<ol>
<li><p>什么叫做函数存在无法到达的重点呢,意思就是这个函数执行的时候,就不可能执行到末尾,<strong>比方说函数内部是一个while死循环,比方说函数内部恒有异常抛出,而无法执行到函数的末尾</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateError</span> (<span class="params">message: string, code: number</span>) </span>&#123;    <span class="keyword">throw</span> &#123;<span class="attr">message</span>: message, <span class="attr">errCode</span>: code&#125;;&#125;<span class="built_in">console</span>.log(generateError(<span class="string">&#x27;something error occured!&#x27;</span>, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用鼠标查看函数类型的时候，其返回值是void，但是打印后并没有undefined值，这意味着其根本无法到达函数结束的位置，所以返回值类型实际上是<code>never</code></li>
<li>在这种场景下，因为ts预测返回值类型是void类型，更明确的做法是，显式指定为never类型</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>类型断言,实际上就是把不确定类型的变量(比如 any或者null)转为其他明确类型的过程,<strong>表明程序员自己明确这个变量的类型,只是对于编译器的一个明确而已,对运行过程无影响</strong>，最典型的应用场景就是对于HTML元素的判断（ts不会分析html，所以在ts中进行DOM操作时，常常需要用到类型断言）。</p>
<ol>
<li>尖括号</li>
<li>as</li>
</ol>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> demo:<span class="built_in">any</span> = <span class="string">&#x27;123&#x27;</span><span class="keyword">let</span> len:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt; demo).lengthconsole.log(len)<span class="keyword">let</span> len1:<span class="built_in">number</span> = (demo <span class="keyword">as</span> <span class="built_in">string</span>).lengthconsole.log(len1)<span class="comment">// 类型断言是as ..前边的！也是一种断言，表示其前边的对象肯定存在，非null，如果不确定非null，则加上显式的if check运行时判断，ts也能理解并不再报错// as的作用是告诉ts此dom对象是HTMLInputElement对象，有value属性，所以下方调用value属性不会报错const input1 = document.getElementById(&quot;num1&quot;! as HTMLInputElement; // const input1 = &lt;HTMLInputElement&gt; document.getElementById(&quot;num1&quot;)!;console.log(input1.value);</span></span><br></pre></td></tr></table></figure>

<h2 id="ts编译器的配置"><a href="#ts编译器的配置" class="headerlink" title="ts编译器的配置"></a>ts编译器的配置</h2><ul>
<li><p>watch mode</p>
<ul>
<li>使用light-server 解决了开发中不得不刷新页面查看页面设置的问题，但是每一次修改ts文件，都需要手动执行<code>tsc **.ts</code>才能得到编译的结果，因此引入ts编译器的监听模式，监听工程内文件的内容变动，自动触发编译过程</li>
<li><code>tsc **.ts -w</code>或<code>tsc **.ts --watch</code>使用监听模式，监听某特定文件的变动，此时命令行会阻塞，不要关闭<ul>
<li><strong>注意这种环境下就不要打开vscode的自动保存模式了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>配置文件</p>
<ul>
<li><p>有没有更灵活的配置方式呢？只监听一个文件实际上也不常用，一个项目中可能会编辑多个源文件    </p>
</li>
<li><p>在工程所在项目中执行<code>tsc --init</code>告诉编译器，此文件夹就是ts项目的根目录，并创建一个<code>tsconfig.json</code>作为配置文件</p>
</li>
<li><p>在根目录执行<code>tsc</code>会编译项目中所有的ts文件，<code>tsc -w</code>会监听项目中的所有的ts文件的文件变动，以触发重新编译</p>
</li>
<li><p>注意，配置文件的配置只会在使用<code>tsc</code>命令是生效，而不会在<code>tsc **.ts</code>这种编译单个文件而不是编译整个工程的命令中生效</p>
</li>
<li><p>配置文件详述：</p>
<ul>
<li><p>配置文件的可配置项肯定是一直更新的，最权威的最新的解释，参考<a target="_blank" rel="noopener" href="https://www.staging-typescript.org/tsconfig">官方网站</a></p>
</li>
<li><p>exclude</p>
<ul>
<li><p>默认tsc把项目目录下的所有的ts文件视为项目源文件，可以使用此配置排除特定的ts文件，此后，执行<code>tsc</code>不会对特定文件进行编译操作</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    ..  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;**/*.dev.ts&quot;</span>  ]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用通配符</li>
<li>一般会把<code>node_modules</code>文件夹排除，<strong>但是这是默认的配置</strong>，如果显式指定此key的话，应带上<code>node_modules</code></li>
</ul>
</li>
</ul>
</li>
<li><p>include</p>
<ul>
<li>将特定文件添加到项目中    </li>
<li><strong>默认是添加根目录中的所有文件，所以如果显式配置此节点的话，需要把项目中所有的文件列到此节点中（有点麻烦）</strong></li>
<li>如果include与exclude出现冲突，文件的包含情况是：<strong>include - exclude</strong></li>
</ul>
</li>
<li><p>files</p>
<ul>
<li>类似于include，但是只能添加单个文件，而不能添加文件夹，因为适用于小项目，实际上并不常用</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>此key时最关键的部分，可以定义具体的编译行为</p>
<ul>
<li><p>target 编译为哪个版本的js</p>
</li>
<li><p>module 模块的组织方式</p>
</li>
<li><p>lib：<strong>默认是被注释的，但是默认会加载DOM Api，以及target中设置的js版本中的一些默认对象方法</strong>，如果打开注释自定义，默认的就会失效，比方说要写nodejs的代码，就不用加载dom</p>
<ul>
<li>默认情况下，lib应该包含以下几个包（全部用标识符标，而不会是路径什么的）</li>
<li>“DOM”</li>
<li>“ES6”</li>
<li>“DOM.Iterable”</li>
<li>“ScriptHost”</li>
</ul>
</li>
<li><p>allowJS，对js结尾的文件也进行编译</p>
</li>
<li><p>checkJs，对js结尾的文件进行审查并在编译时进行错误报告</p>
</li>
<li><p>jsx React框架设置相关</p>
</li>
<li><p>declaration 在编写第三方lib的时候，设置为true会自动生成.d.ts的manifest文件</p>
</li>
<li><p>declarationMap与declaration类似</p>
</li>
<li><p><strong>sourceMap</strong>，针对ts文件生成.map文件，其作用在于：在Chrome控制台的Source中进行源代码的debug时，默认只能看到js，并只能在js中进行debug，有了对应的.map文件后，浏览器就能展示对应的ts文件，并能在ts上进行断点调试</p>
</li>
<li><p>outFile 暂时未说明</p>
</li>
<li><p>outDir  将输出导入到指定文件中</p>
</li>
<li><p>rootDir</p>
<ul>
<li>以上两个的设置目的为：<br>在实际工程中常常把js与ts分开放置，ts放在src文件夹，编译出的js放在dist文件夹，但是默认情况下，js会编译到ts的同目录中，因此可以在outDir中进行配置</li>
<li>outDir会维持与源代码所在目录的一样的目录结构</li>
<li>rootDir设置的就是源代码路径，ts只会编辑此目录下的ts文件，其作用也可以使用include和exclude实现</li>
</ul>
</li>
<li><p>removeComments 编译好的js文件中不会携带ts文件中的注释</p>
</li>
<li><p>noEmit 只进行编译检查，但是不创建js结果文件</p>
</li>
<li><p>downlevelIteration 当target是ES5甚至ES3时，对于for-of的支持可能有问题，此时开启此选项来获得更详细的编译信息 </p>
</li>
<li><p>noEmitOnError 默认为false，此时，即便es编译出错，也会产生对应的js文件，应用场景在于，开发者明确知道即便ts异常报错，但是ts编译器担心的事情是肯定不会发生的，所以直接产出js也可以（其实是不太好的做法）；如果设置为true，编译出错则不会有对应的js产出（推荐）</p>
<ul>
<li>注意，设置为true后，一个文件编译失败，整个工程的文件都不会有js产出</li>
</ul>
</li>
<li><p>strict 执行严格的类型检查</p>
<ul>
<li><p>默认为true，设置此项目为true相当于设置所有的<code>Strict Type-Checking Options</code>选项为true，如果要单独进行精细控制的话，不必要把此项设置为false，直接在下边的选项中配置false即可</p>
<ul>
<li><p>noImplicitAny，如果在函数形参中不指定类型（any类型），就会报错，但是对于变量的any类型则不会报错，这是因为，变量的类型是可以跟踪和自动转化的，但是对于函数形参的类型并不能自动跟踪，并且跟踪也无意义，因为不同的类型在函数中都应有不同的行为，或者根本只能接受特定类型的形参。</p>
<ul>
<li><p>并不是所有的函数定义中的形参不指定类型都会报错，比如下边的案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);<span class="keyword">if</span> (button) &#123;    <span class="comment">// ts明确知道 addEventListener函数执行回调函数时的传入的参数值的类型，所以不需要自己在回调函数中特意指定参数类型    button.addEventListener(`click`, event =&gt; console.log(event));&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>strictNullChecks对于可能为null的变量报错，比如前边例子中的button对象的获取，因为不能确定趋势存在此button，所以是潜在的null，因此报错，<strong>可以使用<code>!</code>断言符号进行非null的断言声明以避免此error，或者自己并不十分肯定不为null，可以添加if检查，此时ts也会检查到风险能被控制住，亦不会报错</strong></p>
</li>
<li><p>alwaysStrict 生成的js文件使用strict模式（js文件开头会有<code>&quot;use strict&quot;;</code>）</p>
<ul>
<li>关于strict模式，参考<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-strict.html">菜鸟网站的介绍</a></li>
</ul>
</li>
<li><p>strictFunctionTypes 与class和interface相关</p>
</li>
<li><p>strictBindCallApply 与bind函数、call函数和apply函数相关，这三个函数用来更改js中的运行时环境，也就是更改this指向的对象，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coco1s/p/4833199.html">具体参考此篇文章</a>，印象笔记也有对应的收藏</p>
<ul>
<li><p>此配置用来检查，以上三个函数的调用中，是否传入了合适的参数，举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saySomething</span> (<span class="params">message: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&quot;say: &quot;</span> + message);&#125;<span class="comment">// 此处第二个参数如果不与saySomething的参数匹配就会报错saySomething.call(null, &#x27;hello&#x27;);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>strictPropertyInitialization 与class和interface相关</p>
</li>
<li><p>noImplicitThis 和this相关</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Additional Checks相关，此部分的配置可以用来提高代码质量，而并非严格的检查，比如不能有未使用的局部变量等等</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TS-中的支持的Modern-JS特性"><a href="#TS-中的支持的Modern-JS特性" class="headerlink" title="TS 中的支持的Modern JS特性"></a>TS 中的支持的Modern JS特性</h3><ul>
<li>所谓的Modern JS指的是ES6或者其他更新版本的js</li>
<li>如果要查看Modern JS 语法或者关键词在何种开发、编译环境和浏览器环境的支持程度，可以查看<a target="_blank" rel="noopener" href="https://kangax.github.io/compat-table/es6/">此网站</a></li>
<li><strong>在ts中介绍modern js特性的意义在于知晓ts支持这些新特性，并且也能将其编译成旧版本的不支持这些特性的js脚本，以支持在旧版本的浏览器中运行</strong></li>
</ul>
<ol>
<li><p>使用let代替var</p>
<ol>
<li><p>var的作用域是全局作用域（定义在函数外部）或者函数作用域（定义在函数内部）</p>
</li>
<li><p>let的好处就是引入了块级作用域（全局作用域与函数作用域与var类似）,看看下边的令人匪夷所思的js代码吧</p>
</li>
<li><p>一个需要更改的操作就是之前经常在var定义之前就去访问变量,<strong>但是在let定义的时候,在其代码块内,声明语句之前就是暂时性死区,不能访问</strong>但是也有看似特殊的情况</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error console.log(a);function demo ()&#123;    // 无error    return a;&#125;// 下边定义的a与函数中的a位于同一个作用域,所以函数内可以访问,并且函数在每调用的时候可以设计为访问变量,但是必须确保函数调用的时候,变量已经定义好了let a: number = 1;// 1console.log(demo());</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在同一个块作用域里,只能定义一次变量,不能重复定义同名变量,但是在嵌套的块作用域里可以有同名的变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;&#123;    <span class="keyword">let</span> a = <span class="number">12</span>;    <span class="comment">// 12    console.log(a);&#125;// 0console.log(a);</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>let变量在循环体中的每一次迭代都是一个新的环境</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);&#125;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>用var定义的变量,在每一次迭代的环境都会被保存下来,因此每次执行setTimeout函数时,延迟时间都是正常的,但是循环结束后i已经是10了此时延时到了执行的时候就会打印一堆10出来</p>
</li>
<li><p>用let定义的变量每次迭代都会有一个独有的环境,不会随着i的变化而进行更新保留,所以打印输出的是0-9</p>
</li>
</ol>
</li>
<li><p>const</p>
<ol>
<li> const修饰符<strong>实际上其作用域规则与let一样（同样拥有块作用域）</strong>,但是其修饰的变量只能被赋值一次</li>
<li> <strong>如果const修饰的是一个对象的话,那么实际上只要对象的引用地址不变即可,对象内部的属性的值是可以任意改变的, 当然也可以设置对象成员是只读</strong></li>
<li> <strong>什么时候使用let,什么时候使用const?就跟Java中使用private一样,没必要访问/改变的全部弄成const类型</strong></li>
</ol>
</li>
<li><p>箭头函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b;<span class="comment">// 注意此处，当箭头函数的参数只有一个，并且要使用如下的简化写法的时候，不能在参数处直接指定类型，而必须在函数变量处指定类型// 除非ts明确调用函数的时候，函数的参数的类型，比如下边的button的案例const printS: (msg: string | number) =&gt; void = messgae =&gt; console.log(messgae);printS(addFunc(1, 2));const button = document.querySelector(&#x27;button&#x27;);if (button) &#123;    // ts明确知道 addEventListener函数执行回调函数时的传入的参数值的类型，所以不需要自己在回调函数中特意指定参数类型    button.addEventListener(`click`, event =&gt; console.log(event));&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数参数默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number=<span class="number">1</span>, b: number = <span class="number">2</span></span>) =&gt;</span> a + b;<span class="built_in">console</span>.log(addFunc(<span class="number">2</span>, <span class="number">3</span>));<span class="built_in">console</span>.log(addFunc());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>格式就是在形参后加上<code>= 默认值</code>即可</p>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>可以全部参数都赋予默认值，但是如果只有部分参数赋予默认值的情况下，必须是后边的参数赋予默认值，而不是排在前边的，其原因在于<strong>实参是按照参数顺序对应到形参的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number=<span class="number">1</span>, b: number</span>) =&gt;</span> a + b;<span class="comment">// okconsole.log(addFunc(2, 3));// error 因为a 被赋予2 但是b没有默认值，应该也被赋予一个值，但是这样的话默认值的设置也没有意义了console.log(addFunc(2));</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>除了使用上述的方式实现函数参数默认值的设置外，还有另外一种类似的方式，即使用解构来实现函数参数默认值（严格来说不是函数参数，但是形式类似，所以就放在这）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?:用来表示不确定属性是否存在,或者说在类型检查中不强求有此属性,或者说是设置属性为可选属性// 可以在接口 抽象类或者自定义类型中使用// 可以在属性上使用，也可以在方法上使用function func (obj:&#123;a:string,b?:number&#125;):void &#123;    // 使用结构间接设定了默认值    // 相当于ab声明的时候，b先初始化再赋值，而a是声明粥通过解构进行初始化    let &#123;a,b=12&#125; = obj    console.log(a,b)&#125;func(&#123;a:&quot;李佳&quot;,b:12&#125;) // 李佳 12func(&#123;a:&quot;李佳&quot;&#125;) // 李佳 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>展开</p>
<ol>
<li><p>使用<code>...</code>来执行展开操作，或者说<strong>从数组或对象中获取值，将数组或对象中的成员拆散为单个的成员，也可以理解为把数组和对象拆解为以逗号分隔的对个成员对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;cook&#x27;</span>, <span class="string">&#x27;play&#x27;</span>];<span class="comment">// 方法0 在定义新array时放入旧的arrayconst newarray = [&#x27;learn&#x27;, ... array];// 目的为将array导入到newarray中// 方法1newarray.push(array[0], array[1]);// 方法2newarray.push(... array);const person1 = &#123;    name: &#x27;lee&#x27;,    age: 20&#125;;// 复制上边的person1对象，注意是实体赋值而不是指针的赋值const person2 = &#123; ... person1&#125;;console.log(person2);</span></span><br></pre></td></tr></table></figure></li>
<li><p>展开相对于解构就变得索然无味了，但是还是有不少的坑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj:&#123;<span class="attr">a</span>:number,<span class="attr">c</span>:string&#125; = &#123;<span class="attr">a</span>:<span class="number">12</span>,<span class="attr">c</span>:<span class="string">&quot;李佳&quot;</span>&#125;<span class="keyword">let</span> obj1 = &#123;...obj,<span class="attr">a</span>:<span class="number">22</span>&#125; <span class="comment">// 后边的a属性值为22会覆盖展开后的a属性为12// a: 22 c: &quot;李佳&quot;console.log(obj1);class Demo &#123;    a:string = &quot;李佳&quot;    function ():void &#123;        console.log(this.a)    &#125;&#125;let demo:Demo = new Demo()let demo1 = &#123;...demo&#125;console.log(demo1) //你会发现方法体丢了，只剩下属性a</span></span><br></pre></td></tr></table></figure></li>
<li><p>将展开操作符作用与函数形参的时候，就能实现函数形参的参数扩展符，<strong>此过程可以视作是展开的逆操作，即把以逗号分隔的参数打包为数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...会将调用此函数时传入的以逗号相隔的参数打包成数组并赋予形参，然后在内部处理此数组const addFunction = (...numbers: number[]) =&gt; &#123;    let result = 0;    for (let num of numbers) &#123;        result += num;    &#125;    return result;&#125;console.log(addFunction(1,2,3,4,5,6,7));const addFunction = (name: string, ...numbers: number[]) =&gt; &#123;    let result = 0;    for (let num of numbers) &#123;        result += num;    &#125;    return result;&#125;console.log(addFunction(&#x27;Lijia&#x27;,1,2,3,4,5,6,7));const addFunction = (...numbers: number[]) =&gt; &#123;		// 使用数组的reduce方法更加简洁    return numbers.reduce((curResult, curValue) =&gt; &#123;        return curResult + curValue;    &#125;, 0);&#125;console.log(addFunction(1,2,3,4,5,6,7));// 明确需要限定个数的参数时，也可以使用元组类型const addFunction = (...numbers: [number, number, number]) =&gt; &#123;		// 元组类型本质上与数组类型一样    return numbers.reduce((curResult, curValue) =&gt; &#123;        return curResult + curValue;    &#125;, 0);&#125;console.log(addFunction(1,2,3));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，<strong>当在函数定义中发现此<code>...</code>时，如上边的案例，不要把参数类型当做数组，函数接受的应该是以逗号分隔的一系列参数，而不是参数数组</strong></li>
</ul>
</li>
<li><p>在数组或函数参数中使用展开语法时, 该语法只能用于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator">可迭代对象</a></p>
<ol>
<li>典型的比如：object类型的对象不是可迭代对象</li>
</ol>
</li>
</ol>
</li>
<li><p>解构</p>
<ol>
<li><p>什么是解构?</p>
<ol>
<li><p><strong>与展开一样，解构也是针对数组与对象的，与展开的区别在于，展开是整体的展开，只能获得一堆分散的数据，但是这些分散的数据必须仍然整体起作用，如果想获得其中离散的个体对象的话需要使用解构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];<span class="keyword">const</span> [n1, n2, ...remainnumber] = array;<span class="built_in">console</span>.log(array, n1, n2, remainnumber);<span class="keyword">const</span> person2 = &#123;    <span class="attr">firstName</span>: <span class="string">&#x27;lee&#x27;</span>,    <span class="attr">age</span>: <span class="number">23</span>&#125;<span class="comment">// 数组的解构是严格按照顺序的，但是object的解构不能保证顺序，所以需要指定与key同名的变量才能执行解构const &#123;firstName, age&#125; = person2;console.log(firstName, age);// 如果不想使用同名的属性可以使用js原生支持的属性别名设置const &#123;firstName: userName, age&#125; = person2;// 此时就可以使用userName这个变量了console.log(userName, age);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意解构后的原对象、数组没有被更改</strong></li>
<li><strong>解构的过程也是变量创建并初始化的过程</strong></li>
</ul>
</li>
<li><p>解构有以下几种使用场景：</p>
<ol>
<li><p>变量做交换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的解构一直出错....let c = &#x27;lee&#x27;;let d = &#x27;jia&#x27;;[c, d] = [d,c];// jia leeconsole.log(c, d);</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组的解构,创建剩余变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略任意位置的元素let [,second,,last] = [1,2,3,4]console.log(second,last) // 2,4</span></span><br></pre></td></tr></table></figure></li>
<li><p>作为函数参数 (在传参的过程中完成解构)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用于函数参数function demo ([a,b]:[number,number]):void &#123;    console.log(a,b)    &#125;let c:[number,number] = [1,2]demo(c)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><ol>
<li>接口是由ts提供的，原生js中无接口</li>
<li>接口中的成员变量不能初始化<ol>
<li><strong>与Java不同，Java中接口如果定义了成员变量则必须初始化</strong></li>
</ol>
</li>
<li>实际上接口定义与object类型声明除了用了<code>interface</code>关键字之外就是一模一样，但是interface更多的是做类的抽象，定义类的结构，赋予类功能（必须实现特定方法）</li>
<li>与Java一样，同样支持多实现</li>
<li>在接口中只能使用<code>readonly</code>这一种修饰符，不能使用其他的修饰符（public、protected、private等等）<ol>
<li><strong>对于接口中定义的变量，其实现类中对于该变量的实现只能使用public修饰（假设如果使用其他修饰符修饰的话，此变量则不能自有访问，那么接口就失去了其意义）</strong></li>
<li>在object对象类型的声明中也可以使用<code>readonly</code>修饰符</li>
</ol>
</li>
<li>与Java一样，同样支持并建议使用面向接口的编程，将提升程序的扩展性</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;    name: <span class="built_in">string</span>;&#125;<span class="keyword">interface</span> Greetable <span class="keyword">extends</span> Named&#123;    <span class="keyword">readonly</span> content: <span class="built_in">string</span>;    greet (context: <span class="built_in">string</span>): <span class="built_in">void</span>&#125;<span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Greetable</span> </span>&#123;        <span class="title">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> content:<span class="built_in">string</span></span>) &#123;    &#125;    <span class="function"><span class="title">greet</span>(<span class="params">context: <span class="built_in">string</span></span>)</span> &#123;        <span class="built_in">console</span>.log(context + <span class="string">&#x27;hey! this is&#x27;</span> + <span class="built_in">this</span>.name);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Greetable</span> </span>&#123;        <span class="title">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> content:<span class="built_in">string</span></span>) &#123;    &#125;    <span class="function"><span class="title">greet</span>(<span class="params">context: <span class="built_in">string</span></span>)</span> &#123;        <span class="built_in">console</span>.log(context + <span class="string">&#x27;wow! wo wow wow&#x27;</span> + <span class="built_in">this</span>.name);    &#125;&#125;<span class="keyword">const</span> greetActionObject: Greetable = <span class="keyword">new</span> Person(<span class="string">&#x27;lee&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>);greetActionObject.greet(<span class="string">&#x27;##%&#x27;</span>);<span class="keyword">const</span> greetActionObject1: Greetable = <span class="keyword">new</span> Dog(<span class="string">&#x27;TD&#x27;</span>, <span class="string">&#x27;wangwang&#x27;</span>);greetActionObject1.greet(<span class="string">&#x27;##%#@%$@&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>在字面量对象中，方法可以直接定义出来，而不是必须赋给一个属性</strong>，对应的在对object类型的类型描述中，也有两种描述方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person:&#123;    <span class="attr">name</span>: string;    age: number;    <span class="comment">// 函数类型声明    greet: () =&gt; void;    // 函数声明    func(): void&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li><p>与Java一样，同样支持接口继承，<strong>并且同样支持接口的多继承</strong></p>
</li>
<li><p>js中的接口除了可以作为class（object）的模板之外，还可以作为函数的模板（因为函数也只是对象而已），与函数类型相似</p>
<ol>
<li><p>本质上把函数看做一个拥有特定函数的对象，将此对象抽象成接口即可（但是也包含特殊语法，就是略去函数名）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type addFn = (a: number, b: number) =&gt; number;interface addFn &#123;    // 无函数名指定    (a:number, b:number) : number&#125;const add:addFn = (n1: number, n2: number) =&gt; n1 + n2;const result = add(1, 2);</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>可选属性与方法（<strong>可以用在接口中，也可以用在object类型声明中，当然也可以用在class定义中</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此接口的实现类可以没有displayName属性和showName方法interface Named &#123;    name: string;    // 可选符号等价于 displayName: string | undefined     displayName?: string;    showName ?(): void&#125;// no error    let obj: &#123;a?: string; b: number&#125; = &#123;    b: 12&#125;;  class Man &#123;    name: string;    carrer ?: string		// 以下两种构造器都可实现构造器方法中参数可选，前者默认参数为undefined，后者默认参数是指定参数        // constructor (name: string, carrer?: string) &#123;    //     this.name = name;    //     this.carrer = carrer;    // &#125;    constructor (name: string, carrer: string = &#x27;None&#x27;) &#123;        this.name = name;        this.carrer = carrer;    &#125;&#125;let man:Man = new Man(&#x27;lee&#x27;);</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>当编译选项选择es5时，查看编译结果会发现，interface完全是ts提供的编译期的一个辅助特性，es5之前的js中完全无此概念</strong></p>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p>在ts的角度看，实际上就是创建了一个新的类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string ;		// 构造器函数不是必须的，默认是空参数的构造器    // 子类中的构造器函数默认是直接调用父类构造器super(参数列表，如果有的话)    constructor (n: string) &#123;        this. name = n;    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果父类的构造器函数被protected修饰，子类中的构造器函数必须显示声明</li>
<li><strong>java中也是类似的机制,不同之处在于父类构造函数被protected修饰的时候,子类中的构造函数还是可以省略的,与正常的子类继承一致</strong></li>
</ul>
</li>
<li><p>TypeScript里的类只是<strong>JavaScript ES6</strong>里常用的基于原型面向对象编程的简写(语法糖)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params">n</span>)</span> &#123;        <span class="built_in">this</span>.name = n;    &#125;&#125;<span class="keyword">const</span> accounting = <span class="keyword">new</span> Department(<span class="string">&#x27;Accounting&#x27;</span>);<span class="built_in">console</span>.log(accounting);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了类属性不能直接定义外，其余的都一样，但是如果编译的target是es5的话，实现就不一样了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Department = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">// 此内部函数就是构造器函数    function Department(n) &#123;        this.name = n;    &#125;    return Department;&#125;());var accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>es6中的class 不过就是上述代码过程的语法糖</li>
</ul>
</li>
</ul>
</li>
<li><p>类方法中的this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;       name: string;    <span class="title">constructor</span> (<span class="params">n: string</span>) &#123;        <span class="built_in">this</span>. name = n;    &#125;    <span class="comment">// 方法之间不用加;隔开    describe () &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);accounting.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如上注释，在类内方法中引用类字段时，必须使用this关键字，<strong>但是此this是有坑的，this指向的是执行当前方法的对象，谁执行此方法，this对象指向谁（并非所有场景下都是如此，可以参考修饰器章节中关于类方法修饰器返回值案例中的描述）</strong></p>
<ul>
<li><p>在前边的例子中，this执行accounting这个Department类型的实例</p>
</li>
<li><p>另外的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this. name = n;    &#125;    // 方法之间不用加;隔开    describe () &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);// 创建字面量对象// 此处仅将方法引用传递给dedcribe属性，与accounting这个实例无任何关系const accountingCopy = &#123;describe: accounting.describe&#125;;// Department: undefined// 此时执行的方法确实是Department class中定义的方法，但是与accounting实例无关，且其中的this指向的是方法的调用者accountingCopy，而其并无name属性，所以是undefinedaccountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二个案例的解决方案：</p>
<ul>
<li><p>当类中的方法内部使用了this关键字时候，实际上，this作为一个隐形的形参，在方法被被调用时，调用者的引用会被赋予到此形参，我们可以显式指定this形参，并为其添加类型检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this. name = n;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;const accounting = new Department(&#x27;Accounting&#x27;);const accountingCopy = &#123;describe: accounting.describe&#125;;// error accountingCopy的类型不是Department，因此在执行函数时，会因参数的类型检查组织accountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ts是如何检查类型是否一致的？</p>
<ul>
<li><p>无论是class与class还是class与字面量对象的比较，比较原则就判断是否有一样的属性，因此只要在上述的字面量对象中添加name属性即可避免报错</p>
<ul>
<li><p><strong>有相同的属性是最高比较原则，如果提供的值的类型中不仅有对应的属性，还有其他更多的属性，ts认为其仍然满足类型筛查</strong>，以下就是案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this.name = n;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;class DepartmentCopy &#123;        name: string;    num: number;    constructor (n: string, num: number) &#123;        this.name = n;        this.num = num;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;    func () &#123;    &#125; &#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);// 创建字面量对象// 此处仅将方法引用传递给dedcribe属性，与accounting这个实例无任何关系const accountingCopy = new DepartmentCopy(&#x27;lee&#x27;, 12);// Department: undefined// 此时执行的方法确实是Department class中定义的方法，但是与accounting实例无关，且其中的this指向的是方法的调用者accountingCopy，而其并无name属性，所以是undefinedaccountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>综上，尽量不要这样class与字面量混用吧</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>当一个类型中有private或者protected类型的成员的时候,与其比较的类型中必须也有对应的成员,并且都是来自同一处声明（同一类或者是继承关系）才行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;    protected name: string;    <span class="function"><span class="title">constructor</span>(<span class="params">theName: string</span>)</span> &#123; <span class="built_in">this</span>.name = theName; &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Rhino</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">super</span>(<span class="string">&quot;Rhino&quot;</span>); &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;    protected name: string;    <span class="function"><span class="title">constructor</span>(<span class="params">theName: string</span>)</span> &#123; <span class="built_in">this</span>.name = theName; &#125;&#125;<span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">&quot;Goat&quot;</span>);<span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();<span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>);animal = rhino;       <span class="comment">// private或者protected都可以// animal = employee; // 错误: 因为protected和private属性 Animal 与 Employee 不兼容.尽管结构一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修饰符（public，private，protected，readonly（可与前边的混合使用））</p>
<ol>
<li>与Java中的含义类似<ol>
<li>如果不指定private，默认就是public，没有Java中所谓的包作用域</li>
<li><strong>事实上，js中只有public修饰符，其余的是ts引入的，也只能在编译时进行限制</strong></li>
<li><strong>需要注意的是只读属性必须在声明的时候,或者在构造函数中被初始化</strong></li>
<li><strong>protected与private类似，前者是只能在本类中访问，后者是在本类以及子类中访问，注意二者都是在类内部访问，在类外部访问是不允许的</strong></li>
</ol>
</li>
<li>除了传统的构造函数的使用方法之外（比较麻烦，所有的需要初始化的属性都需要添加在构造器中并在构造器中进行赋值）,<strong>在构造函数的参数中直接使用public或private修饰符,等同于创建了同名的成员变量</strong>，并且在使用new关键字创建实例时，就完成了对属性的初始化</li>
</ol>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;        <span class="keyword">private</span> employee: <span class="built_in">string</span>[] = [];    <span class="title">constructor</span> (<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> id: <span class="built_in">string</span>, <span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;            &#125;        describe (<span class="built_in">this</span>: Department) &#123;                <span class="built_in">console</span>.log(<span class="string">&#x27;Department: &#x27;</span> + <span class="built_in">this</span>.name);    &#125;    addEmployee (employee: <span class="built_in">string</span>) &#123;        <span class="built_in">this</span>.employee.push(employee);    &#125;    describeEmployee () &#123;        <span class="built_in">console</span>.log(<span class="built_in">this</span>.employee);    &#125;&#125;<span class="comment">// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Dp1&#x27;,&#x27;Accounting&#x27;);accounting.addEmployee(&#x27;lee&#x27;);accounting.addEmployee(&#x27;song&#x27;);accounting.describeEmployee();</span></span><br></pre></td></tr></table></figure>

<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><ul>
<li><p>与Java中是同样的概念</p>
</li>
<li><p>同样只能单继承而不能多继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span></span>&#123;    <span class="comment">// 与Java一样子类会获得所有的父类方法，并且有默认的构造函数与属性，并且在默认的构造函数中自动调用父类的构造方法，如果要自定义子类构造器的话，需要首先显式执行父类构造器方法    // 此处id不用加修饰符，是因为父类中已经有同名成员变量，虽然是private，但是也不允许子类中出现命名冲突    constructor (id :string, public admins: string []) &#123;        super(id, &#x27;IT&#x27;);    &#125;    &#125;class AccountingDepartment extends Department &#123;    constructor (id: string, private reports: string []) &#123;        super(id, &#x27;Accounting&#x27;);    &#125;    addReports (text: string) &#123;        this.reports.push(text);    &#125;    printReports () &#123;        console.log(this.reports);    &#125;&#125;const it = new ITDepartment(&#x27;Dp1&#x27;,[&#x27;lee&#x27;]);it.addEmployee(&#x27;lee&#x27;);it.addEmployee(&#x27;song&#x27;);it.describeEmployee();console.log(it);const account = new AccountingDepartment(&#x27;Account1&#x27;, []);account.addReports(&#x27;something goes wrong&#x27;);account.printReports();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于子类中的构造器函数：<ul>
<li>在Java中如果父类的构造器函数不是默认的空参数，那么子类必须显式声明构造器函数，并首先调用super函数</li>
<li><strong>但是在ts中，如果父类的构造器函数不是默认的空参数，子类也不用显式声明自己的构造器函数，因为此时子类的默认的构造器函数已经是包含参数并且内部调用super，除非有自己的其他的处理逻辑，否则不需要显式声明</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>复写</p>
<ul>
<li>成员变量</li>
<li>成员函数<ul>
<li>与Java中的类似，但是注意这个在IDE中并没有提示，自己知道就行</li>
</ul>
</li>
</ul>
</li>
<li><p>getter和setter</p>
<ul>
<li><p>js类中的getter与setter与Java中的概念一致，但是有自己的独特的标识方式，并且可以用属性的方式调用（<strong>不用在调用时加括号</strong>）</p>
<ul>
<li>getter：使用get关键字，必须有返回值，调用方式是访问属性</li>
<li>setter：使用set关键字，不需要返回值，调用方式是为属性赋值，<strong>setter与getter的名字可以一致，类似于Java中的方法重载</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter    get recentReports () &#123;        if (!this.lastReport) &#123;            throw new Error(&#x27;no lastReport.&#x27;);        &#125;        return this.lastReport;    &#125;    // setter    set recentReports (report: string) &#123;        if (!report) &#123;            throw new Error(&#x27;please set valid report&#x27;);        &#125;        this.addReports(report);    &#125;const account = new AccountingDepartment(&#x27;Account1&#x27;, []);account.recentReports = &#x27;end year report&#x27;;console.log(account.recentReports);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态属性与方法</p>
<ul>
<li>同样的使用static修饰符即可</li>
<li><strong>在静态方法中也可以使用this关键字来调用静态方法与属性，此时该this关键字的指向不再是实例，而是指代的类本身，与直接使用类名调用效果一样</strong></li>
<li>静态属性可以不初始化，但是非静态属性不初始化（无显示初始化，并且也没有在构造器中初始化）会报错</li>
</ul>
</li>
<li><p>抽象类与抽象方法</p>
<ul>
<li><p>同样使用abstract关键字，抽象方法只能定义在抽象类中，抽象类中抽象方法与普通方法可以共存</p>
<ul>
<li><strong>可以使用abstract关键字修饰成员变量，并且可以不初始化，即要求此属性在子类中必须得到初始化赋值</strong></li>
<li><strong>在Java中此关键字不能用来修饰成员变量</strong></li>
</ul>
</li>
<li><p><strong>抽象类的子类必须复写或者说实现对应的抽象方法</strong></p>
</li>
<li><p>抽象方法没有方法体，但是必须明确定义出方法参数列表与返回值类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract describe (<span class="built_in">this</span>: Department):<span class="keyword">void</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>抽象类不能被实例化</strong></p>
</li>
<li><p><strong>抽象类与接口一样，其内部的方法都可以使用?来表示非必须</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract configure ?(): <span class="keyword">void</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单例模式</p>
<ul>
<li>与Java类似<ul>
<li>构造函数私有化，设置静态实例变量</li>
<li>设置静态获取实例方法<ul>
<li>判断是否已经初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ts中的复杂类型"><a href="#ts中的复杂类型" class="headerlink" title="ts中的复杂类型"></a>ts中的复杂类型</h2><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li><p>与联合类型是类似的方向，联合类型是或的关系，而复合类型是与的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Admin = &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;type Employee = &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;<span class="comment">// 复合类型// 此类型拥有两种类型的全部属性type ElevaltedEmployee = Admin &amp; Employee;</span></span><br></pre></td></tr></table></figure></li>
<li><p>复合类型也可以使用接口的继承来实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Admin  &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;interface Employee  &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;interface ElevaltedEmployee <span class="keyword">extends</span> Admin, Employee&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复合类型运算符可以作用于任意两个类型，包括自定义类型和默认类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type a = number | string;type b = number | boolean;<span class="comment">// 本质上c就是number类型// 对于两个联合类型来说，其复合类型就是两个联合类型的共有类型type c = a &amp; b;// type errorlet var1:c = &#x27;1&#x27;;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>用以构建更加灵活的对象，即只指定对象中的属性的存在与属性的类型，但是并不指定属性的名称属性的个数（甚至可以是0个，或者说使用索引类型构建的结构中的属性都是可选的），以此种类型的蓝图构建的对象可以更加灵活</p>
<ul>
<li>此特性用在设计对象结构当中，所以适用于interface定义与自定义type定义（字面量对象类型的结构定义）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此类型的对象中可以存储String类型的键值对，键的类型可以修改为除了boolean之外的其他类型(string number symbol)interface ErrorContainer &#123;    [prop: string]:string;&#125;let error_bag: ErrorContainer = &#123;    // 12可以被当做是String类型，但是反之不可    12: &#x27;email not valid&#x27;,    username: &#x27;user not fund&#x27;    // value的类型必须是string类型    // username: 12  // error&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ts中的函数重载"><a href="#ts中的函数重载" class="headerlink" title="ts中的函数重载"></a>ts中的函数重载</h2><ul>
<li><p>ts中的函数重载与Java中的不一样，目的一样，但是实现并不一样</p>
</li>
<li><p>ts中的函数重载只包含函数签名的重载，但是函数体不能重载，也就是说对于不同的函数签名，函数体都是同一个函数体</p>
<ul>
<li><strong>因此函数签名的形式应该与函数体对应，比如，原本函数中有两个参数，现在重载为1个参数，此时，如果函数体中在任何情况下都需要2个参数参与，则此重载是不被允许的</strong></li>
</ul>
</li>
<li><p>并且ts也不支持Java的那种重载，会报函数重复定义的错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上边的两行就是对于add函数的重载说明，function add (a: number, b: number):number;function add (a: string, b: string):string;function add (var1: number|string, var2: number|string) &#123;    // 不得不引入运行时类型检查，实际上此运行时类型判断即为ts的特性之一 type guardif (typeof var1 === &#x27;number&#x27; &amp;&amp; typeof var2 === &#x27;number&#x27;) &#123;    // 如果直接相加，会报错，因为ts只检测到了对Union类型使用+，而不会探究Union内部的类型，所以    // 暂时引入类型判断(type guard)    return var1 + var2;&#125; else &#123;    // 可以对Union类型使用toString 方法，因为不管其到底是Union内部的哪一种类型，都有此方法    return var1.toString() + var2.toString()&#125;&#125;console.log(add(1, 2));// no overload match this call console.log(add(1, &#x27;&#x27;));console.log(add(&#x27;李&#x27;, &#x27;佳&#x27;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述例子中，add原函数会的返回值是联合类型（这会导致，无法使用特定类型的方法），但是在参数类型确定的情况下，返回值的类型实际上也是确定的，然而ts并不能正确预测其类型，可以使用类型断言解决此问题，也可以使用上述的重载解决此问题</li>
<li>关于重载，有趣的是：上述的例子中，本来参数可以是number或String，但是一旦指定重载后，函数就只匹配重载的两种形式了，不能是(number, String)或(string, number)，除非再定义这两种的函数重载形式</li>
</ul>
</li>
</ul>
<h3 id="Optional-Chaining-可选链"><a href="#Optional-Chaining-可选链" class="headerlink" title="Optional Chaining(可选链)"></a>Optional Chaining(可选链)</h3><ul>
<li>前边的案例中实际已经用过，就是<code>?</code>，但是前边的使用都是用作可选的参数或者属性，这里用来在嵌套对象中进行判断<ul>
<li>对于未知来源的数据或者说是<strong>未定义在ts中的嵌套对象的数据结构</strong>，在js中需要使用多层嵌套的if-check来保证属性确实存在，在ts中可简洁的使用可选链达到这个目的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*userData: &#123;  job: &#123;    title: &#x27;&#x27;  &#125;,  ...&#125;if (fetchUserDataFromBackened &amp;&amp; fetchUserDataFromBackened.job) &#123;  const title = fetchUserDataFromBackened.job.title;&#125;*/</span><span class="comment">// fetchUserDataFromBackened是一类变量，可能是从用户输入拿到的或者是从后端拿到的数据，总之ts不清楚其具体的数据结构无法在编译时进行检查const title = fetchUserDataFromBackened?.job?.title;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>?</code>前的对象是undefined或null，那么就不会再继续向后使用<code>.</code>进行对象索引</li>
</ul>
<h3 id="Nullish-Coalescing-空值合并"><a href="#Nullish-Coalescing-空值合并" class="headerlink" title="Nullish Coalescing 空值合并"></a>Nullish Coalescing 空值合并</h3><ul>
<li>与上边的可选链是同样的使用情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fetchedUserData = &#123;    name: &#x27;lee&#x27;,    age: 12&#125;*/</span><span class="comment">// 如果fetchedUserData不是null或者undefined，那么就返回默认数据// 注意过滤null或undefined，不包含空字符串等console.log(fetchedUserData?? &#x27;DEFAULT DATA&#x27;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>空值合并与可选链的编译结果实际上就是用连续的逻辑判断来实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(fetchedUserData?.name);console.log(fetchedUserData === null || fetchedUserData === void 0 ? void 0 : fetchedUserData.name);// console.log(fetchedUserData?? &#x27;DEFAULT DATA&#x27;);console.log(fetchedUserData !== null &amp;&amp; fetchedUserData !== void 0 ? fetchedUserData : &#x27;DEFAULT DATA&#x27;);</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以发现二者的逻辑是一样的，只是使用场景不一样</p>
<ul>
<li>可选链用于多层数据结构的属性引用的场景</li>
<li>空值合并用于直接的（非null非undefined）判断</li>
</ul>
</li>
</ul>
<h2 id="ts中的泛型"><a href="#ts中的泛型" class="headerlink" title="ts中的泛型"></a>ts中的泛型</h2><ul>
<li><p>泛型同样仅在ts中支持，与原生js无关</p>
</li>
<li><p>ts中对于泛型的支持，可以从两个类型开始</p>
<ul>
<li><p>Array</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise: <span class="built_in">Promise</span>&lt;string&gt; = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;        resolve(<span class="string">&#x27;job is done&#x27;</span>);    &#125;, <span class="number">2000</span>);&#125;);promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>泛型的意义在于以下两者的结合</p>
<ul>
<li>向ts提供更丰富的类型信息，便于ts提供更好的类型支持</li>
<li>扩展函数或者class的功能，相当于引入了动态类型</li>
</ul>
</li>
<li><p>在函数中使用泛型</p>
<ul>
<li><p>定义一个merge函数用来执行类型复合的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*// ts只知道返回类型是objectfunction merge (objA: object, objB: object) &#123;    return Object.assign(objA, objB);&#125;*/</span><span class="comment">// 通过泛型的方式，将详细的类型信息告知了ts// ts推测返回类型是 T &amp; Vfunction merge&lt;T, V&gt; (objA: T, objB: V) &#123;    return Object.assign(objA, objB);&#125;// mergeresult类型是&#123;name: string; age: number&#125;const mergeResult = merge(&#123;name: &#x27;lee&#x27;&#125;, &#123;age: 23&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>并不是只有class中的泛型能够在初始化时使用尖括号的形式进行声明，函数的也可以，但是当函数参数已经指定了泛型的类型时，就不必显式指定了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>泛型中的type Constrain</p>
<ul>
<li><p>其实就是Java中使用的上下界通配符<code>extends</code>和<code>super</code></p>
</li>
<li><p>其作用就是为泛型引入<strong>类型限制</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">V</span> <span class="title">extends</span> <span class="title">object</span>&gt; (<span class="params">objA: T, objB: V</span>) </span>&#123;    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(objA, objB);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样的例子，如果泛型T和V不做限制的话，可以传递任意类型的值，但是函数体内的assign函数只接受object类型，因此，需要使用泛型中的类型限制</li>
<li>extends后边的类型可以灵活的设置为string、number、自定义类型、联合类型等等</li>
</ul>
</li>
<li><p>使用类型限制的一个案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接受字符串或数组并得到其长度，并返回长度信息元组，接受的参数是多元参数，可以使用联合参数，更灵活的就使用泛型为了明确表示，T类型有length属性，尝试使用类型限制自定义一个接口，并定义length属性，表示只接受有length属性的对象*/</span>interface Lengthy &#123;    <span class="attr">length</span>: number;&#125;<span class="comment">// 如果不显示指定返回类型，默认被推测为联合类型的数组function countAndDescribe&lt;T  extends Lengthy &gt; (elements: T) :[T, string]&#123;    let descibeMessage = &#x27;there is no value&#x27;;    if (elements.length == 1) &#123;        descibeMessage = `there is 1 element`;    &#125; else if (elements.length &gt; 1) &#123;        descibeMessage = `there are $&#123;elements.length&#125; element`;    &#125;    return [elements, descibeMessage];&#125;console.log(countAndDescribe([1,2,3]));</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>keyof</code>做类型限制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传入一个对象参数，与其中的一个key获取对应的value1. 可以是任何object,可以使用泛型2. 必须保证对象中有特定的属性，使用keyof*/</span><span class="function"><span class="keyword">function</span> <span class="title">extractAndConvert</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">V</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt; (<span class="params">obj: T, key: V</span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;the value of key &#x27;</span> + key + <span class="string">&#x27; is &#x27;</span> + obj[key];&#125;<span class="built_in">console</span>.log(extractAndConvert(&#123;<span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>&#125;, <span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在class中使用泛型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据存储的类型，当然希望能存储各种类型，所以用到泛型*/</span><span class="class"><span class="keyword">class</span> <span class="title">DataStorage</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">string</span> | <span class="title">number</span> | <span class="title">boolean</span>&gt; </span>&#123;    private data: T[] = [];    getData () &#123;        <span class="keyword">return</span> [... <span class="built_in">this</span>.data];    &#125;    addData (item: T) &#123;        <span class="built_in">this</span>.data.push(item);    &#125;    removeData (item: T) &#123;        <span class="comment">// T 可以是任意类型，当然也可以是一个字面对象，但是会涉及到指针传递的问题        // indexof无法找到时，会返回-1，splice接受到-1参数后，会从尾部元素开始删除        this.data.splice(this.data.indexOf(item), 1);    &#125;&#125;const textStorage = new DataStorage&lt;string&gt; ();textStorage.addData(&#x27;lee&#x27;);textStorage.addData(&#x27;jia&#x27;);textStorage.removeData(&#x27;jia&#x27;);console.log(textStorage.getData());// const objectStorage = new DataStorage&lt;object&gt; ();// objectStorage.addData(&#123;name: &#x27;lee&#x27;&#125;);// objectStorage.addData(&#123;name: &#x27;jia&#x27;&#125;);// // 是指针传递而非值传递，因此传入参数的不是一模一样的对象，而是一个全新的对象的指针，所以并不会索引到此对象// // 因此可能需要适时的引入泛型的类型限制（当然也可以引入其他机制解决此引用传递的问题，这里这是强调在泛型中使用类型检查的重要性）// objectStorage.removeData(&#123;name: &#x27;lee&#x27;&#125;);// console.log(objectStorage.getData());</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>每当使用泛型时，都应注意，是否需要做类型限制，不要让泛型过于自由</strong></li>
<li>class中的方法也可以灵活定义属于自己的泛型</li>
</ul>
</li>
<li><p>ts中支持的一些常用的使用泛型的工具类（使用泛型提供便利的工具类）</p>
<ul>
<li><p>Partial，一个包装类，用来表示<strong>泛型指定的类型中的属性都是可选的，其使用场景在于可以单独设置指定类型的参数，而不用一次性设定（默认情况下ts会报错，参考下边的案例）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface CourseGoal &#123;    <span class="attr">title</span>: string;    description: string;    completeUntil: <span class="built_in">Date</span>&#125;<span class="comment">/** 创建CourseGoal对象，对象的属性可能来自于数据库或者用户输入*/</span><span class="function"><span class="keyword">function</span> <span class="title">createCourseGoal</span> (<span class="params">title: string, description: string, date: <span class="built_in">Date</span></span>) : <span class="title">CourseGoal</span></span>&#123;    <span class="comment">// 首先初始化一个空对象    // 在程序中会一步一步的设置对象的属性，但是在初始化时创建对象后就不允许赋值为空对象,此时需要使用Partial包装类    // 告诉ts，CourseGoal的属性都是可选的，不必在初始化时操作，后续该有的属性都会酌情添加    let courseGoal: Partial&lt;CourseGoal&gt; = &#123;&#125;;    // ... 数据库获取或用户输入    courseGoal.title = &#x27;ts&#x27;;    // ... 数据库获取或用户输入    courseGoal.description = &#x27;up up&#x27;;    // ... 数据库获取或用户输入    courseGoal.completeUntil = new Date();    // 返回的类型是Partial类型会报错，但是开发者知道返回的对象就是CourseGoal形式的对象，因此直接使用断言即可    return courseGoal as CourseGoal;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>ReadOnly，设置任意对象为只读，前边学到的readonly（或者说定义变量时使用的const）是class中的类成员修饰符，当修饰一个对象时，不可更改的是对象的地址，而对象内部的属性是可以任意更改的，ReadOnly类就可以使用泛型标记一个泛型的对象为完全只读，其内部的属性也不可能更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">// okarray.push(5);const arrayReadOnly:Readonly&lt;number []&gt; = [1,2,3];// errorarrayReadOnly.push(5);</span></span><br></pre></td></tr></table></figure></li>
<li><p>更多参考<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/utility-types.html">ts中支持泛型的工具类</a></p>
</li>
</ul>
</li>
<li><p>泛型与联合类型的区分</p>
<ul>
<li>许多情况下，在使用泛型时，实际上只是接受多个特定类型而已，而不一定接受所有类型，这种情况下，貌似使用联合类型也能解决，毕竟也实现了接受多个类型，但是最关键的不同在于<strong>泛型所代表的类型一旦确定，就是唯一接触的类型，同一时间只对这一种类型服务，而联合类型永远支持多个类型</strong></li>
</ul>
</li>
</ul>
<h2 id="ts中的装饰器"><a href="#ts中的装饰器" class="headerlink" title="ts中的装饰器"></a>ts中的装饰器</h2><ul>
<li><p>注意，如果要在ts中使用装饰器，需要在tsconfig.json中打开以下的配置<code>&quot;experimentalDecorators&quot;: true</code></p>
</li>
<li><p>装饰器更确切的说是一个函数，可以用来修饰一个类（<strong>包括类属性类方法等等</strong>），从名字来看与Java中的装饰者模式类似（使用方法上更像是springboot中的注解）</p>
</li>
<li><p>这里涉及到元编程的概念，可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B">维基百科</a>以及相关的其他介绍</p>
<ul>
<li><p>元编程是一种计算机程序可以将代码看待成数据的能力</p>
</li>
<li><p>元编程赋予了编程语言更加强大的表达能力，通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。归根结底就是一种使用代码生成代码的思想，消灭重复的代码，极大地增强编程语言的表达能力</p>
</li>
<li><p>泛型，注解（依靠反射实现），等实际上都是元编程的概念</p>
</li>
<li><p>编写元程序的语言称之为元语言。被操纵的程序的语言称之为「目标语言」。一门编程语言同时也是自身的元语言的能力称之为「反射」或者「自反」。</p>
</li>
</ul>
</li>
<li><p>总结下边的装饰器案例，装饰器更像一个插件，可以用作第三方库的切入点，用以提供强大的功能（类似于spring AOP）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorator首字母大写// 修饰器函数的参数随着其修饰位置的不同而变化// 修饰构造器function Logger (constructor: Function) &#123;    console.log(&#x27;logging ...&#x27;);    console.log(constructor);&#125;// 使用@函数名来部署一个修饰器@Loggerclass Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;// const pers = new Person();// console.log(pers);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>装饰器在class定义后（js发现class的构造器函数后）立即起作用，而不是实例化后起作用</strong></li>
<li><strong>类装饰器的参数是该类的类构造器方法</strong></li>
</ul>
</li>
<li><p>使用装饰器工厂</p>
<ul>
<li><p>使用装饰器工厂可以更灵活的创建装饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建修饰器function LoggerFactory (loggerText: string) &#123;    return function (constructor: Function) &#123;        console.log(loggerText);        console.log(constructor);    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@LoggerFactory(&#x27;constructor logging ...&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>功能更强大的装饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="comment">// 将参数名称设置为_是告诉ts，函数中不会用到形参，但是得有这个形参，所以就设置一个特殊的名字即可    return function (_: Function) &#123;        const element = document.getElementById(hookId)!;        element.innerHTML = template;    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@WithTemplate(&#x27;&lt;h1&gt; !!!&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>显然，此装饰器更类似于一个模板渲染的工具，如何将class的数据导入进来呢？使用构造器函数即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="comment">// 将参数名称设置为_是告诉ts，函数中不会用到形参，但是得有这个形参，所以就设置一个特殊的名字即可    return function (constructor: any) &#123;        const element = document.getElementById(hookId)!;        element.innerHTML = template;        // 注意这里比较诡异，要使用new关键字来调用构造函数，相当于创建class实例，为了避免报错，将constructor参数的        // 类型设置为any        let person = new constructor();        document.querySelector(&#x27;h1&#x27;)!.innerText = person.name;    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@WithTemplate(&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>angular这样的前端框架中就支持诸如此类的装饰器，以进行页面渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以对class同时使用多个装饰器，但是装饰器的启动顺序是怎样的？离着class越近的越先被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoggerFactory</span> (<span class="params">loggerText: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;loggerFactory start&#x27;</span>)    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_: <span class="built_in">Function</span></span>) </span>&#123;        <span class="built_in">console</span>.log(loggerText);    &#125;    &#125;<span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;templateFactory start&#x27;</span>)    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: any</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;template redering....&#x27;</span>)        <span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(hookId)!;        element.innerHTML = template;        <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title">constructor</span>(<span class="params"></span>);        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>)!.innerText = person.name;    &#125;    &#125;@LoggerFactory(<span class="string">&#x27;person class logging ...&#x27;</span>)@WithTemplate(<span class="string">&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;</span>, <span class="string">&#x27;app&#x27;</span>)<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    name = <span class="string">&#x27;lee&#x27;</span>;    <span class="title">constructor</span> (<span class="params"></span>) &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;creating Person object...&#x27;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印顺序为：<code>loggerFactory start app.ts:10 templateFactory start app.ts:12 template redering.... app.ts:28 creating Person object... app.ts:5 person class logging ...</code></li>
<li>装饰器工厂的执行顺序，就是按照执行顺序来的，尽管前边有<code>@</code>符号，但是本质上还是执行了后边的工厂方法，而装饰器的执行顺序则是离着class近的先被执行</li>
</ul>
</li>
<li><p>类属性修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类属性修饰器// 2个参数// 1. 如果是实例成员，则为类的原型；如果是静态成员，则为构造器函数// 2. 属性名function Log (target: any, propertyName: string|Symbol) &#123;    console.log(&#x27;property decorator..&#x27;);        console.log(target, propertyName);&#125;class Product &#123;    @Log    static title: string;    private _price: number;    constructor (price: number) &#123;        this._price = price;    &#125;    set setPrice (price: number) &#123;        if (price &gt; 0) &#123;            this._price = price;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例成员：</p>
<img src="http://images.demoli.xyz/20210103143843.png" style="zoom:80%;" /></li>
<li><p>静态成员</p>
<img src="http://images.demoli.xyz/20210103143927.png" style="zoom:80%;" /></li>
<li><p>关于类属性修饰器的一个案例（数据validator，实际上也是类似的注解的经典应用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用接口来定义存储结构// 此接口必须具有极大的灵活性，因为可以存储任意class中的待验证信息// 结构就是： 类名：&#123;类中属性的名字:[需要的验证规格]&#125;interface ValidatorConfig &#123;    [className: string]: &#123;        [propName: string]: string []    &#125;&#125;// 此验证器信息的存储结构在待验证class定义好之后就会被修饰器中的逻辑进行赋值const registeValidator: ValidatorConfig = &#123;&#125;;function Require (target: any, propName: string) &#123;        // 向存储结构中添加验证信息    // 使用[]来索引object中的属性或添加属性    // target.constructor指向的是class的类构造器（js原生中的类构造器）其name属性就是类构造器方法的名字也就是语法糖中class的名字    registeValidator[target.constructor.name]  = &#123;        ...registeValidator[target.constructor.name],        [propName]: [...registeValidator[target.constructor.name][propName], &#x27;require&#x27;]    &#125;;&#125;function LargerthanZero (target: any, propName: string) &#123;    // 向存储结构中添加验证信息    registeValidator[target.constructor.name] = &#123;        ...registeValidator[target.constructor.name],        [propName]: [...registeValidator[target.constructor.name][propName] , &#x27;largerthanZero&#x27;]    &#125;;&#125;function validate (object: any): boolean &#123;    //首先在全局的存储结构中找到参数obkect对应的验证信息    const validator = registeValidator[object.constructor.name];    if (!validator) &#123;        // 没有存储该class的验证信息，说明不用验证，返回true        return true;    &#125;    let isValid = true;    for (const prop in validator) &#123;        for (const valid of validator[prop]) &#123;            switch (valid) &#123;                case &#x27;require&#x27;:                     // 使用!!运算符，空字符串与null、0或undefined都转为false                     console.log(prop);                    isValid = isValid &amp;&amp; !! object[prop];                    break;                case &#x27;largerthanZero&#x27;:                    console.log(prop);                    isValid = isValid &amp;&amp; object[prop] &gt; 0;                    break;            &#125;        &#125;    &#125;    return isValid;&#125;class Course &#123;    @Require    title: string;    @LargerthanZero    price: number;    constructor (title: string, price: number) &#123;        this.title = title;        this.price = price;    &#125;&#125;const form = document.querySelector(&#x27;form&#x27;)!;form.addEventListener(&#x27;submit&#x27;, (event) =&gt; &#123;    // 防止表单提交后发出http请求    event.preventDefault();    const titleEl = document.getElementById(&#x27;title&#x27;) as HTMLInputElement;    const priceEl = document.getElementById(&#x27;price&#x27;) as HTMLInputElement;    const title = titleEl.value;    // +的作用就是将数字内容的字符串转为数字    // 如果是非数字内容的字符串的话，会得到NaN    const price = +priceEl.value;    // 显然对于用户的输入，希望title的内容与price的设置必须要经过检查    // 可以使用if-check，但是如果每一次创建一个实例都要进行判断，就过于繁琐，所以引入了基于class的使用修饰器实现的验证器    let course = new Course(title, price);    if (!validate(course)) &#123;        alert(&#x27;wrong!&#x27;);        return;    &#125;    console.log(course);&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用场景：<ul>
<li>构造class实例的数据来自于用户输入或者后台数据，需要验证数据类型的有效性</li>
</ul>
</li>
<li>设计分析<ul>
<li>应该有三个函数要定义<ul>
<li>titile属性的修饰器</li>
<li>price属性的修饰器</li>
<li><strong>验证器函数（非修饰器），因为类属性的修饰器，仅仅能获得属性的名字，不能获取属性的值，所以只能起到一个标注的作用，验证逻辑应该在验证器函数中完成</strong></li>
</ul>
</li>
<li><strong>应该有一个存储类型需要定义，此存储类型对象要存储的是类实例中的哪个属性需要什么规格的验证（此信息需要从修饰器中获得并被验证器函数利用以对参数中传入的实例进行验证）</strong></li>
</ul>
</li>
<li><strong>很复杂的修饰器实现的验证器，但是实际上一般这都是第三方库要提供的服务，使用者只需import就可以直接使用修饰器与修饰器了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>类getter与setter的修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log2</span> (<span class="params">target : any, name: string, descriptor: PropertyDescriptor</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;accessor decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, descriptor);&#125;<span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;    <span class="comment">// @Log    static title: string;    private _price: number;    constructor (price: number) &#123;            this._price = price;    &#125;    // @log2    set setPrice (price: number) &#123;        if (price &gt; 0) &#123;            this._price = price;        &#125;    &#125;    @log2    static set setTitle (title: string) &#123;        this.title = title;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类的getter与setter又被称为accessor，其修饰器的参数有三个</p>
<ul>
<li><p>与类属性修饰器的第一个参数一样，如果accessor为类成员方法就是类的原型，如果是静态方法就是构造器函数</p>
</li>
<li><p>accessor的名字</p>
</li>
<li><p>PropertyDescriptor类型（原生js提供的的内置类型（详细可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">官网</a>））的值</p>
<img src="http://images.demoli.xyz/20210103144849.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>类方法的修饰器</p>
<ul>
<li><p>与前边的accessor的修饰器实际上是一样的，只是descriptor的内部结构不太一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log3</span> (<span class="params">target : any, name: string| <span class="built_in">Symbol</span>, descriptor: PropertyDescriptor</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;method decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, descriptor);&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法参数的修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log4</span> (<span class="params">target : any, name: string| <span class="built_in">Symbol</span>, position: number</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;parameter decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, position);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数与类方法修饰器的一样</li>
<li><strong>参数所在的方法的方法名</strong></li>
<li>参数在方法形参列表中的位置，从0开始</li>
</ul>
</li>
<li><p>修饰器的执行顺序</p>
<ul>
<li>以上所有的修饰器，都是在class定义好后就开始工作的，而不是class实例化后工作的，后边提到的修饰器函数返回值的使用案例中需要进行实例化</li>
<li><strong>对于同一个对象（class 类方法 类属性）赋予多个修饰器时，都是离得越近的修饰器越先被执行</strong></li>
</ul>
</li>
<li><p>修饰器函数的返回值</p>
<ul>
<li><p>并不是所有修饰器函数的返回值都有意义</p>
</li>
<li><p>修饰器函数能返回什么取决于此修饰器函数的类型</p>
<ul>
<li><p>类修饰器可以返回一个类构造函数用以替换被修饰器修饰的class</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;templateFactory start&#x27;</span>)    <span class="comment">// 为了表示泛型T是构造器函数类型，需要对其进行类型限制，其必须有new方法，方法参数是可变数组    // new方法的返回值也必须定义好，因为下边要用到name属性，所以返回值必须有name属性    return function&lt;T extends &#123;new (...args: any[]): &#123;name: string&#125;&#125;&gt; (originalConstructor: T) &#123;        console.log(originalConstructor);            // 同样可以是class关键字这个语法糖来生成一个构造器函数并返回        // 需要注意到的是这个新的class应当继承自原有的class        return class extends originalConstructor&#123;            // 子类的构造器函数            // 并不会使用构造器参数，所以命名为_            constructor (..._: any[]) &#123;                // 使用super方法可以保留原有class的数据结构                super();                // 将渲染步骤放在构造函数中，则其必须在实例化时才能起作用                console.log(&#x27;template redering....&#x27;)                const element = document.getElementById(hookId)!;                element.innerHTML = template;                document.querySelector(&#x27;h1&#x27;)!.innerText = this.name;            &#125;        &#125;;    &#125;    &#125;@WithTemplate(&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;// 实例化后，执行修饰器返回的构造函数，并在构造函数中完成渲染let pers = new Person();</span></span><br></pre></td></tr></table></figure></li>
<li><p>类方法修饰器</p>
</li>
<li><p>accessor修饰器</p>
<ul>
<li><p>以上两个修饰器本质上都是类似的，可以返回新的PropertyDescriptor类型的对象用于替换其本来的PropertyDescriptor，下边展示关于类方法修饰器的案例展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的功能在于点击button后可以执行class内的一个成员方法function AutoBind (_: any, _2: string, desciptor: PropertyDescriptor) &#123;// 1. 在修饰器内部获取修饰的方法    const originMethod = desciptor.value;    // 2. 配置要返回的PropertyDescriptor以取代被修饰的方法的PropertyDescriptor    // 3. 在ts中PropertyDescriptor是一个接口，并且接口中的属性与方法都是可选的，所以不用写全所有的属性    const adjustDescriptor: PropertyDescriptor = &#123;        configurable: true,        enumerable: false,        // 此属性相当于是在函数调用前与addEventListener注册回调函数间添加了一个代理，addEventListener将this设置为event target后，在函数调用时执行此get方法来获得函数引用，而在get方法中，重新将        // this设置为this，这里的this会恒定指向类实例，因为这个get方法总是被方法所属的实例调用的        get () &#123;            const boundFn = originMethod.bind(this);            return boundFn;        &#125;    &#125;;    return adjustDescriptor;&#125;class Printer &#123;    private message: string = &#x27;Printer work!&#x27;;    // 可以说用此注解取代了对于bind函数的使用，这使得代码更加整洁    @AutoBind    printMessage () &#123;        console.log(this.message);    &#125;&#125;let printer = new Printer();const button = document.querySelector(&#x27;button&#x27;)!;button.addEventListener(&#x27;click&#x27;, printer.printMessage);// 注意这里只是传递函数引用而不是执行函数// 实际上点击之后，会打印undefined，这是因为在事件触发机制中，回调函数内部的this被绑定为事件对象（event target）上// 而不是实例printer// 解决办法有以下几种// 1. 使用bind函数，重新配置context（也就是this变量）// 2. 使用类方法修饰器，修饰器的目的在于使得被修饰的类方法内部的this无论在任何场景下都只会指向其所属的class实例// button.addEventListener(&#x27;click&#x27;, printer.printMessage.bind(printer));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>具体的PropertyDescriptor的各个属性的功能应该参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">官网</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>nest.js中的server端代码使用修饰器实现的注解来实现复杂功能（与Java中类似），Angular也把修饰器作为其核心部分，提供页面数据渲染等功能，修饰器真的很强大，也很重要</strong></p>
</li>
<li><p>更好用的第三方库<a target="_blank" rel="noopener" href="https://github.com/typestack/class-validator">class validator</a></p>
</li>
</ul>
<h2 id="Demo-可视化的项目管理器"><a href="#Demo-可视化的项目管理器" class="headerlink" title="Demo 可视化的项目管理器"></a>Demo 可视化的项目管理器</h2><ul>
<li><p>html文件与css文件直接复制写好的</p>
<ul>
<li>关于html的一些设计<ul>
<li>template标签默认情况下是不可见的，可由js操作是否可见，字如其意，用来做模板数据的，在需要的时候可以渲染到页面中</li>
</ul>
</li>
</ul>
</li>
<li><p>去源代码目录中查看源代码与注释即可</p>
</li>
<li><p><strong>class中public的方法应放在protected、private前面</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">关于modern browser的drag与drop</a></p>
</li>
</ul>
<h2 id="ts中的模块化"><a href="#ts中的模块化" class="headerlink" title="ts中的模块化"></a>ts中的模块化</h2><ul>
<li>上边的demo中的所有代码都写在一个文件中，显然不利于维护，有两种方式可以拆分代码到不同的文件：<ul>
<li>使用Namespace，由ts提供的语法，由ts负责处理文件依赖关系</li>
<li>ES6 Import/Export，原生js语法，由browser负责处理文件依赖关系<ul>
<li>弊端在于，需要多次HTTP请求来获取不同的js文件，因此生产中常把所有的js文件打包为一个js文件，打包工具常用的有WebPack等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drag &amp; Drop// 可被拖动的对象namespace DDInterfaces &#123;    export interface Dragable &#123;        // 开始拖动        dragStartHandler(event: DragEvent) : void        // 结束拖动        dragEndHandler(event: DragEvent) : void    &#125;    // 拖动的目的对象    export interface DragTarget &#123;        // 拖动进入        dragOverHandler(event: DragEvent): void        // 拖动进入并松开        dropHandler(event: DragEvent): void        // 拖动离开        dragLeaveHandler(event: DragEvent): void    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>内部可定义任何数据结构</p>
</li>
<li><p><strong>可以使用export暴露内部的任意数据结构，否则只能在同一命名空间下才能被访问到</strong></p>
</li>
<li><p>文件的引入方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;drag-drop-interface.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>再次强调，这是纯ts语法，与js无关，其依赖关系由ts维护</strong></p>
<ul>
<li><strong>此语法仅仅是告诉ts编译器从哪里找寻需要的类型接口等等，但是对于编译后结果，所有拆分的文件都是独立编译的，因此如此拆分实际上会出错（因为html文件实际上只引用了一个js文件，其余的虽然编译了，但是并没有引用，我们需要ts编译器将编译结果统一编译到一个js文件中）</strong><ul>
<li>在<code>tsconfig.json</code>中设置<code>&quot;outFile&quot;: &quot;./dist/bundle.js&quot;,</code>以及设置<code>&quot;module&quot;: &quot;amd&quot;,</code></li>
<li>实际上namespace这个语法的实现对应的就是js中的一个函数，可以查看js编译结果</li>
</ul>
</li>
</ul>
</li>
<li><p>上述语法的作用是把path属性对应的ts中namespace引入到本文件中，<strong>但是要访问namespace内部的结构，必须还是要把当前文件中要访问的代码放到同一namespace下，否则无法访问</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;drag-drop-interface.ts&quot; /&gt;namespace DDInterfaces &#123;  ...&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么 export的作用是？将本ts文件中的数据结构暴露出去，否则，即便别的文件使用同一namespace，但是依然无法访问到其他问价同一namespace下的数据结构</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Namespace的使用弊端</p>
<ul>
<li>拆分起来很麻烦，并且需要自己分析依赖逻辑</li>
<li>一旦依赖逻辑错误，可能没有编译错误，但是会有运行时错误</li>
</ul>
</li>
</ul>
<h3 id="ES6-Import-Export"><a href="#ES6-Import-Export" class="headerlink" title="ES6 Import/Export"></a>ES6 Import/Export</h3><ul>
<li><p>与namespace类似使用export 导出本文件中的对象</p>
</li>
<li><p>在其他文件使用import： <code>import &#123;要引用的对象,对象1,对象2&#125; from &#39;文件位置&#39;;</code></p>
<ul>
<li>需要注意文件位置中的文件名应当是<code>.js</code>后缀，因为要引入的应当是编译好的js文件，因为Import是js原生支持的语法，ts会做提示，但不会做其他的干预</li>
<li>可以先不写<code>&#123;&#125;</code>中药引入的对象，先把后边的文件位置写好，此时对象会有提示</li>
</ul>
</li>
<li><p><strong>使用此方法避免了使用namespace时，依赖是否被正确添加的提示机制，此方法中，只要在本文件中没有正确添加依赖就会报错，而不管其他文件如何添加依赖</strong></p>
</li>
<li><p>一顿操作猛如虎，最后还会报一个错误<code>Uncaught ReferenceError: define is not defined typescript</code></p>
<ul>
<li><strong>保证配置文件中target是es6以后的版本，module设置为es2015，outFile属性也要注释掉（这是namespace需要的，并不受es6 module支持）</strong><ul>
<li>基本做的就是告诉ts编译器，原封不动的输出import与export关键字，浏览器知道如何处理，不要ts做干预</li>
</ul>
</li>
</ul>
</li>
<li><p>html引入js文件的方式也需要做设置，否则会有<code>Uncaught SyntaxError: Cannot use import statement outside a module</code>，应当告诉浏览器，js代码使用module维护依赖关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;dist/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>去掉<code>defer</code>，添加type属性为module</li>
<li><strong>此时app.js作为入口文件，浏览器会迭代的去解析依赖，并且实时的去请求对应的依赖的js文件（可以通过控制台的network查看）</strong></li>
</ul>
</li>
<li><p>使用中的其他语法：</p>
<ul>
<li><p>为了避免命名冲突冲突，可以使用别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用*导入目的包的全部对象，使用as指定别名import * as Drag from &#x27;../models/drag-drop.js&#x27;;import &#123;Project&#125; from &#x27;../models/project.js&#x27;;import &#123;Component&#125; from &#x27;./base-component.js&#x27;;import &#123;AutoBind as autoBind&#125; from &#x27;../decorators/autobind.js&#x27;;// ProjectItem classexport class ProjectItem extends Component&lt;HTMLUListElement, HTMLLIElement&gt; implements Drag.Dragable&#123;  ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认export</p>
<ul>
<li><p>import时总要指定与export中同样的名字，使用默认export时则不用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">Component</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span>&gt;</span>&#123;...&#125;<span class="comment">// 不用使用&#123;&#125;指定名字，并且可以使用任意名字，不冲突即可import Cmp from &#x27;./base-component.js&#x27;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个文件只能有一个默认export</li>
<li>只有目的模块文件如此设置了才能使用这样的语法，并且如果目的模块设置了默认export，要引用模块的其他文件也<strong>必须使用</strong>这种不带{}引用的语法，当然名字也是可以任意指定的的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>使用es6 module时，同一个对象可能多次被不同的文件引用，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的状态管理器export const projectState = ProjectState.getInstance(); </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>初次引用后，后续就不会重复执行并引用了，相当于浏览器有一套缓存机制，对于之前已经import的对象，可以拿来直接用，而不用重新执行一次初始化或者声明什么的</strong></p>
</li>
<li><p><strong>无论用namespace还是用module（推荐）都要合理的设计目录，用于分放各个组件，有效管理</strong></p>
</li>
<li><p><strong>export后边直接跟一个函数调用的时候，暴露的就是函数的返回值</strong></p>
</li>
</ul>
</li>
<li><p>总的来说，使用module固然好，但是也有HTTP 请求次数过多，与浏览器兼容性问题（仅主流浏览器的最新版本支持，IE的旧版本可能不支持），所以引入第三方的打包工具–webpack</p>
</li>
<li><p><strong>需要注意的是本节中说的module是一种语法也是一种依赖治理的方式，不推荐使用这种依赖治理方式，但是export与import的语法是js es6官方原生支持的用来取代commonjs、AMD、CMD等的一种模块加载方式（同样也是ts默认支持的方式），在webpack还是可以继续使用这种语法的，只不过如果目标浏览器是旧版浏览器，需要调节编译的target，将export/import语法转为旧版的AMD模块加载语法（require）或者是目标运行环境为commonjs的nodejs，则编译为使用require方法的js代码</strong></p>
</li>
</ul>
<h2 id="ts与webpack"><a href="#ts与webpack" class="headerlink" title="ts与webpack"></a>ts与webpack</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/">webpack官方文档</a></p>
</li>
<li><p>webpack是一个前端的打包工具，可以将项目中的多个文件打包成一个文件，同时也可以自动优化代码，减小代码体积，减小HTTP请求的数量与请求体大小，除此之外，在CSS等方面也有其他功能</p>
</li>
<li><p>甚至可以做混淆加密等功能，以及开启本地服务器serve页面等功能（不用再开启lite-server了）</p>
<img src="http://images.demoli.xyz/20210106205018.png" style="zoom:80%;" /></li>
<li><p>项目中安装webpack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli webpack-dev-server typescript ts-loader --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li>ts-loader用来协助webpack执行ts文件的编译</li>
</ul>
</li>
<li><p>配置webpack</p>
<ul>
<li><p>配置ts项目的tsconfig.json</p>
<ul>
<li>target: webpack会根据此处的设定执行对应的编译工作</li>
<li>module同理(<strong>在drag项目中，此处维持es2015也没什么问题，但是当使用第三方模块时会出现无法找到模块的问题，此时应将此处更改为commonjs</strong>)</li>
<li>rootDir不用设置，webpack会接管</li>
</ul>
</li>
<li><p>在项目根目录创建<code>webpack.config.js</code></p>
<ul>
<li><p>此文件名是webpack的默认配置文件名，其js语法使用nodejs中使用的commonjs 包语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);<span class="built_in">module</span>.exports = &#123;    <span class="comment">// 设置打包模式为开发模式，这样可以使webpack做少量的优化，并给出尽量详细有用的日志信息    mode: &#x27;development&#x27;,    // 项目入口    entry: &#x27;./src/app.ts&#x27;,    output: &#123;        // 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.[contenthash].js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        publicPath: &#x27;/dist/&#x27;    &#125;,    // 声明ts支持生成sourcemap文件，webpack打包时应考虑提供sourcemap，便于debug    devtool: &#x27;inline-source-map&#x27;,    // module节点用来声明webpack处理不同类型的文件的方式，包括ts css img 等等    module: &#123;        // 对于不同类型的文件，在列表中可以有多种规则        rules: [            &#123;                // 用来筛选特定类型的文件,使用正则                test: /\.ts$/,                // 使用ts-loader组件处理ts文件                use: &#x27;ts-loader&#x27;,                // 不筛选此文件夹中的文件                exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)             &#125;        ]    &#125;,    // 依赖解析的配置    resolve: &#123;        // 依赖解析时需要解析的文件的后缀名        extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;]    &#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>webpack会从entry文件开始迭代依赖，并依此进行构建</li>
</ul>
</li>
</ul>
</li>
<li><p>项目中所有import from中的文件名的js后缀都应删除，保持无后缀即可</p>
<ul>
<li><strong>export与import语法与es6 module保持一致，只不过从浏览器解析依赖变成webpack解析依赖并进行项目构建</strong></li>
</ul>
</li>
<li><p>修改package.json，提供build命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>npm run-script build</code>进行构建</li>
</ul>
</li>
<li><p>如果要使用webpack-dev-server同样修改package.json即可：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Webpack-dev-server同时提供watch功能，可以自动编译ts文件</p>
</li>
<li><p>但是实际上执行自动编译之后并没有生效，实际上是因为更改后的编译结果并没有存储到磁盘中，可以将dist中的打包好的文件删除，再触发自动编译，可以发现没有新的文件生成，只会在内存中生成最新修改的打包文件，需要对webpack进行进一步的配置，明确打包文件的位置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;        <span class="comment">// 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        publicPath: &#x27;/dist/&#x27;    &#125;,</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开发环境下设置mode为development即可，但是生产环境下，需要做更多的设置</p>
<ul>
<li><p>创建一个专供生产环境打包的新的webpack配置文件<code>webpack.config.production.js</code>(名字任意)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);const clean = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123;    <span class="comment">// 设置打包模式为开发模式，这样可以使webpack做少量的优化，并给出尽量详细有用的日志信息    mode: &#x27;production&#x27;,    // 项目入口    entry: &#x27;./src/app.ts&#x27;,    output: &#123;        // 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        // 仅供webpack-dev-server使用，所以注释掉        // publicPath: &#x27;/dist/&#x27;    &#125;,    // 声明ts支持生成sourcemap文件，webpack打包时应考虑提供sourcemap，便于debug    devtool: false,    // module节点用来声明webpack处理不同类型的文件的方式，包括ts css img 等等    module: &#123;        // 对于不同类型的文件，在列表中可以有多种规则        rules: [            &#123;                // 用来筛选特定类型的文件,使用正则                test: /\.ts$/,                // 使用ts-loader组件处理ts文件                use: &#x27;ts-loader&#x27;,                // 不筛选此文件夹中的文件                exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)             &#125;        ]    &#125;,    // 依赖解析的配置    resolve: &#123;        // 依赖解析时需要解析的文件的后缀名        extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;]    &#125;,    // module工作在文件层面，plugin工作在workflow层面    plugins: [        new clean.CleanWebpackPlugin()    ]&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>插件安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li>此插件的作用在于每次重新构建，向目的文件夹写入新的打包文件之前，都能删除打包位置的旧文件，不用再手动删除之前打包的不用的旧文件了</li>
</ul>
</li>
<li><p>配置package.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,    <span class="attr">&quot;prodbuild&quot;</span>: <span class="string">&quot;webpack --config webpack.config.production.js&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>npm run-script probuild</code>执行编译即可</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>补充：使用了webpack后，html中引入js的方式不用再添加<code>type=module</code>因为最终打包成了一个js不用浏览器再去解析依赖了，同时最好也把<code>defer</code>加上</strong></p>
</li>
<li><p><strong>使用webpack的另外一个好处在于，使用第三方模块时，使用npm安装即可，不用引入script了，webpack会将依赖进行打包</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三方模块的引入"><a href="#第三方模块的引入" class="headerlink" title="第三方模块的引入"></a>第三方模块的引入</h2><ul>
<li>分为两类：<ul>
<li>普通js工程可以引入的第三方模块</li>
<li>只能在ts工程中使用的第三方模块</li>
</ul>
</li>
<li>注意<ul>
<li><strong>在drag项目中，tsconfig中的module处维持es2015也没什么问题，但是当使用第三方模块时会出现无法找到模块的问题，此时应将此处更改为commonjs</strong></li>
</ul>
</li>
</ul>
<h3 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h3><ul>
<li><p>纯js模块，在js工程中可以使用CDN加载也可以使用npm安装，<strong>在webpack项目中可以直接使用npm安装，就可以直接在源代码中使用import导入此模块并使用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save lodash</span><br></pre></td></tr></table></figure></li>
<li><p>在项目中引入lodash</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;<span class="built_in">console</span>.log(_.shuffle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<ul>
<li>但是，因为lodash是纯js项目，ts编译器并不能很好的将其引入到项目中，因此会报错，但是我们设置tsconfig中的noEmitOnError为false之后（不管编译是否出问题，都产出编译结果），并开启webpack-server后发现实际上是可用的</li>
</ul>
</li>
<li><p>对于纯js第三方模块理论上是可以转译成ts模块的，GitHub上的<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash">DefinitelyTyped项目</a>为众多主流js模块提供了对ts的转译</p>
<ul>
<li><p><strong>所谓的转译实际上就是提供了js原生模块的<code>.d.ts</code>文件，这些文件不提供具体的操作逻辑，只是向ts提供有关模块的一些类型，这使得ts编译器能够理解此js模块的类型，从而正确导入不会报错</strong></p>
</li>
<li><p>项目中的转译项目都可以使用npm安装到本地（前提是已经安装好了之前的纯js模块，或者以CDN形式获取了js库，比如下面的Google Map项目）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/lodash</span><br></pre></td></tr></table></figure>

<ul>
<li>所有的这些转译项目都以<code>@types</code>开头，Google中可以使用 <code>type $&#123;js模块名字&#125;</code>查询，一般就能查到对应的npm页面</li>
<li>只有在开发时会使用，因为最终都是编译成js文件，在部署后不再需要此模块</li>
</ul>
</li>
<li><p>对于自己写的js脚本，或者说一些实在没有转译版本的第三方的js库，使用<code>declare</code>将其引入到ts类型系统中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;dist/bundle.js&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        var GLOBAL = &#x27;GLOBAL!!&#x27;;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;js:declare var GLOBAL:string;console.log(GLOBAL);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>declare</code>后边是对于声明的变量的修饰符，不管其在其他js文件如何修饰，这里定义的是其在ts中的修饰符，ts会负责根据修饰符以及类型对此变量的操作进行检查</li>
<li><strong>之所以上述所说的转译或者declare可用的本质原因还是ts本身与js一样，ts的最终编译结果还是js，js可以兼容到ts中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="class-transformer"><a href="#class-transformer" class="headerlink" title="class transformer"></a>class transformer</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/typestack/class-transformer">Github</a></p>
</li>
<li><p>此模块既可以在ts中使用，也可以在js项目中使用</p>
</li>
<li><p><strong>其功能是将字面量objec与对应的class实例相互转化，或者是直接的对象的序列化于反序列化</strong></p>
</li>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install class-transformer --savenpm install reflect-metadata --save// 放在入口文件的头部位置import <span class="string">&#x27;reflect-metadata&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span>;<span class="keyword">import</span> &#123; plainToClass &#125; <span class="keyword">from</span> <span class="string">&#x27;class-transformer&#x27;</span>;<span class="keyword">import</span> &#123;Product&#125; <span class="keyword">from</span> <span class="string">&#x27;./product-model&#x27;</span>; <span class="comment">// 模拟json数据const products = [    &#123;title: &#x27;A&#x27;, price: 12&#125;,    &#123;title: &#x27;B&#x27;, price: 15&#125;,]// 手动转换products.map(product =&gt; &#123;    let p = new Product(product.title, product.price);    console.log(p.getInformation());&#125;)// 使用class transformerconst targetProducts = plainToClass(Product, products);for (const p of targetProducts) &#123;    console.log(p.getInformation());&#125;const product = new Product(&#x27;book&#x27;, 12);console.log(product.getInformation());</span></span><br></pre></td></tr></table></figure>

<h3 id="class-validator"><a href="#class-validator" class="headerlink" title="class validator"></a>class validator</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/typestack/class-validator">Github</a></p>
</li>
<li><p>此模块只能在ts中使用</p>
</li>
<li><p>注意要把tsconfig.json中的<code>&quot;experimentalDecorators&quot;: true, </code>打开</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; validate &#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;<span class="keyword">import</span> &#123;Product&#125; <span class="keyword">from</span> <span class="string">&#x27;./product-model&#x27;</span>;<span class="keyword">let</span> p = <span class="keyword">new</span> Product(<span class="string">&#x27;&#x27;</span>, -<span class="number">2</span>);<span class="comment">// 返回promisevalidate(p).then(errors =&gt; &#123;    if (errors.length &gt; 0 ) &#123;        console.log(errors);    &#125; else &#123;        console.log(p.getInformation());    &#125;&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Google-Map项目"><a href="#Google-Map项目" class="headerlink" title="Google Map项目"></a>Google Map项目</h2><ul>
<li><p>使用百度地图API与axios</p>
</li>
<li><p>axios是一个js库，但是其原生包含.d.ts声明文件，所以也可以在ts项目中使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure></li>
<li><p>在渲染地图时，尽管我们用的是CDN形式的开发库，但是还是可以在ts中使用declare来引用，但是只能为其设置any类型，为了获得更好的类型支持，使用第三方的type支持即可（获取匹配Google Map js库的声明文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/googlemaps</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="在Nodejs项目中使用ts"><a href="#在Nodejs项目中使用ts" class="headerlink" title="在Nodejs项目中使用ts"></a>在Nodejs项目中使用ts</h2><ul>
<li><p>首先明确：<strong>Nodejs不能作为ts的运行时环境（Deno可以），ts首先应该被编译为js文件才行</strong></p>
</li>
<li><p>可以使用<a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node工具</a>来直接运行使用ts编写的node工具，但是其本质上也就是先编译成js再用nodejs运行而已</p>
<ul>
<li>可以在开发时使用，但是不推荐在生产环境使用</li>
</ul>
</li>
<li><p><code>npm init</code>  <code>tsc --init</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随node版本锁支持的js版本而定&quot;target&quot;: &quot;es2018&quot;,                          /* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */&quot;module&quot;: &quot;commonjs&quot;,                     /* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */// 声明nodejs环境下的commonjs依赖管理模式，并且不再加载dom等包&quot;moduleResolution&quot;: &quot;node&quot;,&quot;outDir&quot;: &quot;./dist/&quot;,                        /* Redirect output structure to the directory. */&quot;rootDir&quot;: &quot;./src/&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>npm install --save express bodyparser nodemon</code></p>
</li>
<li><p>众所周知，nodejs使用commonjs的模块加载方式，使用require函数加载包，但是默认的ts并没有这个函数，需要安装第三方依赖<code>npm install --save-dev @types/node</code></p>
</li>
<li><p>可以顺利加载express后，发现没有任何类型提示，因为express是完全的js库，因此同样的，安装<code>npm install --save-dev @types/express</code></p>
<ul>
<li><strong>即便加载了这些包，但是如果使用commonjs的require语法的话，可以编译并执行，但是还是没有类型提示，这是因为ts默认不支持commonjs的语法，可以使用ts支持的 es6的import语法，最终编译的结果会被编译为require的方式，因为在配置文件中设置了<code>&quot;moduleResolution&quot;: &quot;node&quot;,</code></strong></li>
</ul>
</li>
<li><p>之前使用nodemon都是全局安装，可以直接在命令行中使用ndemon命令，但是如果仅在当前项目安装的话，不能直接在命令行中使用，此时使用npm脚本即可</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon dist/app.js&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure></li>
<li><p><code>tsc -w</code>                <code>npm start</code></p>
</li>
<li><p><strong>可以说在nodejs项目中，ts的语法与浏览器端项目的语法一样，只不过被编译后的结果是不一样的格式</strong></p>
</li>
<li><p><strong>与webpack中一样，此时import时不用设置文件后缀名（因为node的运行机制本来就不需要识别后缀名）</strong></p>
</li>
<li><p><strong>如果要想获得nodejs后端开发中使用ts的最佳提要，去看看<a target="_blank" rel="noopener" href="https://nestjs.com/">nest.js</a>与<a target="_blank" rel="noopener" href="https://deno.land/">deno</a>吧，二者都原生支持ts的各种特性，并在框架内部充分使用了ts的特性比如修饰器等等，当然deno是与nodejs并行的另外一个js运行时环境了</strong></p>
<ul>
<li>除了上述两者之外，<a target="_blank" rel="noopener" href="https://angular.io/">Angular</a>是完全在ts的基础上开发的前端框架，有兴趣可以看看</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/typeScript/" rel="tag"># typeScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/11/pypi%E7%A7%81%E6%9C%89%E6%BA%90%E9%83%A8%E7%BD%B2/" rel="prev" title="pypi私有源部署">
      <i class="fa fa-chevron-left"></i> pypi私有源部署
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/11/OpenResty%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/" rel="next" title="OpenResty的部署与使用">
      OpenResty的部署与使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">TS 学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.</span> <span class="nav-text">TS是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo%E5%BC%95%E5%85%A5"><span class="nav-number">1.2.</span> <span class="nav-text">Demo引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.3.</span> <span class="nav-text">开发前的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">基础类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.</span> <span class="nav-text">ts编译器的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TS-%E4%B8%AD%E7%9A%84%E6%94%AF%E6%8C%81%E7%9A%84Modern-JS%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">TS 中的支持的Modern JS特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="nav-number">1.6.</span> <span class="nav-text">接口 interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.7.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.1.</span> <span class="nav-text">类继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E7%9A%84%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.</span> <span class="nav-text">ts中的复杂类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">复合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.2.</span> <span class="nav-text">索引类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.9.</span> <span class="nav-text">ts中的函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional-Chaining-%E5%8F%AF%E9%80%89%E9%93%BE"><span class="nav-number">1.9.1.</span> <span class="nav-text">Optional Chaining(可选链)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nullish-Coalescing-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6"><span class="nav-number">1.9.2.</span> <span class="nav-text">Nullish Coalescing 空值合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">ts中的泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">1.11.</span> <span class="nav-text">ts中的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.12.</span> <span class="nav-text">Demo 可视化的项目管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.13.</span> <span class="nav-text">ts中的模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Namespace"><span class="nav-number">1.13.1.</span> <span class="nav-text">Namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-Import-Export"><span class="nav-number">1.13.2.</span> <span class="nav-text">ES6 Import&#x2F;Export</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%8Ewebpack"><span class="nav-number">1.14.</span> <span class="nav-text">ts与webpack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">1.15.</span> <span class="nav-text">第三方模块的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lodash"><span class="nav-number">1.15.1.</span> <span class="nav-text">Lodash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-transformer"><span class="nav-number">1.15.2.</span> <span class="nav-text">class transformer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-validator"><span class="nav-number">1.15.3.</span> <span class="nav-text">class validator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Google-Map%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.16.</span> <span class="nav-text">Google Map项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8Nodejs%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8ts"><span class="nav-number">1.17.</span> <span class="nav-text">在Nodejs项目中使用ts</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
