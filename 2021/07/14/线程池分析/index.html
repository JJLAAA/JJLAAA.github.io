<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java线程池技术线程池概述 池化技术应该是最常用的提高程序性能的手段，包括线程池与数据库连接池，常量池等等 创建与销毁线程是比较耗费时间的，不利于处理Java程序的高并发，因此引入线程池，也就是维护一组可用的线程，如果有任务，就立即将线程池的空闲线程分配给任务，提升性能，如果线程池内所有的线程都是忙状态的话，可以将任务放到任务队列，或者创建一个新的线程并放入线程池，用于处理新的任务">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池分析">
<meta property="og:url" content="http://example.com/2021/07/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Long March">
<meta property="og:description" content="Java线程池技术线程池概述 池化技术应该是最常用的提高程序性能的手段，包括线程池与数据库连接池，常量池等等 创建与销毁线程是比较耗费时间的，不利于处理Java程序的高并发，因此引入线程池，也就是维护一组可用的线程，如果有任务，就立即将线程池的空闲线程分配给任务，提升性能，如果线程池内所有的线程都是忙状态的话，可以将任务放到任务队列，或者创建一个新的线程并放入线程池，用于处理新的任务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.demoli.xyz/image-20210415154301230.png">
<meta property="og:image" content="https://images.demoli.xyz/20201217092308.png">
<meta property="og:image" content="https://images.demoli.xyz/20201217104438.png">
<meta property="og:image" content="https://images.demoli.xyz/20200927190831.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210419143355740.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210419133922120.png">
<meta property="og:image" content="https://images.demoli.xyz/20201030154401.png">
<meta property="og:image" content="https://images.demoli.xyz/bV3K35">
<meta property="og:image" content="https://images.demoli.xyz/image-20210423201541482.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210426092911659.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210422141443980.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210427175959020.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210717144933245.png">
<meta property="og:image" content="https://images.demoli.xyz/image-20210425151258617.png">
<meta property="og:image" content="https://images.demoli.xyz/20201021135615.png">
<meta property="article:published_time" content="2021-07-14T13:25:11.000Z">
<meta property="article:modified_time" content="2021-07-17T08:31:11.359Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="Java基础-并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.demoli.xyz/image-20210415154301230.png">

<link rel="canonical" href="http://example.com/2021/07/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>线程池分析 | Long March</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Long March</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Long March">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线程池分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-14 21:25:11" itemprop="dateCreated datePublished" datetime="2021-07-14T21:25:11+08:00">2021-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-17 16:31:11" itemprop="dateModified" datetime="2021-07-17T16:31:11+08:00">2021-07-17</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java线程池技术"><a href="#Java线程池技术" class="headerlink" title="Java线程池技术"></a>Java线程池技术</h1><h2 id="线程池概述"><a href="#线程池概述" class="headerlink" title="线程池概述"></a>线程池概述</h2><ul>
<li>池化技术应该是最常用的提高程序性能的手段，包括线程池与数据库连接池，常量池等等</li>
<li><strong>创建与销毁线程是比较耗费时间的，不利于处理Java程序的高并发，因此引入线程池，也就是维护一组可用的线程，如果有任务，就立即将线程池的空闲线程分配给任务，提升性能，如果线程池内所有的线程都是忙状态的话，可以将任务放到任务队列，或者创建一个新的线程并放入线程池，用于处理新的任务</strong></li>
</ul>
<span id="more"></span>

<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用线程池的好处</strong></span></p>
<ul>
<li><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出<strong>线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</strong></span></p>
</blockquote>
</li>
<li><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等待线程创建就能立即执行。</p>
</li>
<li><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用线程池可以进行统一的分配，调优和监控</strong></span>。<strong>线程过少，无法充分利用硬件资源，线程过多，又会导致过度切换，过多的内存消耗，降低系统稳定性</strong></p>
<ul>
<li><p><strong>线程池监控的方法</strong>：</p>
<ul>
<li><p>SpringBoot 中的 <code>Actuator</code> 组件</p>
</li>
<li><p>通过<code>ThreadPoolExecutor</code>的自有接口获取线程池信息</p>
<img src="https://images.demoli.xyz/image-20210415154301230.png" alt="image-20210415154301230" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程池使用的注意事项"><a href="#线程池使用的注意事项" class="headerlink" title="线程池使用的注意事项"></a>线程池使用的注意事项</h2><ul>
<li><p><strong>使用<code>ThreadPoolExecutor</code>构造函数构建线程池而不是<code>Executors</code>工厂类，下文有具体的解释</strong></p>
</li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>显式的定义线程池名字，以业务名字作区分，便于定位问题</strong></span></p>
<ul>
<li><p>可以使用自定义的<code>ThreadFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用guava的<code>ThreadFactoryBuilder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="keyword">true</span>).build();</span><br><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>不同的业务使用不同的线程池</strong></span></p>
<ul>
<li>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务</li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>有依赖关系的任务在使用同一个线程池在稍高的并发状况下可能会出现一种逻辑上的死锁</strong></span>，大概来说就是父任务A中调用了子任务B，父任务与子任务共用一个线程池，当父任务占据了全部的核心线程资源，并且子任务仍未执行时，无法退出对核心线程的占用，而与此同时子任务只能堆积在任务队列中，无法获得线程资源，如果又使用了无界队列的话，则会一直堆积直到OOM，具体的参考<a target="_blank" rel="noopener" href="https://club.perfma.com/article/646639">线程池运用不当的一次线上事故</a></li>
</ul>
</li>
</ul>
<h2 id="线程池类的继承、实现关系–Executor框架"><a href="#线程池类的继承、实现关系–Executor框架" class="headerlink" title="线程池类的继承、实现关系–Executor框架"></a>线程池类的继承、实现关系–Executor框架</h2><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><ul>
<li><p>Executor 框架是 Java5 之后引进的，<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的execute方法就可以提交任务执行，然后就不用管了（如果需要返回值则调用submit方法做后续处理）</strong></span></p>
<ul>
<li><strong>可以联想到构建线程实例的两个方法，推荐使用传入Runnable参数而不是复写Thread类，其目的就是为了能够将任务与线程解耦</strong></li>
<li><strong>应该说在线程池中，任务的提交与任务执行的解耦是通过任务阻塞队列完成的，任务阻塞队列成为了实质上的消息队列</strong></li>
</ul>
</li>
<li><p><strong>Executor框架有助于避免<code>this</code>逃逸问题</strong></p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用。调用尚未构造完全的对象的方法可能引发令人疑惑的错误，如果用<code>volatile</code>或者final修饰的话应该就能解决这个问题了，不知道Executor框架的出现是如何有助于解决此问题的呢？—不是很清楚</p>
<p>实际上可查看ThreadPoolExecutor类的Worker类，发现thread实例确实使用final修饰（实现<strong>安全发布</strong>），不知道说的是不是这里</p>
</blockquote>
</li>
<li><p><strong>除了说Executor框架，还有一种说法就是<code>JUC框架</code>，也就是<code>java.util.concurrent</code>这个包下的所有的多线程相关类的总称，下面是Executor框架的继承关系图</strong></p>
<img src="https://images.demoli.xyz/20201217092308.png" style="zoom:80%;" />

<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>对Executor框架中每个类的大致描述（继承关系描述）</strong></span><ul>
<li>Executor：一个接口，其定义了一个接收Runnable对象的方法execute，该方法接收一个Runable实例。</li>
<li>ExecutorService：Executor的子类接口，其定义了可以接收Callable对象的方法submit，返回 Future 对象，同时提供execute方法。</li>
<li>ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务，定义了<code>schedule</code>、<code>scheduleAtFixedRate</code>、<code>schduleWithFixedDelay</code>方法。</li>
<li>AbstractExecutorService：抽象类，提供 ExecutorService 中定义的方法的默认实现，比如对submit方法做了实现。</li>
<li>ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。</li>
<li>ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后将小任务分配给线程池去执行，Join 是获得小任务的结果，类似于map reduce、并行计算。</li>
<li>ScheduledThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。</li>
<li>Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。<ul>
<li><strong>Executors内部有实现ExecutorService的内部类，用来创建一些特殊的线程池，其实就是创建一些包装类用来为线程池子提供一些特定的特征</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Executor的框架结构"><a href="#Executor的框架结构" class="headerlink" title="Executor的框架结构"></a>Executor的框架结构</h3><img src="https://images.demoli.xyz/20201217104438.png" style="zoom:80%;" />

<h4 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h4><p><strong>向普通线程池提交任务有两种方法：</strong></p>
<ol>
<li><p><code>execute</code>方法</p>
<ol>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>只接受<code>Runnable</code>的任务，也不会对Runnable类型的任务做包装，直接提交给线程执行或者放进任务阻塞队列，不提供返回值，源码分析见下文</strong></span></li>
</ol>
</li>
<li><p><code>submit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">  execute(ftask);</span><br><span class="line">  <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">  execute(ftask);</span><br><span class="line">  <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">  execute(ftask);</span><br><span class="line">  <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable与Callable的任务统一包装为FutureTask类型</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FutureTask对于Runnable的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">  <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Runnable task;</span><br><span class="line">  <span class="keyword">final</span> T result;</span><br><span class="line">  RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.task = task;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    task.run();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong><code>ThreadPoolExecutor</code>没有实现自己的submit方法，而是沿用的父类<code>AbstractExecutorService</code>的实现</strong></span></li>
<li><strong>传入<code>Runnable</code>的任务时可以指定一个返回值，也可以不指定，如果指定的话，Runnable转为RunnableAdapter后的结果返回值就是传入的返回值，如果没有传入就是返回null，对应的使用FutureTask获得的返回值也就是对应的返回值，这个传入的结果值的作用类似于是一个flag</strong><ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>因此可以说，虽然传入Runnable参数也可以获得Future的返回，可以用来判断异步任务的执行程度，以及处理任务运行的异常，但是获得有效返回值是不可能的，如果真想获得有效返回值应该去用Callable构建任务咯</strong></span></li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="submit方法中任务的封装"><a href="#submit方法中任务的封装" class="headerlink" title="submit方法中任务的封装"></a>submit方法中任务的封装</h5><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用submit提交任务在线程池中使用<code>Callable-Future</code>凭借的是<code>FutureTask</code>类</strong></span><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><code>submit</code>方法内部会将提交的任务（无论是<code>Runnable</code>还是<code>Callable</code>）都通过newTaskFor方法转化为<code>FutureTask</code>再提交给<code>execute</code>方法</span><ul>
<li><strong>当提交的为Runnable时，Runnble任务会在FutureTask内部进一步被封装为RunnableAdapter（父类是Callable）类型</strong></li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><code>submit</code>方法的返回对象的类型也是<code>FutureTask</code></span></li>
</ul>
</li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong><code>FutureTask</code>类实现的是<code>RunnableFuture</code>接口，而后者继承了<code>Runnable</code>与<code>Future</code>两个接口</strong></span><ul>
<li>从线程池的角度来看此接口将任务与返回结合，可以直接将引用提交给<code>execute</code>方法，然后再将引用返回即可使用到两个接口的功能</li>
<li>Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类（接口的实现）来供我们使用</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>FutureTask能够在高并发环境下确保任务只执行一次（执行前有状态判断，并且内部状态的维护是单向不可逆的）</strong></span></li>
</ul>
</li>
</ul>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ul>
<li><p>补充<code>Callable</code>与<code>Runnable</code>的差异：</p>
<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>前者的执行方法内部可以有返回值，并且如果无法得到有效返回值还可以抛出异常，后者的执行方法中没有返回值也不能抛出异常</strong></span></li>
</ul>
</li>
</ul>
<h5 id="从源码角度分析FutureTask"><a href="#从源码角度分析FutureTask" class="headerlink" title="从源码角度分析FutureTask"></a>从源码角度分析FutureTask</h5><ul>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>Callable接口提供了线程执行任务并提供任务执行结果的功能，但是线程池执行的是异步任务，如何有效的获取异步任务的返回？靠的就是Future接口提供的功能，Executor架构的submit方法将二者结合，而FutureTask对Future接口做了具体的实现，即如何异步获取Callable任务的返回结果，如何做到这一点的？实现Runnable接口，监控任务的执行，以得到有效的返回结果</strong></span></p>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>FutureTask在jdk1.7时依赖AQS构建，在JDK1.8后改为使用CAS+state变量的维护+WaitNode类型的链表来维护等待获取异步结果的线程（线程的阻塞使用的又是LockSupport）</strong></span></p>
<ul>
<li><strong>分析的过程中要注意，可能有多个线程尝试执行任务，但是要保证只执行一次</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从构造函数看起，可以接受Callable以及Runnable类型的任务，并将Ruunable任务转为RunnableAdapter类型的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">// 维护任务的执行状态</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable; <span class="comment">// 维护任务本身</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.callable = callable;</span><br><span class="line">  <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">  <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此类是Executors工厂类提供</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Runnable task;</span><br><span class="line">  <span class="keyword">final</span> T result;</span><br><span class="line">  RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.task = task;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    task.run();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 入口函数run方法，此方法就是线程池内工作线程执行的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护正在执行当前任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 避免重复执行</span></span><br><span class="line">  <span class="comment">// 执行前需要设置runner为当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">      !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                   <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Callable&lt;V&gt; c = callable;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">      V result;</span><br><span class="line">      <span class="keyword">boolean</span> ran;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行异步任务</span></span><br><span class="line">        result = c.call();</span><br><span class="line">        ran = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异步任务执行出错</span></span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">        ran = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 执行异常状态更新</span></span><br><span class="line">        setException(ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ran)</span><br><span class="line">        <span class="comment">// 执行任务执行完毕后的状态更新</span></span><br><span class="line">        set(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">    <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">    runner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">    <span class="comment">// leaked interrupts</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 判断是否有线程中断发生，并及时响应</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">      handlePossibleCancellationInterrupt(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. set方法执行任务完成后的状态更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护认知执行结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将状态更新为COMPLETING</span></span><br><span class="line">  <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">    <span class="comment">// 更新结果值</span></span><br><span class="line">    outcome = v;</span><br><span class="line">    <span class="comment">// lazy 设置为NORMAL状态</span></span><br><span class="line">    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">    finishCompletion();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行出现异常，返回异常信息，任务执行结束</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">    outcome = t;</span><br><span class="line">    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">    finishCompletion();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Future接口的常用 API</span></span><br><span class="line"><span class="comment">// 判断任务是否取消</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务执行是否已经结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> state != NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消任务</span></span><br><span class="line"><span class="comment">// true----即便任务已经开始执行了也要中断</span></span><br><span class="line"><span class="comment">// false----如果任务已经执行了，就先执行吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                                 mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">    <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread t = runner;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">          t.interrupt();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    finishCompletion();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞获取异步结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = state;</span><br><span class="line">  <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">    s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">  <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> s = state;</span><br><span class="line">  <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">      (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">  <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞或超时阻塞函数 使用LockSupport</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程队列的头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">  WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 自旋中判断任务执行的状态</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 判断线程是否中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      removeWaiter(q);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务结束了，尝试获取返回值吧</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">        q.thread = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还要再等等，等下一个时间片到的时候再看看</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务还没有开始执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">      q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排队</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">      <span class="comment">// 本次循环排好队，下次循环就得去阻塞了</span></span><br><span class="line">      <span class="comment">// 维护头节点</span></span><br><span class="line">      queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                           q.next = waiters, q);</span><br><span class="line">    <span class="comment">// 设置了超时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">      nanos = deadline - System.nanoTime();</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        removeWaiter(q);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125;</span><br><span class="line">      LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 排hao队的线程执行阻塞</span></span><br><span class="line">      LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 任务执行完毕（或者异常退出）后执行的方法</span></span><br><span class="line"><span class="comment">// 唤醒等待的线程，可以尝试获取结果了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">  <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="comment">// 在循环中不断唤醒等待链表中的线程</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Thread t = q.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">          q.thread = <span class="keyword">null</span>;</span><br><span class="line">          LockSupport.unpark(t);</span><br><span class="line">        &#125;</span><br><span class="line">        WaitNode next = q.next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">        q = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 钩子函数等待被子类实现</span></span><br><span class="line">  done();</span><br><span class="line">	<span class="comment">// 帮助GC</span></span><br><span class="line">  callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>无论是AQS还是FutureTask中，LockSupport以及其他的一些线程挂起方法总是在for死循环中使用的，这是因为，一方面需要线程自旋的去判断能否跳出自旋获得锁资源或者其他的什么资源，另一方面如果符合挂起条件后，就不再自旋，避免浪费CPU，等到被唤醒后，重新进入循环，判断条件是否能获得对应资源，而不是立即跳出循环</strong></span></li>
<li><strong>注意有一个done函数作为钩子函数，在任务执行完毕后调用</strong></li>
</ul>
</li>
</ul>
<p><strong>向定时任务线程池中提交任务有以下三种方法（ScheduledExecutorService中定义）</strong></p>
<ul>
<li><p>schedule <strong>一次性的延迟任务执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">                                              <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                                                            triggerTime(delay, unit)));</span><br><span class="line">  delayedExecute(t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">                                              <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                                                                         triggerTime(delay, unit)));</span><br><span class="line">  delayedExecute(t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">  <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> schedule(Executors.callable(task, result), <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>这里值得补充的是，<code>ScheduledThreadPoolExecutor</code>重写了<code>execute</code>与<code>submit</code>方法，两个方法内部实际上都是简单地调用<code>schedule</code>方法来实现的</strong></span></li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>schedule支持Runnable或者是Callable的任务，另外两个方法只支持Runnable</strong></span></li>
</ul>
</li>
<li><p>scheduleAtFixedRate <strong>从上一轮任务开始时刻算起的定时循环任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">    <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                  <span class="keyword">null</span>,</span><br><span class="line">                                  triggerTime(initialDelay, unit),</span><br><span class="line">                                  unit.toNanos(period));</span><br><span class="line">  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">  sft.outerTask = t;</span><br><span class="line">  delayedExecute(t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>scheduleWithFixedDelay <strong>从上一次任务结束开始算起的定时循环任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">    <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                  <span class="keyword">null</span>,</span><br><span class="line">                                  triggerTime(initialDelay, unit),</span><br><span class="line">                                  unit.toNanos(-delay));</span><br><span class="line">  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">  sft.outerTask = t;</span><br><span class="line">  delayedExecute(t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>后两者的区别见图</p>
<img src="https://images.demoli.xyz/20200927190831.png" style="zoom:80%;" />

<ul>
<li><p>引出两个问题：</p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'>如果在fixed-rate模式下，任务的执行时间大于间隔时间，那么任务是怎样安排执行的呢？ 答案是：<strong>后续的任务会在上一个任务执行完毕后再开始执行，而不管执行间隔了,也就是延迟执行，而不是并发执行</strong></span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>如果做定时间隔任务时，前边的任务出现异常，后续的任务会继续执行吗？ 答：一旦出现异常，当前的任务与后续的任务都不会再执行，而是卡住，可以能通过自定义afterExecute钩子方法来处理异常，保证抛出异常的任务取消，而其他任务继续执行</strong></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>显然定时任务线程池的入口方法就不是execute了，而是<strong>delayedExecute</strong>，源码分析在后边</li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>与submit方法一样，定时任务线程池提交任务的几个方法都对提交的任务做了包装，具体的源码分析在后面，其之所以与submit包装性质不一样是因为，submit的包装是为了使用Future的特性，而定时任务线程池中的包装是为了实现定时任务的基本功能，源码分析在后面</strong></span></li>
</ul>
</li>
</ul>
<h4 id="销毁（关闭）线程池"><a href="#销毁（关闭）线程池" class="headerlink" title="销毁（关闭）线程池"></a>销毁（关闭）线程池</h4><ol>
<li><p><code>shutdown方法</code> 关闭线程池，<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>执行此方法可以使线程池的状态由<code>RUNNING</code>变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕</strong></span></p>
<ol>
<li><p>执行<code>shutdown</code>方法后，可以执行<code>awaitTermination</code>方法，则会等待指定的时间让线程池关闭，若在指定时间内关闭则返回true，否则false</p>
</li>
<li><p>shutdown源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     		<span class="comment">// 上锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断调用者是否有权限shutdown线程池</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// CAS 设置线程池状态为SHUTDOWN</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">// 中断所有空闲线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            <span class="comment">// 钩子函数</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>对于interruptIdleWorkers函数的解析与tryTerminate的解析放在了后边</strong></li>
</ul>
</li>
</ol>
</li>
<li><p><code>shutdownNow</code>方法 闭线程池，<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>执行此方法可以是线程的状态从<code>RUNNING</code>变为 <code>STOP</code>。线程池不再接受新任务，也不再处理队列中的任务，终止当前正在运行的任务，并返回正在等待执行的任务列表</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Runnable&gt; tasks;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  <span class="comment">// 上锁</span></span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否有权限shutdown线程池</span></span><br><span class="line">    checkShutdownAccess();</span><br><span class="line">    <span class="comment">// CAS 设置线程池状态为STOP</span></span><br><span class="line">    advanceRunState(STOP);</span><br><span class="line">    <span class="comment">// 中断所有线程</span></span><br><span class="line">    interruptWorkers();</span><br><span class="line">    <span class="comment">// 从队列中获取剩余的未执行的工作列表</span></span><br><span class="line">    tasks = drainQueue();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试终止线程池</span></span><br><span class="line">  tryTerminate();</span><br><span class="line">  <span class="comment">// 返回未执行的任务列表</span></span><br><span class="line">  <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>interruptWorkers</code>的解析放到了后文中</li>
</ul>
</li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>terminate方法，彻底终止线程池，此方法只在ThreadPoolExecutor中提供，默认实现为空函数，真正执行线程池terminate的方法是tryTerminate方法，terminated作为钩子函数在tryTerminate函数中被调用，线程池的状态由<code>TYDING</code>状态转为<code>TERMINATED</code>状态</strong></span></p>
</li>
<li><p>使用如下两个方法来判断线程池是否完全关闭</p>
<ol>
<li><p><code>isTerminated</code>() 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true，或者是执行<code>shutdownNow</code>后，线程池内的线程全部被中断，工作线程数量为0后返回true（看起来是在描述TIDYING状态，实际上在TYDING状态下执行tryTerminate才会转为TERMINATE状态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>isShutdown()</code> 当调用 <code>shutdown()</code> 方法后返回为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><h3 id="使用Executors工厂类创建线程池"><a href="#使用Executors工厂类创建线程池" class="headerlink" title="使用Executors工厂类创建线程池"></a>使用Executors工厂类创建线程池</h3><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>创建线程池的最方便的做法是使用<code>Executors</code>工厂类，可以创建普通的线程池与可以执行定时任务的线程池，但是简单的创建方法意味着封装的程度高，就会导致自由度低，甚至有一些风险</strong></span></li>
</ul>
<h4 id="普通的线程池"><a href="#普通的线程池" class="headerlink" title="普通的线程池"></a>普通的线程池</h4><ul>
<li><p><strong>固定线程数量的线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认任务队列的长度是Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心线程数量与最大线程数量一致，也就是核心线程就是全部可用的线程了；keepAlive设置为0，因为没有非核心线程</strong></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用的是LinkedBlockingQueue作为任务队列，默认的长度是Integer.MaxValue，因此带来隐患</strong></span><ul>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>所以一旦corePoolSize设置不对的话，将会有大量任务干等着，并且性能也没有完全发挥</strong></span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>允许创建的线程个数虽然有限制，但是允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的任务，从而导致 OOM</strong></span><ul>
<li><strong>注意这里说出现OOM的意思不是说队列中的任务数量超过 Integer.MAX_VALUE 造成溢出，这是不可能的情况，如果真的达到这个数量，向队列中添加新的任务就会失败，出现OOM是因为队列中存储太多的任务实例了，因此可能导致占用内存过大导致可分配内存不够进入导致OOM</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>当任务数量大于Integer.MAX_VALUE后，继续提交新的任务就直接会执行拒绝策略了</strong></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用场景在于维持固定的并发度</strong></span></li>
</ul>
</li>
<li><p><strong>仅有一个线程的线程池</strong></p>
<ul>
<li><p><strong>可以视为是固定线程数量线程池的特值情况，即nThreads为1的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用包装类包装过的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                            threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Executors中提供了不少包装类，用来实现特定功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">  FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">    <span class="keyword">super</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 线程池实例回收器可以执行shutdown方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只暴露被包装的ExecutorService实例中的所有接口方法，而不暴露其余实现类自定义的方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>在创建单线程线程池时使用包装类的目的在于：保证线程池实例维持单线程运行，不允许通过ThreadPoolExecutor的一些set方法来添加线程数量，比如<code>setCorePoolSize</code>等</strong></span></p>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>因为可以看做是<code>newFixedThreadPool</code>的特例，所以隐患之处也一样，线程为1的目的在于保证所有任务按照执行顺序执行</strong></span></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>动态分配线程数量的线程池</strong></span></p>
<ul>
<li><p><strong>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>核心线程数量设置为0，没有核心线程，全员非核心线程，都会在60秒内，接不到活时被回收</strong></span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>动态分配与按需创建的功能的实现应归功于SynchronousQueue类型的任务队列，这个队列不会缓存任务，而是如果有空闲线程就一定会交给空闲线程执行，没有空闲线程就直接创建新线程</strong></span>：<ul>
<li><strong>在execute方法中首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前线程池中有线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，则任务成功添加到队列，并且随即被空闲线程消费，<code>execute()</code>方法执行完成；如果没有空闲线程则创建非核心线程去执行任务</strong></li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>虽然队列使用的是有界队列，但是最大线程数量是<code>Integer.MAX_VALUE</code>，这意味着线程池可以不受控的一直接受任务，直到栈空间OOM</strong></span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>使用场景或者优势在于灵活回收灵活分配</strong></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="执行定时任务的线程池"><a href="#执行定时任务的线程池" class="headerlink" title="执行定时任务的线程池"></a>执行定时任务的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">        <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>虽然队列使用的是有界队列，但是最大线程数量是<code>Integer.MAX_VALUE</code>，这意味着线程池可以不受控的一直接受任务，直到栈空间OOM</strong></span></p>
<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>需要注意的是，ScheduledTHreadPoolExecutor是ThreadPoolExecutord的子类，每一个构造函数中定义的最大线程数量都是Integer.MaxValue，所以不用工厂类自己手动创建也一样，无非就是能多自定义一个拒绝策略而已</strong></span><ul>
<li><strong>定时任务的实现依赖于延迟队列DelayedWorkQueue</strong></li>
<li><strong>超时参数设置全部默认为0</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>实现定时任务有其他的方案，比如springboot的@Scheduled注解与quartz等等</strong></span></p>
<blockquote>
<p><strong>备注：</strong> Quartz 是一个由 java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等</p>
</blockquote>
</li>
</ul>
<h3 id="ThreadPoolExecutor线程池原理"><a href="#ThreadPoolExecutor线程池原理" class="headerlink" title="ThreadPoolExecutor线程池原理"></a>ThreadPoolExecutor线程池原理</h3><ul>
<li>直接使用ThreadPoolExecutor构造线程池实例，使用有界队列和有限数量的线程数会保证安全</li>
</ul>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul>
<li><p>在关闭线程池章节中，查看源码实际上会发现线程池有许多状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment">     * two conceptual fields</span></span><br><span class="line"><span class="comment">     *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment">     *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In order to pack them into one int, we limit workerCount to</span></span><br><span class="line"><span class="comment">   * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2</span></span><br><span class="line"><span class="comment">     * billion) otherwise representable. If this is ever an issue in</span></span><br><span class="line"><span class="comment">     * the future, the variable can be changed to be an AtomicLong,</span></span><br><span class="line"><span class="comment">     * and the shift/mask constants below adjusted. But until the need</span></span><br><span class="line"><span class="comment">     * arises, this code is a bit faster and simpler using an int.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The workerCount is the number of workers that have been</span></span><br><span class="line"><span class="comment">     * permitted to start and not permitted to stop.  The value may be</span></span><br><span class="line"><span class="comment">     * transiently different from the actual number of live threads,</span></span><br><span class="line"><span class="comment">     * for example when a ThreadFactory fails to create a thread when</span></span><br><span class="line"><span class="comment">     * asked, and when exiting threads are still performing</span></span><br><span class="line"><span class="comment">     * bookkeeping before terminating. The user-visible pool size is</span></span><br><span class="line"><span class="comment">     * reported as the current size of the workers set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The runState provides the main lifecycle control, taking on values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class="line"><span class="comment">     *   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class="line"><span class="comment">     *   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class="line"><span class="comment">     *             and interrupt in-progress tasks</span></span><br><span class="line"><span class="comment">     *   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class="line"><span class="comment">     *             the thread transitioning to state TIDYING</span></span><br><span class="line"><span class="comment">     *             will run the terminated() hook method</span></span><br><span class="line"><span class="comment">     *   TERMINATED: terminated() has completed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The numerical order among these values matters, to allow</span></span><br><span class="line"><span class="comment">     * ordered comparisons. The runState monotonically increases over</span></span><br><span class="line"><span class="comment">     * time, but need not hit each state. The transitions are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment">     *    On invocation of shutdown(), perhaps implicitly in finalize()</span></span><br><span class="line"><span class="comment">     * (RUNNING or SHUTDOWN) -&gt; STOP</span></span><br><span class="line"><span class="comment">     *    On invocation of shutdownNow()</span></span><br><span class="line"><span class="comment">     * SHUTDOWN -&gt; TIDYING</span></span><br><span class="line"><span class="comment">     *    When both queue and pool are empty</span></span><br><span class="line"><span class="comment">     * STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment">     *    When pool is empty</span></span><br><span class="line"><span class="comment">     * TIDYING -&gt; TERMINATED</span></span><br><span class="line"><span class="comment">     *    When the terminated() hook method has completed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Threads waiting in awaitTermination() will return when the</span></span><br><span class="line"><span class="comment">     * state reaches TERMINATED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Detecting the transition from SHUTDOWN to TIDYING is less</span></span><br><span class="line"><span class="comment">     * straightforward than you&#x27;d like because the queue may become</span></span><br><span class="line"><span class="comment">     * empty after non-empty and vice versa during SHUTDOWN state, but</span></span><br><span class="line"><span class="comment">     * we can only terminate if, after seeing that it is empty, we see</span></span><br><span class="line"><span class="comment">     * that workerCount is 0 (which sometimes entails a recheck -- see</span></span><br><span class="line"><span class="comment">     * below).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将注释翻译下来就是对着几个线程池状态的具体描述：</p>
<ul>
<li><p><strong>其中五个状态</strong>：</p>
<p>RUNNING：接收新的任务，处理队列中的任务；</p>
<p>SHUTDOWN：不接收新的任务，<strong>但处理队列中的任务</strong>；</p>
<p>STOP：不接收新的任务，不处理队列中的任务，<strong>中断正在执行的任务</strong>；</p>
<p>TIDYING：<strong>所有任务都终止，有效线程数为0</strong>， <strong>线程过度到TIDYING时会调用terminated钩子方法</strong>；</p>
<p>TERMINATED：terminated()（<strong>实际上是tryTerminate方法</strong>）方法执行完毕后进入该状态；</p>
</li>
<li><p><strong>状态之间的转换</strong>：</p>
<p>RUNNING -&gt; SHUTDOWN：调用shutdown方法；</p>
<p>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow方法；</p>
<p><strong>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空（队列中没有未执行的任务了，并且所有线程都完成了工作处于赋闲状态）；</strong></p>
<p><strong>STOP -&gt; TIDYING：当线程池中工作线程数量为0（其实就是变为stop状态，对所有正在执行任务的线程执行中断，也不再处理队列中未处理的任务，一旦中断全部完成，所有工作线程数量就为0了，直接进入tidying状态，也不管队列中的任务了）；</strong></p>
<p>TIDYING -&gt; TERMINATED：<strong>当terminated（实际上是tryTerminate方法）方法执行完毕</strong></p>
</li>
<li><p>状态转换示意图</p>
<img src="https://images.demoli.xyz/image-20210419143355740.png" alt="image-20210419143355740" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池状态是由命名为ctl的AtomicIntegr的成员变量持有的（共32位）</strong></span>，包含以下两个信息：</p>
<ul>
<li><p>线程池状态-最高3位</p>
</li>
<li><p>线程池中线程数量-低29位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化线程池状态-RUNNING 0工作线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置位数 高3位与低29位分别表示线程池状态与线程池工作线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 线程的最大数量大概是5亿多</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;  <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;  <span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;  <span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;  <span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;  <span class="comment">// 011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 根据ctl获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 根据ctl获取线程池中工作线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 使用runstate与workercount组装ctl,初始状态下rs 为RUNNING wc为0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意大小比较关系</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事实上Integer.MAX_VALUE大于CAPACITY，所以可以说实际上下边的Executors中的构造函数中的最大线程池数量是根本无法达到的</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>为什么要把线程池数量和线程池状态维护在一个变量中？</strong></span><ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>因为事实上是需要维护线程池内有效线程数量和线程池状态的一致性的（源码中实际上许多地方是同时判断线程池状态与线程池内有效线程的数量的），如果二者分开维护会因为维护二者的一致性而浪费锁资源；</strong></span></li>
<li><strong>并且可以通过位运算去分别计算得到线程池状态与工作线程数量，效率也是很高的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ThreadPoolExecutor的整体架构与运行流程"><a href="#ThreadPoolExecutor的整体架构与运行流程" class="headerlink" title="ThreadPoolExecutor的整体架构与运行流程"></a>ThreadPoolExecutor的整体架构与运行流程</h4><p><img src="https://images.demoli.xyz/image-20210419133922120.png" alt="image-20210419133922120"></p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池在内部实际上构建了一个<code>生产者消费者模型</code>，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收</strong></span></li>
</ul>
<h4 id="Executor框架内的核心类–ThreadPoolExecutor"><a href="#Executor框架内的核心类–ThreadPoolExecutor" class="headerlink" title="Executor框架内的核心类–ThreadPoolExecutor"></a><span style='color:red;background:背景颜色;font-size:文字大小;'>Executor框架内的核心类–ThreadPoolExecutor</span></h4><ul>
<li>学习<code>ThreadPoolExecutor</code>构造方法（针对参数最多的学习）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">​                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line"></span><br><span class="line">​            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line"></span><br><span class="line">​            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line"></span><br><span class="line">​            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">null</span> :</span><br><span class="line"></span><br><span class="line">​                AccessController.getContext();</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">this</span>.handler = handler;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>ThreadPoolExecutor 3 个最重要的参数</strong></span>：</p>
<ul>
<li>corePoolSize : 核心线程数定义了最小可以同时运行的线程数量，所谓最小的含义就是，这些线程创建后即便没有任务执行，是空闲的，也要维持运行，<strong>除非设置了<code>allowCoreThreadTimeOut</code>,如果设置为true，则在超过<code>keepAliveTime</code>之后，空闲的核心线程也会被回收</strong><ul>
<li>注意这里会有一个误解需要澄清：<strong>并不是线程池启动起来后就立即维护起<code>corePoolSize</code>个线程，也是按需求来的，最先分配任务的<code>corePoolSize</code>自动成为核心线程</strong></li>
</ul>
</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。（<strong>注意是可以同时运行的最大的线程数量，不是当前正在运行的线程数量</strong>）</li>
<li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。<strong>拿队列当缓存，直到队列放满无法继续投放或者有空闲线程消费队列中的人物</strong><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>需要注意的是这个队列存储的仅仅是<code>execute</code>方法提交的<code>Runnable</code>任务，而不是其他的什么复杂的结构</strong></span></li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor其他常见参数:</p>
<ul>
<li>keepAliveTime:<strong>当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁（注意这里针对的是核心线程外的线程，核心线程也就是最小维持数量的线程会一直维持运行），而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</strong><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>其起作用的机制在于<code>getTask</code>函数中调用的阻塞队列的poll函数的超时设置</strong></span></li>
</ul>
</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory : 线程工厂。</li>
<li>handler :饱和策略。关于饱和策略下面单独介绍一下。<strong>当提交的任务过多而不能及时处理（这里的及时处理指的是任务队列已经满了，并且线程池已经达到了允许的最大线程量，）时，我们可以定制策略来处理任务</strong></li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>饱和策略（对应的是任务拒绝模块）</strong></span></p>
<ul>
<li><p>定义：饱和就是当任务队列满了，并且线程池当前同时运行的线程数量已经达到设定的最大值时的状态，<strong>更准确地定义应该是任务拒绝策略</strong>，而不仅仅是饱和策略，不仅仅线程池饱和的时候会执行拒绝，当线程池状态double-check线程池状态不是running状态时，也要对新提交的任务执行拒绝策略</p>
</li>
<li><p>任务的拒绝是通过reject函数完成的， 默认提供4个拒绝策略，当然也可以实现自己的拒绝策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理，<strong>此policy也是使用Executors工具类创建线程池以及我们不指定饱和策略使用ThreadPoolExecutor构造函数时的<span style='color:red;background:背景颜色;font-size:文字大小;'>默认的饱和策略</span></strong></p>
<ul>
<li>如果是比较关键的业务，推荐使用此拒绝策略，这样在系统不能承载更多任务时，及时通过异常发现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                       <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                       e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy：<strong>让提交任务的线程去运行任务，也就是直接在调用execute方法的线程（一般是主线程）中运行(run)被拒绝的任务，<span style='color:red;background:背景颜色;font-size:文字大小;'>如果执行程序（线程池）已关闭，则会丢弃该任务</span>。因此这种策略会降低对于新任务提交速度，影响程序的整体性能（因为Main线程去处理新提交的任务去了，就无法处理新的请求了）。<span style='color:red;background:背景颜色;font-size:文字大小;'>如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略</span></strong></p>
<ul>
<li>此策略适合处理大量计算任务的任务类型<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕</strong></span></li>
</ul>
</li>
<li><strong>此策略可以做分流，请求可以分别缓存在线程池工作队列-&gt;工作线程（一般是main线程）-&gt;TCP 层-&gt;客户端 达成了一定程度的可伸缩功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果线程池还在RUNNING状态</span></span><br><span class="line">  <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    <span class="comment">// 提交任务的当前线程直接执行任务</span></span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。（<strong>直接丢弃掉，甚至不会抛出异常</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 直接为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求（<strong>所谓的抛弃最早的未处理的任务请求，就是抛弃下一个待处理的任务，处于头部的任务</strong>），<strong>丢弃后再次尝试提交新的任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    <span class="comment">// 直接兀自取出下一个任务</span></span><br><span class="line">    e.getQueue().poll();</span><br><span class="line">    <span class="comment">// 重新提交任务</span></span><br><span class="line">    e.execute(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于以上几种饱和策略的理解补充：</p>
<p>​    <img src="https://images.demoli.xyz/20201030154401.png"></p>
</li>
</ul>
</li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>任务队列（线程安全的阻塞队列）</strong></span></p>
<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'>如果execute是线程池的任务调度器，是作为整个线程池的入口的话，那么任务缓冲队列可以看作是整个线程池的神经中枢，作为神经中枢，其起到了解耦任务与线程的操作，<strong>之所以有这一层缓冲，才有了所谓的调度</strong>—其实是一个生产者、消费者模式，其中生产者（一般是创建线程池的线程，main线程）投放任务，消费者（线程池中的工作线程）取任务去执行</span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>BlockingQueue除了提供阻塞方法之外一般也会同时提供超时阻塞版本以及非阻塞版本，线程池中三种类型的方法都有使用</strong></span></li>
<li>显然是一个队列模型，构造函数要求的任务队列类型是<code>BlockingQueue&lt;Runnable&gt;</code>,但是这个是一个接口类，真正可以使用的实现类有如下几种（<span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>具体的描述看自己总结的线程安全的容器这个文章</strong></span>）：<ul>
<li>LinkedBlockingQueue 无界队列，所谓的无界队列就是队列长度默认设置为<code>Integr.MAX_VALUE</code>，使用工具类创建线程池时，<strong>newFixedThreadPool与newSingleThreadExecutor都是使用的此类型的队列</strong></li>
<li>ArrayBlockingQueue 有界队列,一般自己使用的就是此队列,数组实现，一旦创建大小不可更改</li>
<li><strong>DelayedWorkQueue 定时任务的线程池使用的是此队列，按照任务的下一次执行的时间的早晚进行排序</strong></li>
<li>SynchronousQueue 直接提交，也就是不把任务存储，而知直接提交给线程，<strong>newCachedTHreadPool使用的就是这个</strong></li>
<li><strong>除此之外还有多种任务队列可供使用，包括优先级队列,双端队列等等</strong></li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>在普通线程池中，提交任务使用的是<code>boolean offer(E e)</code>，是一个非阻塞的方法（即队列满了后直接返回false），消费任务使用的是<code>E take() throws InterruptedException;</code>与<code>E poll(long timeout, TimeUnit unit) throws InterruptedException;</code>前者是阻塞的，后者是超时阻塞（keepAliveTime）</strong></span></li>
</ul>
</li>
<li><p><strong>线程工厂</strong></p>
<ul>
<li><strong>在创建线程池的时候，还可以传入一个重要的参数就是</strong><code>线程工厂</code>,默认情况下的线程池创建线程的过程都是其内部的<code>DefaultThreadFactory</code>，但是如果要用自定义的方式创建线程，以使用同一个模板批量的创建线程的话，就需要用到这个线程工厂的参数</li>
</ul>
</li>
</ul>
<h5 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a><span style='color:red;background:背景颜色;font-size:文字大小;'>任务调度</span></h5><ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>任务调度是整个线程池的入口，是整个线程池的核心所在，而这个任务调度对应的实际上就是<code>execute</code>方法</strong></span></p>
<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><code>execute</code>作为任务调度方法的大致运作流程是<strong>根据线程池的运行状态，工作线程的数量与运行策略来决定新提交的任务的三种可能的去向：</strong></span><ul>
<li>直接申请线程执行</li>
<li>缓冲到阻塞队列中</li>
<li>使用配置好的拒绝策略，拒绝任务的执行</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池中最重要的方法一定是任务的提交执行方法，又由于submit内部实际调用了execute方法，所以直接查看ThreadPoolExecutor的execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程池内正在运行的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 首先肯定是检查的任务的有效性，如果为null就要报空指针异常</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">​        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* Proceed in 3 steps:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         \* and so reject the task.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 检查完提交的任务的有效性之后就要执行如上英文注释的三个步骤的处理了</span></span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 获得线程池的状态与当前运行的线程的数量的记录（ThreadPoolExecutor类中定义了五种线程池状态）</span></span><br><span class="line">      <span class="comment">// ctl更像是一个线程池的运行时上下文的状态维护变量</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// addWorker失败，重新获得线程池状态，以进行下一步判断</span></span><br><span class="line">​            c = ctl.get();</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 2.如果当前之行的线程数量大于等于 corePoolSize 或者addWorker失败（失败的原因可能是有效线程的数量已经大于corePoolSize,所以需要缓存任务，在addWorker函数中确实有这样的逻辑）后就会走到这里</span></span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会将任务加入到任务队列中,并且判断是否能加入到任务队列中</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// 成功将任务添加到任务队列中</span></span><br><span class="line"></span><br><span class="line">​            <span class="comment">// 再次检查线程池中的线程状态，并再次检查线程池中是否有可用的线程，因为自从上一次检查后，可能有线程已经完成了工作或者线程池已经shutdown了</span></span><br><span class="line"></span><br><span class="line">​            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// 如果线程池状态不是running状态，就要从任务队列中移除任务，相当于一次回滚，并执行构造函数中参数指定的饱和策略</span></span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        <span class="comment">// 执行回滚</span></span><br><span class="line">​                reject(command);</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// 如果当前线程池是running状态并且工作线程为0（之前运行的工作线程被回收了，corePoolSize也有可能被回收）就新创建一个线程，其中worker的初始任务为null</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">​            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="comment">// 3. 任务队列已经满了，或者线程池已经不是running状态了 因此做最后的尝试，在创建一个新的线程试试，如果创建失败，表示线程池已经满了，因此执行饱和策略</span></span><br><span class="line">​        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line"></span><br><span class="line">​            reject(command);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>事实上，源代码的注释上就已经说的很清楚了。</p>
<img src="https://images.demoli.xyz/bV3K35" style="zoom:80%;" />

<ul>
<li><strong>文字说明</strong><ul>
<li>首先要保证的是，线程池状态必须是RUNNING状态才会接受新的任务，如果不是RUNNING状态，会直接执行拒绝策略<code>reject</code>函数</li>
<li>如果当前线程池中的有效线程池数量小于<code>corePoolSize</code>说明还可以无脑添加新的线程并使其执行新的任务（<strong>这也说明corePoolSize数量的线程也是懒创建的，不是默认就自动维护这么多数量的线程</strong>）</li>
<li>如果大于的话，就要尝试将新的任务缓存到任务队列中，如果任务队列没有满就加到任务队列，如果满了，没办法只能继续扩张线程数量了，此时判断当前的有效线程数量是否小于<code>maximumPoolSize</code>，如果小于，则创建新的线程并用来执行新的任务；如果有效线程数量已经大于<code>maximumPoolSize</code>，只能去执行拒绝策略了</li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>不要忽略源码中的double-check机制，在成功将任务加到缓存队列中后，要double-check线程池的状态是否还是RUNNING状态，如果不是及时回滚提交的任务，执行拒绝策略，除此之外还要检查工作线程是否已经全部被回收，如果全部被回收，需要创建一个空的Worker以备用，不能让线程池为空（如果线程池一直为空的话，下一个任务相当于纯创建一个线程，无法发挥线程池的性能优势了）</strong></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="线程管理与任务的获取"><a href="#线程管理与任务的获取" class="headerlink" title="线程管理与任务的获取"></a><span style='color:red;background:背景颜色;font-size:文字大小;'>线程管理与任务的获取</span></h5><ul>
<li><p><strong>线程池为了方便的掌握线程的状态与维护线程的周期，设计了工作线程对象<code>Worker</code></strong></p>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>Worker实现了<code>Runnable</code>的接口（使得Worker可以作为线程任务被执行，相当于将提交的任务做了包装，毕竟线程执行任务的行为需要Worker干预与FutureTask一样）和继承了<code>AQS</code>类（控制线程的中断，维护线程的生命周期）</strong></span></p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>在Worker中实现了任务与完成任务的线程的结合</strong></span></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread thread;</span><br><span class="line">  Runnable firstTask;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Worker中最重要的两个成员变量</p>
<ul>
<li><p>thread，在Worker的构造函数中被创建，使用的是ThreadPoolExecutor创建时传入的threadFactory去执行线程的构建</p>
</li>
<li><p>firstTask，firstTask用来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，<strong>那么线程就会在启动初期立即执行这个任务，执行完<code>firstTask</code>后再去队列中取后续的任务</strong>；<strong>如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务</strong></p>
<ul>
<li><strong>上边的描述针对的是一般的线程池，对于定时任务线程池来说，添加核心线程时，<code>firstTask</code>也是为<code>null</code>的</strong></li>
</ul>
<img src="https://images.demoli.xyz/image-20210423201541482.png" alt="image-20210423201541482" style="zoom:150%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>addWorker函数（任务调度时创建核心线程执行任务或者创建非核心线程，并启动工作线程）</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 跟踪线程池的最大大小，应该只有在持有全局锁mainLock的前提下才访问此属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回true表示创建并启动线程成功</span></span><br><span class="line"><span class="comment">// firstaTask就是这个线程的初始任务</span></span><br><span class="line"><span class="comment">// 第二个参数为true表示新的worker也就是工作线程是尝试加到corePool中还是maximumPool中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retry标志位常用于多循环嵌套的流程控制</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 获取线程池状态</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果状态&gt;= SHUTDOWN 表示线程池是正在关闭（SHUTDOWN）或者已经关闭(&gt;SHUTDOWN)状态的处置方法：</span></span><br><span class="line">            <span class="comment">// 如果此时是shutdown状态，并且没有分配初始任务，并且任务队列不为空，则是允许创建新的worker的（此时新创建的worker用来在SHUTDOWN状态下，执行任务队列中剩余的任务），违反任一则是不允许的，比如线程池已经关闭(&gt;SHUTDOWN)或者是SHUTDOWN状态，但是附加了自己的初始任务，是不允许的，只能执行队列中剩余的任务，或者队列已经为空了，不再需要新的worker了，也会创建失败</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">// 获取线程池中的线程数量</span></span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">// 判断当前线程池的数量与哪个值比较，如果已经达到最终的最大值CAPACITY，立即返回false</span></span><br><span class="line">                <span class="comment">// 否则根据参数判断与哪个值比较，是最小值还是最大值比较，如果目标是创建核心线程，就和corePoolSize比较，如果已经达到设计大小了，就创建失败，如果目标是创建非核心线程，就和maximumPoolSize比较</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 上一步判断后还可以添加worker，就使用CAS增加worker计数</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="comment">// 跳出整个循环</span></span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">// CAS 失败</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="comment">// 如果线程池状态发生了改变，</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="comment">// 从头开始执行整个外部的for循环，重新根据线程池状态进行判决</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// 省略的else表示的就是CAS失败的原因是线程数量被同步修改了，只需要重新执行内部的for循环，根据线程数量进行判决即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 线程数量成功更新，</span></span><br><span class="line">    <span class="comment">// 初始化工作线程启动成功标志</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 初始化工作线程创建成功标志</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建worker实例</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="comment">// 获得worker持有的线程实例</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="comment">// 获取线程池状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">          <span class="comment">// &lt; shutdown也就是running状态下执行操作  </span></span><br><span class="line">                    <span class="comment">// 或者是在SHUTDOWN状态下，并且firstTask为空时执行下述操作</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 判断线程是否已经启动了，若已经启动了，抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       <span class="comment">// 将新创建的worker实例添加到worker集合中，是一个HashSet集合</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                       <span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                       <span class="comment">// 设置worker添加成功标志位</span></span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">// 启动worker</span></span><br><span class="line">                    <span class="comment">// 实际上执行的是runWorker函数，参数为worker实例</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    <span class="comment">// 设置worker启动成功标志位</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">               <span class="comment">// worker启动失败，要执行回滚</span></span><br><span class="line">               <span class="comment">// 从工作线程集合中移除新添加的Worker实例</span></span><br><span class="line">               <span class="comment">// 线程池状态中线程池数量-1</span></span><br><span class="line">               <span class="comment">// tryTerminate</span></span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回worker是否启动的状态</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池中的Worker存储在HashSet结构中，只能在加锁的时候可以访问此线程集</strong></span></p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池通过维护<code>workers</code>这个集合来维护线程不被回收，当需要回收时，只需要将其引用消除，也就是将<code>Worker</code>对象消除即可，<code>jvm</code>会完成后续的回收（详见线程回收小节）</strong></span></li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池本身如何保证在运行时保证线程安全呢—–使用ReentrantLock，同时Condition用来支持awaitTermination的实现</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              	<span class="comment">// 在tryTerminate方法中被唤醒</span></span><br><span class="line">                nanos = termination.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>从<code>addWorker</code>源码中，也能看见线程池状态与线程池数量共同决定流程走向的场景，这就是为什么要把这两个状态维护在一个变量中的原因</strong></p>
</li>
<li><p>流程图</p>
</li>
</ul>
<img src="https://images.demoli.xyz/image-20210426092911659.png" alt="image-20210426092911659" style="zoom:50%;" /></li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>runWorker函数，worker开始执行任务</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如何addWorker中启动线程的语句t.start()转到了runWorker方法呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker的线程实例是在Worker构造函数中完成初始化的，注意，传入newThread的是this，也就是Worker实例本身被当做一个Runnable任务提交到了线程中，所以调用线程实例的start方法时，就会执行Runnable任务也就是Worker实例的run方法</span></span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); <span class="comment">// 将AQS计数设置为-1，目的是为了在worker初始化导致runWorker被执行的期间内不被中断</span></span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// thread成员变量由默认的或者指定的线程工厂创建，传入的Runnable参数是Worker实例本身</span></span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程启动后执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// addWorker: </span></span><br><span class="line"><span class="comment">// 创建worker实例</span></span><br><span class="line">w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"><span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新线程后执行Runnbale参数的run方法，也就是Worker实例的run方法</span></span><br><span class="line">t.start()</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  上述代码是addWorker中的启动线程的代码</span></span><br><span class="line"><span class="comment">*  下边的代码是runWorker中的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实际在新线程中执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 首先保存初始任务。再清空初始任务</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">      w.unlock(); <span class="comment">// worker 允许中断，此时worker的状态是空闲状态，可以被回收（中断）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 初始化线程异常退出标志位</span></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行初始化任务，或者while循环不断的阻塞以从任务队列获得新的任务，除非getTask返回null，表示已经无法获得任务，需要执行线程回收</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功的获取了任务</span></span><br><span class="line">          <span class="comment">// 开始执行任务，不允许中断，此时线程是非空闲状态</span></span><br><span class="line">          w.lock();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 执行recheck 如果线程池已经关闭了，并且当前线程还没有中断，就要执行对当前线程的中断，否则要保证当前线程不是中断状态</span></span><br><span class="line">          <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">               (Thread.interrupted() &amp;&amp;</span><br><span class="line">                runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">              !wt.isInterrupted())</span><br><span class="line">            wt.interrupt();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 钩子函数，默认的钩子函数的函数体为空，可以去构造ThreadPoolExecutor的子类去复写此钩子函数</span></span><br><span class="line">            beforeExecute(wt, task);</span><br><span class="line">            Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 执行任务</span></span><br><span class="line">              task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">              thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">              thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">              thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 钩子函数与beforeExecute同理</span></span><br><span class="line">              afterExecute(task, thrown);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// worker的完成的任务数量加1，注意此时是线程安全的</span></span><br><span class="line">            w.completedTasks++;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            w.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程不是因为异常退出的，而是因为无法获得任务导致退出的</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// while循环已无法通过getTask获得新的任务了，具体的原因参考后续的getTask方法</span></span><br><span class="line">        <span class="comment">// 执行线程回收</span></span><br><span class="line">        <span class="comment">// 如果是因为task执行时出现异常，completedAbruptly为true，否则为false</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>总的来说，Worker启动后的命运就是孜孜不倦的获取任务与执行任务，一旦不能及时的接受任务就会被销毁，这就是打工人？</strong></p>
</li>
<li><p>如何<code>addWorker</code>中启动线程的语句<code>t.start()</code>转到了<code>runWorker</code>方法呢？这一块比较绕，可以直接看代码的注释</p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>这里就体现了<code>Worker</code>类实现<code>Runnable</code>接口的作用，就是将自己包装为可执行任务，以便于干预线程执行任务的过程</strong></span></li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>注意方法中出现的对于Worker的声明周期维护</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Worker初始化的时候设置state为-1，避免工作线程初始化到正常执行任务这段时间内被回收</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 进入runWorker函数后，此时线程需要自己努力获取任务并执行任务了，如果一直获取不到，是可能被回收的，因此要释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果领导了任务，要设置加锁，表示自己在工作了，不要回收自己</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 任务执行完毕或者执行任务出现异常要释放锁</span></span><br></pre></td></tr></table></figure></li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>注意两个钩子函数，可以在子类中复写以实现其功能</strong></span></p>
<ul>
<li>beforeExecute</li>
<li>afterExecute</li>
</ul>
</li>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>导致出现线程回收的原因有两个</strong></span></p>
<ul>
<li><strong>任务执行过程中出现异常，注意每次catch后，都会记录下异常，然后重新抛出异常，导致跳出最外边的try代码块</strong></li>
<li><strong>无法从队列中获取新的任务，跳出while循环具体原因参考<code>geTask</code>方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>getTask方法，也就是从队列中获取任务的方法也是很重要的,主要功能是核心线程获取任务或保持阻塞，非核心线程获取任务，或超时返回null,进而线程生命周期结束</strong></span></p>
<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>在这个函数中，充分体现了核心线程与非核心线程的区别，以及keepAlive参数起作用的机制；同时也注意allowCoreThreadTimeOut参数的作用</strong></span></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取任务超时的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">            <span class="comment">//线程池状态是STOP之后的状态，表示已经不处理任务了，或者是SHUTDOWN时，任务队列已经为空，想处理也没的处理了，就直接返回null，worker会被直接回收</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 工作线程数量-1</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//是否超时控制，allowCoreThreadTimeOut默认false，代表不对核心线程做超时限制，对于超出核心线程的线程需要控制超时</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">     <span class="comment">//当线程数大于最大线程数，即线程池已经满了，或者需要做超时控制且上次获取任务就已经超时这两个任一的条件下</span></span><br><span class="line">          <span class="comment">//且线程数大于1或者队列为空，尝试将线程数减一并返回null</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 失败重试，重新根据线程池状态与线程池中线程数量做判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//当需要超时控制时，在keepAliveTime时间内没有获取到任务的话会设置超时标志位，如果没有超时限制，则调用take获取任务，此时线程是阻塞等待获取任务的</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待获取任务时，整个worker并没有加锁，也就是被认为是空闲状态，可能会被回收掉</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>这里需要补充的就是任务队列的poll与take方法虽然名称差异比较大，但是唯一的差异在于前者是加了超时时间，后者是阻塞</strong></p>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>注意很关键的一句判断<code>boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</code>，直接决定了对于核心线程与非核心线程的不同的对待方式</strong></span></p>
<p><img src="https://images.demoli.xyz/image-20210422141443980.png" alt="image-20210422141443980"></p>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收</strong></span></p>
<ul>
<li><p>比如在下边这段代码中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">    &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">  <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 失败重试，重新根据线程池状态与线程池中线程数量做判断</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当前线程池内的线程数量超过最大值会进行线程回收</li>
<li>存在超时设置，并且上一次获取任务已经超时时，如果任务队列还有不少任务，线程数量又恰好只有一个，是不会对当前这个独苗进行回收的，而是再试试</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>decrementWorkerCount</code>与<code>compareAndDecrementWorkerCount</code>二者的区别是什么</strong></p>
<ul>
<li><strong><code>decrementWorkerCount</code>内部是在循环调用<code>compareAndDecrementWorkerCount</code>，换句话说就是，必须要尝试将工作线程数量-1，因为确实不需要此线程了，而<code>compareAndDecrementWorkerCount</code>直接拿来用，只是尝试一次将工作线程-1，如果失败的话，就要重新根据状态做出可能与之前不同的判断</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程回收，<code>processWorkerExit</code></strong></span></p>
<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>实际上，关于线程回收，是有两种场景的：1. 主动的线程回收，比如<code>processWorkerExit</code>函数这样的（runWorker函数中调用） 2. 探查式的回收，或者说是被动的回收，比如<code>interruptIdleWorkers</code>（shutdown函数、tryTerminate方法中调用）</strong></span></p>
</li>
<li><p>主动回收：在<code>runWorker</code>函数中，如果无法再获得任务，就会跳出执行此线程回收函数，<span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>实际上线程池中线程的回收依赖的是JVM的自动回收，线程池要做的只是把线程的引用消除而已</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个标志位，是否是因为发生线程异常，所以进入的此方法</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            <span class="comment">// 工作线程数-1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 加锁，因为要进行审计计数了</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 统计此worker的完成的任务数目</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">// 从线程池中移除此线程</span></span><br><span class="line">            <span class="comment">// 执行remove方法完毕后，实际上已经完成了线程的回收，但是由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程-----即所谓的线程状态自适应的过程</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 尝试中断、回收空闲线程</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">// 线程池状态是RUNNING或SHUTDOWN状态并且并非因为异常导致线程关闭的情况下</span></span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果线程够用，就直接返回，否则还要添加一个worker到线程池</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果因为线程异常导致的线程关闭的话，还需要再向线程池中补充一个worker</span></span><br><span class="line">          <span class="comment">// 或者是此时线程数量不能满足最小要求时也要再添加一个worker</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>workers访问时要加锁</strong></li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>在工作线程回收的方法中，比如getTask方法与本方法中总能发现对于线程池的线程的自适应调整过程</strong></span></li>
</ul>
</li>
<li><p>被动回收：<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>上述代码中提到的tryTerminate方法，也就是在某worker结束生命周期后判断线程池是否要关闭线程池以及回收空闲线程，以便有效的管理线程池的生命周期，在所有可能线程池可能已经终止的地方都调用了此方法</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//当线程池状态是RUNNING（状态正常）或者已经TIDYING或者已经TERMINATED（线程已经快关闭了）或者SHUTDOWN且还有任务没有被执行（SHUTDOWN状态需要处理完队列中的任务），直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 当前线程池状态是STOP状态或是SHUTDOWN状态但任务列表为空时，如果线程数量不为0,需要最多终止1个空闲的线程，上边所述的stop状态或者shutdown状态并且queue为空统称为终止流程开始的状态</span></span><br><span class="line">          <span class="comment">// 如果线程数不为0，则中断一个阻塞等待任务的空闲的工作线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">// 尝试中断最多一个阻塞等待任务的空闲的工作线程</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 如果当前工作线程数量为0就准备关闭线程池</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 尝试设置线程池状态为tidying状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果设置成功调用此钩子方法</span></span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 钩子方法执行完毕后，设置状态为TERMINATED，并设置线程数量为0</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        <span class="comment">// 通知调用awaitTermination的主线程，已经进入了TERMINATION状态</span></span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS失败的话，就重新根据状态进行判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>基本流程如下</strong></span>：<ul>
<li>如果线程池状态正常、线程池为SHUTDOWN状态但是还有存量任务要执行（嘛事没有）或者已经要结束了（TYDING、TERMINATE）（已经凉透了）则直接返回</li>
<li><strong>如果是STOP状态或者SHUTDOWN状态但是已经没有存量任务了，此时判断工作线程数量是否为0，不为0则尝试回收一个空闲线程，为0的话则说明要转TYDING状态与TERMINATED状态了，直接设置状态为TYDING，执行termintaed钩子函数，再设置为TERMINATED状态，唤醒awaitTermination的等待</strong></li>
</ul>
</li>
<li>调用了<code>tryTerminate</code>方法的地方有<ul>
<li><code>addWorkerFailed</code></li>
<li><code>processWorkerExit</code></li>
<li><code>shutdown</code></li>
<li><code>shutdownNow</code></li>
<li><code>remove</code>从队列中移除某任务</li>
<li><code>purge</code>从队列中移除所有被取消的任务</li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>在被动回收过程中，最重要的就是能了解线程的当前状态，在主动回收中尚且可以知道线程是需要回收的，但是被动回收时实际上并不清楚线程池中线程的状态，Worker通过继承AQS，使用AQS来实现不可重入的独占锁（使用AQS的独占模式）这个功能</strong></span><ul>
<li>没有使用可重入锁ReentrantLock，而是使用AQS，为的就是<span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>实现不可重入的特性去反应线程现在的执行状态</strong></span></li>
<li><strong>lock方法一旦获取了独占锁，表示当前线程正在执行任务中，如果正在执行任务，则不应该中断线程</strong></li>
<li><strong>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</strong></li>
</ul>
</li>
</ul>
<img src="https://images.demoli.xyz/image-20210427175959020.png" alt="image-20210427175959020" style="zoom:80%;" /></li>
<li><p>被动回收：<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>interruptIdleWorkers</strong></span>，中断空闲线程，使其不再阻塞等待任务，最主要的是在shutdown函数、tryTerminate中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">      Thread t = w.thread;</span><br><span class="line">      <span class="comment">// 判断线程是否已经被中断，是的话就什么都不做</span></span><br><span class="line">      <span class="comment">// 若未被中断，还要尝试获取worker的锁，此时如果worker如果已经通过lock方法获取了锁，则因为其不可重入的特性，导致此处为false，即对该worker不做任务处理</span></span><br><span class="line">      <span class="comment">// 使用tryLock方法来判断线程池中的线程是否是空闲状态</span></span><br><span class="line">      <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行线程中断</span></span><br><span class="line">          t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// worker释放锁</span></span><br><span class="line">          w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果未true，最多只会中断一个空闲线程，也可能一个线程也没有中断</span></span><br><span class="line">      <span class="comment">// 如果为false，则会持续遍历全部的worker，并尝试中断所有的空闲的线程</span></span><br><span class="line">      <span class="keyword">if</span> (onlyOne)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess();</span><br><span class="line">    advanceRunState(SHUTDOWN);</span><br><span class="line">    interruptIdleWorkers();</span><br><span class="line">    onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shutdown中调用了中断所有空闲线程的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>使用Worker的tryLock函数尝试获取锁，如果对应的Worker正在执行任务，则获取锁失败，否则获取成功，表明线程空闲，则执行中断</strong></span></p>
</li>
<li><p><strong>在shutdown函数中是回收全部的空闲线程，tryTerminate是尝试回收一个</strong></p>
</li>
<li><p><strong>只有在线程池终止流程开始状态下（线程池状态准备转入TIDYING状态，但是还有空闲线程的时候），传入的参数为true，其余调用都是false，也就是中断所有的空闲线程</strong></p>
<ul>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'>为什么仅在<code>tryTerminate</code>方法中，传入的参数为true，也就是最多中断一个空闲的线程呢？（解释的不是很清除，自己不是很懂…….）</span></p>
<ul>
<li><p><strong>当前线程池状态是STOP状态或是SHUTDOWN状态但任务列表为空时，如果线程数量还不为0，这说明，有可能是剩余的所有线程都是阻塞，而不能传递shutdown的指令，在线程池终止流程开始的状态下，必须最多使一个阻塞在等待获取任务的线程中断，才能传播shutdown信号，以免所有的线程陷入等待而无法关闭线程池</strong></p>
</li>
<li><p><strong>中断一个空闲线程，也能保证在线程池已经是<code>SHUTDOWN</code>状态后，新来的Worker也能最终退出</strong></p>
</li>
<li><p><strong>综上，为了保证线程池未来最终能够终止，总是仅中断一个空闲的工作程序就足够了，但是<code>shutdown</code>会中断所有空闲的工作程序，以便多余的工作程序迅速退出</strong></p>
</li>
<li><p>参考<code>interruptIdleWorkers</code>的注释</p>
</li>
</ul>
<blockquote>
<p>Interrupts threads that might be waiting for tasks (as indicated by not being locked) so they can check for termination or configuration changes. Ignores SecurityExceptions (in which case some threads may remain uninterrupted).<br>Params:<br>onlyOne – If true, interrupt at most one worker. This is called only from tryTerminate when termination is otherwise enabled but there are still other workers. In this case, at most one waiting worker is interrupted to propagate shutdown signals in case all threads are currently waiting. Interrupting any arbitrary thread ensures that newly arriving workers since shutdown began will also eventually exit. To guarantee eventual termination, it suffices to always interrupt only one idle worker, but shutdown() interrupts all idle workers so that redundant workers exit promptly, not waiting for a straggler task to finish.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>强制回收：<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>interruptWorkers</strong></span> shutdownNow中调用，所有线程都要回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Runnable&gt; tasks;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess();</span><br><span class="line">    advanceRunState(STOP);</span><br><span class="line">    interruptWorkers();</span><br><span class="line">    tasks = drainQueue();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate();</span><br><span class="line">  <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">      <span class="comment">// 遍历所有工作线程进行回收</span></span><br><span class="line">      w.interruptIfStarted();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在worker类中，粗暴的打断所有的已经执行过runWorker方法的worker</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t;</span><br><span class="line">  <span class="comment">// getState() &gt;= 0即state != -1,也就是不是刚初始化的Worker，而是已经运行runWorker的Worker</span></span><br><span class="line">  <span class="comment">// 直接在线程层面执行中断，而不管worker此时是否是正在运行的状态（不用去获取worker的锁）</span></span><br><span class="line">  <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>执行shutdownNow函数后要立即中断所有正在工作的线程，因此不去尝试获取锁而是直接执行线程的中断</strong></span></li>
</ul>
</li>
</ul>
</li>
<li><p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>从AQS的角度理解Worker的生命周期</strong></span></p>
<p><img src="https://images.demoli.xyz/image-20210717144933245.png" alt="image-20210717144933245"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/60f27d977d9c087bac5b7393">源图参考</a></li>
</ul>
<p><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong><code>Worker</code>使用的是<code>AQS</code>的独占模式，使用独占的特性来判断Worker本身是空闲状态（未上锁）还是工作状态（上锁）</strong></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. worker初始化</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); <span class="comment">// 设置AQS计数标志为-1，其目的是为了防止初始化到runWorker执行这段时间内被中断</span></span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. runWorker函数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 至此worker是被以被中断的，也就是进入了空闲状态</span></span><br><span class="line">  w.unlock();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  w.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占模式下释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置独占的线程为null</span></span><br><span class="line">  setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 设置状态为0</span></span><br><span class="line">  setState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker的实现，其实根本没有用到参数--1 因为规定就是状态1为上锁的状态，所以直接用的常量1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试获得worker的锁，必须保证锁状态的旧状态是0，才能设置状态为1</span></span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interruptIdleWorkers函数执行时尝试中断空闲的线程，会通过尝试获取锁的方法来判断线程的状态</span></span><br><span class="line"><span class="comment">// 在tryAcquire方法中尝试设置状态为1，但是状态的当前值应是0（即执行unlock（）之后），才能设置成功</span></span><br><span class="line"><span class="comment">// 这一点也保证了，在Worker初始化设置状态为-1到runWorker的状态设置为0时，是能够保证不被中断的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ScheduledThreadPoolExecutor线程池原理"><a href="#ScheduledThreadPoolExecutor线程池原理" class="headerlink" title="ScheduledThreadPoolExecutor线程池原理"></a>ScheduledThreadPoolExecutor线程池原理</h3><ul>
<li><p>上边说过了，定时任务线程池的核心入口就是<code>delayedExecute</code>，但是在说这个关键的入口方法之前，不得说下，调用方法前对于提交的任务的包装，包装这一块设计到的类比较多，先用一张类图大致把握</p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>之所以在定时任务线程池中需要着重讲解任务的包装是因为其不同于普通线程池中对于任务的包装主要是用来实现Future的相关功能实现异步的获取任务执行的返回结果或者是异常，定时任务线程池中对于任务的包装可以直接用来实现定时执行逻辑</strong></span></li>
</ul>
<p><img src="https://images.demoli.xyz/image-20210425151258617.png" alt="image-20210425151258617"></p>
</li>
<li><p>首先包装为<code>ScheduledFutureTask</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于包装schedule(Runnable)提交的任务</span></span><br><span class="line"><span class="comment">// result为null，ns是纳秒为单位的，要触发执行任务的系统时间</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">  <span class="keyword">super</span>(r, result);</span><br><span class="line">  <span class="keyword">this</span>.time = ns;</span><br><span class="line">  <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 包装schedule(Callable)提交的任务</span></span><br><span class="line"><span class="comment">// ns是纳秒为单位的，要触发执行任务的系统时间</span></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">  <span class="keyword">super</span>(callable);</span><br><span class="line">  <span class="keyword">this</span>.time = ns;</span><br><span class="line">  <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装scheduleWithFixedDelay和scheduleAtFixedRate提交的任务</span></span><br><span class="line"><span class="comment">// result 为null</span></span><br><span class="line"><span class="comment">// ns是纳秒为单位的，下一次要触发执行任务的系统时间</span></span><br><span class="line"><span class="comment">// period是以纳秒为单位的任务循环周期</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">  <span class="keyword">super</span>(r, result);</span><br><span class="line">  <span class="keyword">this</span>.time = ns;</span><br><span class="line">  <span class="keyword">this</span>.period = period;</span><br><span class="line">  <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker开始执行任务时执行此方法，要区分是一次性执行的任务，还是周期执行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 首先判断是不是周期性执行的任务</span></span><br><span class="line">  <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">  <span class="comment">// 判断当前的线程池能否执行定时任务，如果不能则取消任务</span></span><br><span class="line">  <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">    cancel(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">    <span class="comment">// 如果不是周期性任务，也就是一次性的定时任务的话，直接执行提交的任务</span></span><br><span class="line">    ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">  <span class="comment">// 如果是周期性执行的任务，首先执行提交的任务，并将任务的状态重置为初始化状态，以备下一次执行</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">    <span class="comment">// 执行完毕后计算下一次执行的时间</span></span><br><span class="line">    setNextRunTime();</span><br><span class="line">    <span class="comment">// 重新提交当前的任务到延时队列中，用于下一个周期的执行</span></span><br><span class="line">    reExecutePeriodic(outerTask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 定时循环任务在执行完一次后重新提交执行，所谓的提交就是直接访达延迟队列中 </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">      <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">        task.cancel(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下一次要执行任务的时间</span></span><br><span class="line"><span class="comment">// time表示下一次执行任务的时间，period是用来计算time的周期时间</span></span><br><span class="line"><span class="comment">// 此方法中体现出scheduleAtFixedRate与scheduleWithFixedDelay的区别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> p = period;</span><br><span class="line">  <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// scheduleAtFixedRate</span></span><br><span class="line">    <span class="comment">// 在第一次执行完任务后，下一次要执行的时间就是完全按照周期来执行，不管到底什么时候执行完的，之后的每次执行都是如此</span></span><br><span class="line">    time += p;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// scheduleWithFixedDelay</span></span><br><span class="line">    <span class="comment">// 第一次执行完任务后，下一次要执行的时间是以当前时间为基准计算的，也就是上一次完成任务的时间为基准计算的，之后的每次执行都是如此</span></span><br><span class="line">    time = triggerTime(-p);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 下边的两个关键方法用于在DelayedWorkQueue中进行任务的排序与延迟的计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在延迟队列中按照下一次触发的顺序进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">    ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">    <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 触发时间一致的，按照提交的顺序来</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">  <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算从当前时刻到下次执行任务还有多长时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>与FutureTask（确实继承了FutureTask）和Worker一样都实现Runnable接口，以便于控制run方法内任务的执行</strong></span><ul>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>应该说这样的设计使用了静态代理的技术</strong></span></li>
</ul>
</li>
<li>注意两个重要的属性<ul>
<li>time 下次执行定时任务的时间</li>
<li>period 用来计算下次执行任务的周期时间，<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>显然period是否为0是schedule方法与另外两方法的最大区别</strong></span><ul>
<li>除此之外的另一个区别就是outterTask，后边有介绍</li>
</ul>
</li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>延迟任务队列的正常工作是保证定时任务能够正常调度的核心，对应的就是关键的两个方法，compareTo方法与getDelay方法</strong></span><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>ScheduleFutureTask实现了Comparable接口，其目的就在于要在延迟任务队列中，按照下次执行的时间顺序排列，先执行的排在前边</strong></span></li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>当Woker取下一个要执行的任务时，如果任务队列不为空，那么还要等待下一个任务到了执行时间之后，再交给线程池去执行，等多场时间？用getDealy计算</strong></span></li>
<li><span style='color:blue;background:背景颜色;font-size:文字大小;'><strong>应该可以这样说，从大体上看，延迟队列可以按照延迟时间进行排序+延迟队列中可以使用<code>getDelay</code>方法来控制获取任务的时延–这两个特性是直观上的延迟任务线程池起作用的关键</strong></span></li>
<li><strong>DelayedWorkQueue的源码在后边，主要就会提交任务和获取任务的三个方法</strong></li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong><code>scheduleWithFixedDelay</code>与<code>scheduleAtFixedRate</code>在实现时的区别就在于此次包装过程中，前者传入的周期是<code>unit.toNanos(-delay)</code>而后者是<code>unit.toNanos(perioid)</code></strong></span><ul>
<li><strong>其原理在于<code>setNextRunTime</code>方法中，详见方法注释</strong></li>
</ul>
</li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>在此次包装过程中，定时循环任务与一次行的定时任务在实现上除了<code>period</code>之外还有一个区别就是<code>outerTask</code></strong></span><ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>定时循环任务会持有此属性，以便能够在本轮任务执行完毕后，将当前的任务重新提交到延迟队列中，以备下一轮周期的执行，参考<code>reExecutePeriodic</code>方法</strong></span></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>其次包装为<code>RunnableScheduleFuture</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实际上是直接返回<code>RunnableScheduledFuture</code>，但是没有看懂为什么要用这样的一个方法类型提升</strong></li>
</ul>
</li>
<li><p>定时任务线程池的入口方法<code>delayedExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 判断线程池是不是shutdown状态，如果是执行拒绝策略</span></span><br><span class="line">  <span class="keyword">if</span> (isShutdown())</span><br><span class="line">    reject(task);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 首先就是向DelayedWorkQueue中添加任务</span></span><br><span class="line">    <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">    <span class="comment">// 3. 不管是一般的线程池还是执行定时任务的线程池，都会在向队列中添加完任务后执行re-check</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">        !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">        remove(task))</span><br><span class="line">      task.cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 4. 如果通过了recheck，执行此方法</span></span><br><span class="line">      <span class="comment">// 确保线程池内有线程运行</span></span><br><span class="line">      ensurePrestart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">  <span class="comment">// 对于Executors创建的线程池来说，核心线程数量为0，所以会保证有非核心线程执行</span></span><br><span class="line">  <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>如果线程池状态不是<code>SHUTDOWN</code>的话，直接向队列中添加任务，而没有直接让线程去执行任务的场景</strong></span></li>
</ul>
</li>
<li><p>从<code>addWorker</code>开始，后续的就是标准的线程池的线程管理与任务获取的流程了，也就是说定时任务线程池与一般线程池的主要区别在于任务调度部分，而连接任务管理与线程管理的通道–延时队列也需要大致了解下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 任务调度时提交任务的方法就是add方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Runnable e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> offer(e);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> i = size;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow();</span><br><span class="line">      size = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">        setIndex(e, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 按照排序规则，选择合适的位置插入到队列中</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">        leader = <span class="keyword">null</span>;</span><br><span class="line">        available.signal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按照排序规则，选择合适的位置插入到队列中</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">      <span class="comment">// 按照RunnableScheduledFuture的time属性进行排序</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      queue[k] = e;</span><br><span class="line">      setIndex(e, k);</span><br><span class="line">      k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// getTask中，核心线程取任务（无超时时间）</span></span><br><span class="line">  <span class="comment">// 如果当前不能获取，就阻塞等待</span></span><br><span class="line">  <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">          available.await();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 调用getDelay方法得到需要延时等待的时间</span></span><br><span class="line">          <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">          <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">          first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">          <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">            available.await();</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread thisThread = Thread.currentThread();</span><br><span class="line">            leader = thisThread;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              available.awaitNanos(delay);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">        available.signal();</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  getTask中，非核心线程取任务或则核心线程获取任务（允许超时回收）</span></span><br><span class="line">  <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            nanos = available.awaitNanos(nanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">          <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">          <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">          <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">            nanos = available.awaitNanos(nanos);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread thisThread = Thread.currentThread();</span><br><span class="line">            leader = thisThread;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">              nanos -= delay - timeLeft;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">        available.signal();</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>DelayedWorkQueue</code>的内部存储是<code>RunnableScheduledFuture</code>类型的数组</strong></li>
<li><strong>提交任务与获取任务用的是同一把锁，但是考虑到其内部要对执行时间做排序，使用同一把锁似乎也是应该的</strong></li>
</ul>
</li>
</ul>
<h4 id="线程池数量大小的确定"><a href="#线程池数量大小的确定" class="headerlink" title="线程池数量大小的确定"></a>线程池数量大小的确定</h4><p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> <strong>线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了上下文切换成本</strong>。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>任务从保存到再加载的过程就是一次上下文切换（时间片的轮转调度，线程状态在Runnable状态中，在Running和Ready之间转换）</strong></span>。</p>
<p><strong>上下文切换通常是计算密集型的</strong>。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p><strong>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</strong></p>
</blockquote>
<p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源（这里说的不是争取锁，而是争取CPU时间片，是由操作系统调度的），这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></span></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</strong></span></p>
<h3 id="ForkJoin线程池"><a href="#ForkJoin线程池" class="headerlink" title="ForkJoin线程池"></a>ForkJoin线程池</h3><ul>
<li>此线程池用来把大量数据的计算进行拆分（比如一个超大数组的求和），分配给线程池中的多个线程并行去执行，有并行计算那味了</li>
</ul>
<p><img src="https://images.demoli.xyz/20201021135615.png"></p>
<ul>
<li>Java标准库提供的java.util.Arrays.parallelSort(array)可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。<strong>还有stream的许多操作底层都用了ForkJoin线程池</strong></li>
</ul>
<h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p><code>shutdown vs shutdownNow</code></p>
<ol>
<li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 任务列表</strong></span></li>
</ol>
</li>
<li><p><code>isTerminated vs isShutdown</code></p>
<ol>
<li><p><strong><code>isShutDown</code></strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要是<code>非RUNNING</code>的状态都返回true</li>
</ul>
</li>
<li><p><strong><code>isTerminated</code></strong> </p>
<ol>
<li><strong>线程池在<code>tryTerminate</code>方法中进入<code>TIDYING</code>状态后再进入<code>TERMINATED</code>状态</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>注意几个钩子函数的使用（一般就是留给子类去使用）</p>
<ol>
<li>onShutdown<ol>
<li><strong>在ScheduledThreadPoolExecutor中调用，用来在执行shutdown方法后清除延迟队列中的任务</strong></li>
</ol>
</li>
<li>terminated<ol>
<li>tryTerminate中执行完此函数后，由TYDIING状态转为TERMINATED状态</li>
<li>默认是一个空函数</li>
</ol>
</li>
<li>futureTask 完成任务后执行done钩子函数</li>
<li>runWorker中的beforeExecute与afterExecute 默认是空函数<ol>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'><strong>如果做定时间隔任务时，前边的任务出现异常，后续的任务会继续执行吗？ 答：一旦出现异常，当前的任务与后续的任务都不会再执行，而是卡住，可以通过自定义afterExecute钩子方法来处理异常，保证抛出异常的任务取消，而其他任务继续执行</strong></span></li>
</ol>
</li>
<li>还能想到的就是LinkedHashMap覆写了HashMap中的钩子函数实现双向链表删除的维护与维持访问顺序等</li>
</ol>
</li>
</ol>
<p>有待进一步更新，这几天会逐步更新完毕，先占个坑~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651751537&idx=1&sn=c50a434302cc06797828782970da190e&chksm=bd125d3c8a65d42aaf58999c89b6a4749f092441335f3c96067d2d361b9af69ad4ff1b73504c&scene=21#wechat_redirect">Java线程池实现原理及其在美团业务中的实践–美团技术团队</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md">Java线程池学习总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472">Java线程池</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># Java基础-并发编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/12/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/" rel="prev" title="Atomic原子类">
      <i class="fa fa-chevron-left"></i> Atomic原子类
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/15/Unsafe%E7%B1%BB%E8%A7%A3%E6%9E%90/" rel="next" title="Unsafe类解析">
      Unsafe类解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF"><span class="nav-number">1.</span> <span class="nav-text">Java线程池技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">线程池概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.</span> <span class="nav-text">线程池使用的注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E2%80%93Executor%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.</span> <span class="nav-text">线程池类的继承、实现关系–Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">Executor框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">Executor的框架结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">任务的提交</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#submit%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">submit方法中任务的封装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90FutureTask"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">从源码角度分析FutureTask</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%80%E6%AF%81%EF%BC%88%E5%85%B3%E9%97%AD%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">销毁（关闭）线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.4.</span> <span class="nav-text">线程池的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Executors%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用Executors工厂类创建线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">普通的线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">执行定时任务的线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">ThreadPoolExecutor线程池原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">ThreadPoolExecutor的整体架构与运行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor%E6%A1%86%E6%9E%B6%E5%86%85%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E2%80%93ThreadPoolExecutor"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Executor框架内的核心类–ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">任务调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">线程管理与任务的获取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">ScheduledThreadPoolExecutor线程池原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">线程池数量大小的确定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoin%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.4.</span> <span class="nav-text">ForkJoin线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-1"><span class="nav-number">1.5.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.6.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
