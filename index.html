<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/%E4%BD%BF%E7%94%A8docker-compose-%E6%9E%84%E5%BB%BAWordPress%E5%B9%B3%E5%8F%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/%E4%BD%BF%E7%94%A8docker-compose-%E6%9E%84%E5%BB%BAWordPress%E5%B9%B3%E5%8F%B0/" class="post-title-link" itemprop="url">使用docker-compose 构建WordPress平台</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:19:44 / Modified: 15:20:18" itemprop="dateCreated datePublished" datetime="2021-07-11T15:19:44+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用docker-compose-amp-WordPress建站"><a href="#使用docker-compose-amp-WordPress建站" class="headerlink" title="使用docker-compose &amp;WordPress建站"></a>使用docker-compose &amp;WordPress建站</h1><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.28.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<ul>
<li>如果出现网络问题，直接用浏览器下载可执行文件放到<code>/usr/local/bin</code>目录下即可</li>
</ul>
<h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><ul>
<li><p>为WordPress提供HTTPS支持的Nginx配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> -p  /root/wordpress/nginx/conf &amp;&amp; mkdir -p  /root/wordpress/nginx/ssl \</span><br><span class="line">echo <span class="string">&#x27;server &#123;</span></span><br><span class="line"><span class="string">    listen 80;</span></span><br><span class="line"><span class="string">    server_name <span class="variable">$&#123;host_name&#125;</span>;</span></span><br><span class="line"><span class="string">    rewrite ^(.*)$  https://<span class="variable">$&#123;host_name&#125;</span><span class="variable">$1</span> permanent;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server &#123;</span></span><br><span class="line"><span class="string">    listen          443 ssl;</span></span><br><span class="line"><span class="string">    server_name     <span class="variable">$&#123;host_name&#125;</span>;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #ssl证书文件位置(常见证书文件格式为：crt/pem)</span></span><br><span class="line"><span class="string">    ssl_certificate      /etc/nginx/ssl/cert.pem;</span></span><br><span class="line"><span class="string">    #ssl证书key位置</span></span><br><span class="line"><span class="string">    ssl_certificate_key  /etc/nginx/ssl/cert.key;</span></span><br><span class="line"><span class="string">    ssl_session_timeout  10m;</span></span><br><span class="line"><span class="string">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class="line"><span class="string">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span></span><br><span class="line"><span class="string">    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    location / &#123;</span></span><br><span class="line"><span class="string">         proxy_pass    http://wordpress;</span></span><br><span class="line"><span class="string">         proxy_cache_bypass                 $http_upgrade;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         # Proxy headers</span></span><br><span class="line"><span class="string">         proxy_set_header Upgrade           $http_upgrade;</span></span><br><span class="line"><span class="string">         proxy_set_header Connection        &quot;upgrade&quot;;</span></span><br><span class="line"><span class="string">         proxy_set_header Host              $host;</span></span><br><span class="line"><span class="string">         proxy_set_header X-Real-IP         $remote_addr;</span></span><br><span class="line"><span class="string">         proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span></span><br><span class="line"><span class="string">         proxy_set_header X-Forwarded-Proto $scheme;</span></span><br><span class="line"><span class="string">         proxy_set_header X-Forwarded-Host  $host;</span></span><br><span class="line"><span class="string">         proxy_set_header X-Forwarded-Port  $server_port;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         # Proxy timeouts</span></span><br><span class="line"><span class="string">         proxy_connect_timeout              600s;</span></span><br><span class="line"><span class="string">         proxy_send_timeout                 600s;</span></span><br><span class="line"><span class="string">         proxy_read_timeout                 600s;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> &gt;&gt; /root/wordpress/nginx/conf/route.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>证书可以从阿里云免费申请，绑定到对应的**${host_name}**域名即可，并放置到<code>/root/wordpress/nginx/ssl/</code>目录下（可以自由修改，注意与下边的yaml文件保持一致即可）</li>
</ul>
</li>
<li><p>docker-compose yaml配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;version: &#x27;</span>3.1<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">services:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  nginx: </span></span><br><span class="line"><span class="string">    image: nginx</span></span><br><span class="line"><span class="string">    container_name: wp_nginx</span></span><br><span class="line"><span class="string">    restart: always</span></span><br><span class="line"><span class="string">    ports:</span></span><br><span class="line"><span class="string">      - 443:443</span></span><br><span class="line"><span class="string">      - 80:80</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - /root/wordpress/nginx/conf:/etc/nginx/conf.d/</span></span><br><span class="line"><span class="string">      - /root/wordpress/nginx/ssl/:/etc/nginx/ssl/</span></span><br><span class="line"><span class="string">  wordpress:</span></span><br><span class="line"><span class="string">    image: wordpress</span></span><br><span class="line"><span class="string">    container_name: wp</span></span><br><span class="line"><span class="string">    restart: always</span></span><br><span class="line"><span class="string">    environment:</span></span><br><span class="line"><span class="string">      WORDPRESS_DB_HOST: db</span></span><br><span class="line"><span class="string">      WORDPRESS_DB_USER: wp</span></span><br><span class="line"><span class="string">      WORDPRESS_DB_PASSWORD: wp_db_lee</span></span><br><span class="line"><span class="string">      WORDPRESS_DB_NAME: wp_db</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - wordpress:/var/www/html</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  db:</span></span><br><span class="line"><span class="string">    image: mysql:5.7</span></span><br><span class="line"><span class="string">    container_name: wp_mysql</span></span><br><span class="line"><span class="string">    restart: always</span></span><br><span class="line"><span class="string">    environment:</span></span><br><span class="line"><span class="string">      MYSQL_DATABASE: wp_db</span></span><br><span class="line"><span class="string">      MYSQL_USER: wp</span></span><br><span class="line"><span class="string">      MYSQL_PASSWORD: wp_db_lee</span></span><br><span class="line"><span class="string">      MYSQL_RANDOM_ROOT_PASSWORD: &#x27;</span>1<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - db:/var/lib/mysql</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">volumes:</span></span><br><span class="line"><span class="string">  wordpress:</span></span><br><span class="line"><span class="string">  db:&#x27;</span> &gt;&gt; /root/wordpress/wordpress.yaml \</span><br><span class="line">docker-compose -f wordpress.yaml up -d</span><br></pre></td></tr></table></figure>

<ul>
<li>如果镜像下载缓慢，<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-beijing/instances/mirrors">尝试使用阿里云的镜像加速器</a></li>
</ul>
</li>
</ul>
<h2 id="配置网络与域名"><a href="#配置网络与域名" class="headerlink" title="配置网络与域名"></a>配置网络与域名</h2><ul>
<li>只需要在域名提供商，为自己购买的域名，添加A类型的子域名记录比如<code>blog.demoli.xyz</code>，然后将解析值设置为自己服务器的公网IP即可</li>
</ul>
<h2 id="推荐安装插件"><a href="#推荐安装插件" class="headerlink" title="推荐安装插件"></a>推荐安装插件</h2><ul>
<li><strong>All-in-One WP Migration</strong> 迁移站点</li>
<li><strong>Post Views Counter</strong> 查看阅读数</li>
<li><strong>UpdraftPlus-备份/恢复</strong> 备份站点</li>
<li><strong>WP Githuber MD</strong> Markdown在线编辑</li>
<li><strong>Yoast SEO</strong> SEO设置</li>
</ul>
<h2 id="插件安装的问题"><a href="#插件安装的问题" class="headerlink" title="插件安装的问题"></a>插件安装的问题</h2><ul>
<li>插件安装出现网络错误时，可以进入插件官网，手动下载文件上传到指定文件夹安装，使用docker cp命令导入到容器即可。</li>
<li><strong>注意导入后，进入容器将导入的文件或文件夹的owner 与 group与其他WordPress文件一致</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/GitHub-Actions%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/GitHub-Actions%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">GitHub Actions使用案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:18:16 / Modified: 15:18:45" itemprop="dateCreated datePublished" datetime="2021-07-11T15:18:16+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端代码提交后，自动build（使用gradle）打包并将新的可执行jar包部署到指定服务器</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在项目根目录的<code>.github/workflows</code>目录下写如下文件<code>gradle_build.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Java</span> <span class="string">CI</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line"><span class="comment"># 设置触发条件</span></span><br><span class="line"><span class="comment"># 1. 对main分支执行push操作或者pull request操作时触发</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"><span class="comment"># CI/CD 任务流程</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 指定构建容器环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># 1：下载源码（拉取代码到构建容器中）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line">    <span class="comment"># 2. 设置Java环境</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">11</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="number">11</span></span><br><span class="line">    <span class="comment"># 3. 设置gradlew执行权限</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">    <span class="comment"># 4. 缓存构建缓存</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">Gradle</span> <span class="string">packages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          ~/.gradle/caches</span></span><br><span class="line"><span class="string">          ~/.gradle/wrapper</span></span><br><span class="line"><span class="string"></span>        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-gradle-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/*.gradle*&#x27;,</span> <span class="string">&#x27;**/gradle-wrapper.properties&#x27;</span><span class="string">)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $&#123;&#123; runner.os &#125;&#125;-gradle-</span></span><br><span class="line"><span class="string"></span>    <span class="comment"># 5. 项目构建</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">build</span> <span class="string">-x</span> <span class="string">test</span></span><br><span class="line">    <span class="comment"># 6. 部署到服务器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">file</span> <span class="string">via</span> <span class="string">scp</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">appleboy/scp-action@master</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">USERNAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">PORT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSHKEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;build/libs/dockerhub-1.0.1.jar&quot;</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">&quot;/opt/dockerhub-1.0.1/temp&quot;</span></span><br><span class="line">    <span class="comment"># 7. 重启服务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span> <span class="comment"># 使用ssh链接服务器</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSHKEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mv /opt/dockerhub-1.0.1/temp/build/libs/dockerhub-1.0.1.jar /opt/dockerhub-1.0.1/lib/</span></span><br><span class="line"><span class="string">          rm -rf /opt/dockerhub-1.0.1/temp</span></span><br><span class="line"><span class="string">          cd /opt/dockerhub-1.0.1/</span></span><br><span class="line"><span class="string">          jps |grep DockerHubService | awk &#x27;&#123;print $1&#125;&#x27; | xargs kill -9</span></span><br><span class="line"><span class="string">          nohup bin/dockerhub &gt; nohup.out 2&gt; nohup.err &lt; /dev/null &amp;</span></span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>要在项目根目录使用<code>gradlew</code>所以可以事先在本地环境中，尝试使用<code>gradlew</code>构建项目，保证配置没有错误，并且应将<code>gradlew</code>可执行脚本加入到git库中</li>
<li>使用<code>gradlew</code>配置项目时会在根目录生成<code>gradle/wrapper</code>目录，其中有<code>gradle-wrapper.jar</code>和<code>gradle-wrapper.properties</code>两个文件，要将此目录加入到git库中</li>
<li>将<code>gradle/wrapper/gradle-wrapper.properties</code>配置文件复制到项目根目录中，并加入到git库中，保证gradle配置生效</li>
<li>在第6、7步骤中，需要远程连接到指定的部署服务器，需要在GitHub项目界面中的<code>Settings</code>选项界面的<code>Secret</code>界面中点击<code>New repository secret</code>添加配置信息，名字就是yaml文件中使用的配置属性名</li>
<li>第6步骤中需要注意，会将source的目录结构复制到target指定的文件夹中，所以放到一个临时文件夹中</li>
<li>步骤7中，将目的jar包移动到目的目录。删除临时文件夹，重启服务，注意nohup指令，如果只是写作<code>nohup bin/dockerhub &amp;</code>，GitHub Actions的执行流程会卡顿在此处</li>
</ol>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端代码（Vue项目）提交后，自动打包并将新包部署到指定服务器</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>在项目根目录的<code>.github/workflows</code>目录下写如下文件<code>vue_build.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">VUE-CI</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">node</span> <span class="string">env</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Installing</span> <span class="string">project</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Building</span> <span class="string">the</span> <span class="string">project</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="comment"># 使用ssh链接服务器，清空旧的部署</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span> </span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSHKEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">port:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            rm -rf /opt/dvclab/</span></span><br><span class="line"><span class="string">            mkdir -p /opt/dvclab/</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 拷贝打包好的文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">file</span> <span class="string">via</span> <span class="string">scp</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/scp-action@master</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">USERNAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">PORT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSHKEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">source:</span> <span class="string">&quot;./dist/&quot;</span></span><br><span class="line">          <span class="attr">target:</span> <span class="string">&quot;/opt/dvclab/&quot;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/Jira-Confluence-%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/Jira-Confluence-%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">Jira & Confluence 部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:17:08 / Modified: 15:17:34" itemprop="dateCreated datePublished" datetime="2021-07-11T15:17:08+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Jira-amp-Confluence-服务部署"><a href="#Jira-amp-Confluence-服务部署" class="headerlink" title="Jira &amp; Confluence 服务部署"></a>Jira &amp; Confluence 服务部署</h1><h1 id="1-Jira安装配置"><a href="#1-Jira安装配置" class="headerlink" title="1.  Jira安装配置"></a>1.  Jira安装配置</h1><h2 id="1-1-Jira简介"><a href="#1-1-Jira简介" class="headerlink" title="1.1 Jira简介"></a>1.1 Jira简介</h2><p>JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域，其配置灵活、功能全面、部署简单、扩展丰富</p>
<h2 id="1-2-Jira破解镜像制作"><a href="#1-2-Jira破解镜像制作" class="headerlink" title="1.2 Jira破解镜像制作"></a>1.2 Jira破解镜像制作</h2><ul>
<li>破解crack来源：<a target="_blank" rel="noopener" href="https://gitee.com/pengzhile/atlassian-agent">Gitee atlassian-agent</a>，理论上可用于破解所有版本的Atlassian家几乎所有产品，但是只验证了特定的版本（Jira Docker Image 7.12.0）</li>
</ul>
<p>编写Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/jira</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">FROM cptactionhank/atlassian-jira-software:7.12.0</span></span><br><span class="line"><span class="string">USER root </span></span><br><span class="line"><span class="string">COPY &quot;atlassian-agent.jar&quot; /opt/atlassian/jira/ </span></span><br><span class="line"><span class="string">RUN echo &#x27;</span><span class="built_in">export</span> CATALINA_OPTS=<span class="string">&quot;-javaagent:/opt/atlassian/jira/atlassian-agent.jar <span class="variable">$&#123;CATALINA_OPTS&#125;</span>&quot;</span><span class="string">&#x27; &gt;&gt; /opt/atlassian/jira/bin/setenv.sh &#x27;</span> &gt; /opt/jira/Dockerfile</span><br></pre></td></tr></table></figure>

<p>下载<a target="_blank" rel="noopener" href="https://gitee.com/pengzhile/atlassian-agent/releases">atlassian-agent.jar</a>文件到Dockerfile同目录</p>
<p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t jira/jira:v7.12.0 .</span><br></pre></td></tr></table></figure>

<h2 id="1-3-配置MySQL数据库"><a href="#1-3-配置MySQL数据库" class="headerlink" title="1.3 配置MySQL数据库"></a>1.3 配置MySQL数据库</h2><p>准备MySQL配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">[client]</span></span><br><span class="line"><span class="string">default-character-set = utf8</span></span><br><span class="line"><span class="string">[mysql]</span></span><br><span class="line"><span class="string">default-character-set = utf8</span></span><br><span class="line"><span class="string">[mysqld]</span></span><br><span class="line"><span class="string">character-set-server=utf8</span></span><br><span class="line"><span class="string">innodb_log_file_size=3G</span></span><br><span class="line"><span class="string">character_set_server = utf8mb4</span></span><br><span class="line"><span class="string">innodb_default_row_format=DYNAMIC</span></span><br><span class="line"><span class="string">innodb_large_prefix=ON</span></span><br><span class="line"><span class="string">#innodb_file_format=Barracud</span></span><br><span class="line"><span class="string">default-storage-engine=INNODB &#x27;</span> &gt; /opt/jira/my.cnf </span><br></pre></td></tr></table></figure>

<p>启动MySQL容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \ </span><br><span class="line">--name mysqlForJira \ </span><br><span class="line">--restart always \ </span><br><span class="line">-p <span class="variable">$&#123;port&#125;</span>:3306 \ </span><br><span class="line">-v /opt/jira/mysql/:/var/lib/mysql \ </span><br><span class="line">-v /opt/jira/my.cnf:/etc/mysql/my.cnf \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="variable">$&#123;password&#125;</span> \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>创建表和用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database jira character set &#x27;UTF8&#x27;;</span><br><span class="line">create user jira identified by &#x27;jira&#x27;;</span><br><span class="line">grant all privileges on `jira`.* to &#x27;jira&#x27;@&#x27;172.%&#x27; identified by &#x27;jira&#x27; with grant option;</span><br><span class="line">grant all privileges on `jira`.* to &#x27;jira&#x27;@&#x27;localhost&#x27; identified by &#x27;jira&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Jira容器生成"><a href="#1-4-Jira容器生成" class="headerlink" title="1.4 Jira容器生成"></a>1.4 Jira容器生成</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name jira \</span><br><span class="line">--restart always \</span><br><span class="line">--link mysqlForJira:mysql \</span><br><span class="line">--link confluence:confluence \</span><br><span class="line">-p <span class="variable">$&#123;port&#125;</span>:8080 \</span><br><span class="line">-v /opt/jira/var/:/var/atlassian/jira \</span><br><span class="line">-v /opt/jira/opt:/opt/atlassian/jira \</span><br><span class="line">-d jira/jira:v7.12.0</span><br></pre></td></tr></table></figure>

<h2 id="1-5-Jira破解配置"><a href="#1-5-Jira破解配置" class="headerlink" title="1.5 Jira破解配置"></a>1.5 Jira破解配置</h2><p>访问<a href="about:blank">http://127.0.0.1:${port</a>}，进入Jira setup wizard ,进行初始化配置</p>
<ul>
<li>手动设置项目</li>
<li>选择配置独立数据库</li>
</ul>
<p>制定许可证关键字：</p>
<ul>
<li>复制<strong>服务器ID</strong></li>
<li>在本地存放atlassian-agent.jar目录下执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar atlassian-agent.jar -d -m <span class="variable">$&#123;email&#125;</span> -n <span class="variable">$&#123;company_name&#125;</span> -p jira -o <span class="variable">$&#123;jira_url&#125;</span> -s <span class="variable">$&#123;服务器ID&#125;</span></span><br></pre></td></tr></table></figure>

<p>将生成的许可证复制到页面，完成破解</p>
<h1 id="2-Confluence安装配置"><a href="#2-Confluence安装配置" class="headerlink" title="2 Confluence安装配置"></a>2 Confluence安装配置</h1><h2 id="2-1-Confluence简介"><a href="#2-1-Confluence简介" class="headerlink" title="2.1 Confluence简介"></a>2.1 Confluence简介</h2><p>Confluence是一个专业的企业知识管理与协同软件，也可以用于构建企业wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送。</p>
<h2 id="2-2-Confluence破解镜像制作"><a href="#2-2-Confluence破解镜像制作" class="headerlink" title="2.2 Confluence破解镜像制作"></a>2.2 Confluence破解镜像制作</h2><ul>
<li>破解crack来源：<a target="_blank" rel="noopener" href="https://gitee.com/pengzhile/atlassian-agent">Gitee atlassian-agent</a>，理论上可用于破解所有版本的Atlassian家几乎所有产品，但是只验证了特定的版（Confluence Docker Image 6.13.0）</li>
</ul>
<p>编写Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/confluence</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;FROM cptactionhank/atlassian-confluence:6.13.0</span></span><br><span class="line"><span class="string">USER root</span></span><br><span class="line"><span class="string">COPY &quot;atlassian-agent.jar&quot; /opt/atlassian/confluence/</span></span><br><span class="line"><span class="string">RUN echo &#x27;</span><span class="built_in">export</span> CATALINA_OPTS=<span class="string">&quot;-javaagent:/opt/atlassian/confluence/atlassian-agent.jar <span class="variable">$&#123;CATALINA_OPTS&#125;</span>&quot;</span><span class="string">&#x27; &gt;&gt; /opt/atlassian/confluence/bin/setenv.sh&#x27;</span> &gt;&gt; /opt/confluence/Dockerfile</span><br></pre></td></tr></table></figure>

<p>下载<a target="_blank" rel="noopener" href="https://gitee.com/pengzhile/atlassian-agent/releases">atlassian-agent.jar</a>文件到Dockerfile同目录</p>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t confluence/confluence:6.13.0 .</span><br></pre></td></tr></table></figure>

<h2 id="2-3-配置MySQL数据库"><a href="#2-3-配置MySQL数据库" class="headerlink" title="2.3 配置MySQL数据库"></a>2.3 配置MySQL数据库</h2><p>准备MySQL配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/confluence/mysqlecho <span class="string">&#x27;[client]default-character-set =utf8[mysql]default-character-set =utf8[mysqld]character_set_server =utf8collation-server=utf8_binmax_allowed_packet=256Minnodb_log_file_size=256Mdefault-storage-engine=INNODBtransaction-isolation=READ-COMMITTEDbinlog_format=row &#x27;</span> &gt; /opt/confluence/my.cnf </span><br></pre></td></tr></table></figure>

<p> 启动MySQL容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run \--name mysqlForConfluence \--restart always \-p <span class="variable">$&#123;port&#125;</span>:3306 \-v /opt/confluence/mysql/:/var/lib/mysql \-v /opt/confluence/my.cnf:/etc/mysql/my.cnf \-e MYSQL_ROOT_PASSWORD=<span class="variable">$&#123;password&#125;</span> \-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>创建表和用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database confluence character set &#x27;UTF8&#x27;;create user confluence identified by &#x27;confluence&#x27;;grant all privileges on `confluence`.* to &#x27;confluence&#x27;@&#x27;%&#x27; identified by &#x27;confluence&#x27; with grant option;grant all privileges on `confluence`.* to &#x27;confluence&#x27;@&#x27;localhost&#x27; identified by &#x27;confluence&#x27; with grant option;flush privileges;alter database confluence character set utf8 collate utf8_bin;set global tx_isolation=&#x27;READ-COMMITTED&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Confluence容器生成"><a href="#2-4-Confluence容器生成" class="headerlink" title="2.4 Confluence容器生成"></a>2.4 Confluence容器生成</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name confluence \--restart always \--link mysqlForConfluence:mysql \--link jira:jira \-p <span class="variable">$&#123;port&#125;</span>:8090 \-v /opt/confluence/data/:/home/confluence_data \-v /opt/confluence/opt/:/opt/atlassian/confluence \-v /opt/confluence/var/:/var/atlassian/confluence \-d confluence/confluence:6.13.0</span><br></pre></td></tr></table></figure>

<h2 id="2-5-Confluence破解配置"><a href="#2-5-Confluence破解配置" class="headerlink" title="2.5 Confluence破解配置"></a>2.5 Confluence破解配置</h2><p>访问<a href="about:blank">http://127.0.0.1:${port</a>}，进入Jira setup wizard ,进行初始化配置</p>
<ul>
<li>手动设置项目</li>
<li>选择配置独立数据库</li>
</ul>
<p>制定许可证关键字：</p>
<ul>
<li>复制服务器ID</li>
<li>在本地存放atlassian-agent.jar目录下执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar atlassian-agent.jar -d -m <span class="variable">$&#123;email&#125;</span> -n <span class="variable">$&#123;company_name&#125;</span> -p conf -o <span class="variable">$&#123;jira_url&#125;</span> -s <span class="variable">$&#123;服务器ID&#125;</span></span><br></pre></td></tr></table></figure>

<p>将生成的许可证复制到页面，完成破解</p>
<h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.atlassian.com/software/jira/guides/use-cases/what-is-jira-used-for">What is Jira used for?</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/wuweixiang/blog/3014644">通过Docker安装破解版Jira与Confluence</a></li>
<li>[Docker安装破解版Jira与Confluence](</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/k8s%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/k8s%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">k8s学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:15:01 / Modified: 15:15:41" itemprop="dateCreated datePublished" datetime="2021-07-11T15:15:01+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h2><ul>
<li><p>下边罗列对于k8s的各种描述:</p>
<ul>
<li>Kubernetes 是一款基础设施工具，可对多种不同计算资源（例如虚拟 / 物理机）进行分组，使其呈现为统一的巨量计算资源，从而供应用程序使用或与其他人共享</li>
<li>Kubernetes 是一个<strong>开源容器编排引擎</strong>，用于自动化容器化应用程序的部署、扩展和管理。<strong>Pod 是 kubernetes 应用程序的基本构建模块</strong>。Kubernetes 管理着 Pod，Pod 封装着容器。一个 Pod 可能包含一个或多个容器、存储、IP 地址，并控制着容器运行。</li>
<li>k8s的特点：<ul>
<li>可移植:  支持公有云、私有云、混合云、多重云（multi-cloud）。</li>
<li>可扩展:  模块化,、插件化、可挂载、可组合。</li>
<li>自动化:  自动部署、自动重启、自动复制、自动伸缩/扩展。</li>
</ul>
</li>
</ul>
</li>
<li><p>k8s中各个组件的概念</p>
<ul>
<li><p>Master（主节点）： 控制 Kubernetes 节点的机器，也是创建作业任务的地方。</p>
<ul>
<li>规划、监控 Pod</li>
<li>向集群加入新的Node</li>
<li>在master节点，必须有以下4个进程运行：<ul>
<li>api server，kubectl、dashboard等k8s客户端通过api server操作k8s集群，获取集群状态信息等<ul>
<li><strong>提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</strong><ul>
<li>kubelet进程需要在api server中注册</li>
</ul>
</li>
<li><strong>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</strong></li>
</ul>
</li>
<li>Scheduler 调度器，调度Pod的部署位置，实际上客户端对api server的创建Pod的请求会交付给调度器执行调度<ul>
<li><strong>负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</strong></li>
<li>**mention：调度器只是进行安排调度，真正执行Pod创建的是Node节点的Kubelet进程 **</li>
<li><strong>kube-scheduler 负责分配调度 Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配 Node 的 Pod，然后根据调度策略为这些 Pod 分配节点（更新 Pod的 NodeName 字段）。</strong></li>
</ul>
</li>
<li>Controller Manager 用于进行Pod的状态监测<ul>
<li><strong>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</strong><ul>
<li>检测集群的状态变化，比如有Pod 崩掉了，Controller Manager请求Scheduler重新调度，随后Scheduler请求对应Node的Kubelet执行Pod的创建动作</li>
</ul>
</li>
<li>Controller Manager由kube-controller-manager和cloud-controller-manager组成，是Kubernetes的大脑，它通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。</li>
</ul>
</li>
<li>etcd<ul>
<li><strong>基于Go语言实现的键值对类型的数据库，用来存储集群状态信息</strong></li>
<li>Scheduler与Controller Manager都依赖于etcd中存储的集群状态信息</li>
<li><strong>Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）</strong><ul>
<li>基本的key-value存储</li>
<li>监听机制</li>
<li>key的过期及续约机制，用于监控和服务发现</li>
<li>原子CAS和CAD，用于分布式锁和leader选举</li>
</ul>
</li>
<li>etcd的特点如下：<ul>
<li><strong>简单：</strong>支持 REST 风格的 HTTP+JSON API，既然etcd自己有开放的API，为什么系统其他组件还需要听过api server才能与etcd联系呢</li>
<li><strong>安全：</strong>支持 HTTPS 方式的访问</li>
<li><strong>快速：</strong>支持并发 1k/s 的写操作</li>
<li><strong>可靠：</strong>支持分布式结构，基于 Raft 的一致性算法，<strong>Raft 是一套通过选举主节点来实现分布式系统一致性的算法</strong>。</li>
</ul>
</li>
<li>补充etcd的可能使用场景（未必是在k8s中的使用场景，可以是etcd在任何一个分布式系统中的的使用场景）<ul>
<li><strong>服务发现(Service Discovery)：</strong>服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，<strong>服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接，也可以大概的理解为是一个查询etcd数据库的过程</strong>。</li>
<li><strong>消息发布与订阅：</strong>在分布式系统中，<strong>最适用的一种组件间通信方式就是消息发布与订阅</strong>。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。<strong>通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到etcd上进行集中管理（k8s中使用的是ConfigMap组件）</strong>。</li>
<li><strong>负载均衡：</strong>在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。<strong>etcd本身分布式架构存储的信息访问支持负载均衡</strong>。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，<strong>把数据量小但是访问频繁的消息数据直接存储到etcd中也可以实现负载均衡的效果</strong>。</li>
<li><strong>分布式通知与协调：****与消息发布和订阅类似，都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。</strong></li>
<li><strong>分布式锁：</strong>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，<strong>所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</strong></li>
<li>集群监控与Leader竞选：通过etcd来进行监控实现起来非常简单并且实时性强。</li>
</ul>
</li>
</ul>
</li>
<li>Master节点是整个集群的大脑，因此一般会有多个Master节点，此时api server同样具有负载均衡的作用，<strong>并且etcd也是在多个Master节点分布式存储的形式</strong></li>
<li><strong>Kubernetes Master接受使用YAML定义的配置文件，根据配置文件中相关信息将容器分配到其中一个Node上</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Node（节点）： 这些机器在 Kubernetes 主节点的控制下执行被分配的任务。可以是实体服务器或者是虚拟机</p>
<ul>
<li>作为真正干活的，Node节点所在的系统应该有如下三个进程运行<br>：<ul>
<li>容器运行时环境，可以是Docker或者其他容器环境，比如containerd</li>
<li>Kubelet，默认监听 10250 端口，接收并执行 master 发来的指令，管理Pod及 Pod 中的容器， <strong>这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行。</strong><ul>
<li><strong>负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理,是一个后台的守护进程,相当于MySQLd；</strong></li>
<li><strong>每个 kubelet 进程会在 API Server 上注册节点自身信息</strong>，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor 监控节点和容器的资源。</li>
</ul>
</li>
<li>kube proxy 用于智能转发集群中的流量<ul>
<li><strong>负责为 Service 提供 cluster 内部的服务发现和负载均衡</strong></li>
<li><strong>每台机器上都运行一个 kube-proxy 服务，它监听 API server 中 service 和 endpoint 的变化情况，并通过 iptables 等来为服务配置负载均衡（仅支持 TCP 和 UDP）。</strong></li>
<li>kube-proxy 可以直接运行在物理机上，也可以以 static pod 或者 daemonset 的方式运行。</li>
<li>Kube-proxy通过管理iptables等方式使得pod到pod之间，和pod到node之间网络能够互通。<strong>实质上在跨主机的pod之间网络也能够互通</strong>。</li>
<li>kube-proxy支持以下三种代理模式：<ul>
<li>Userspace</li>
<li>iptables</li>
<li>IPVS</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Pod： <strong>由一个或多个容器构成的集合（对于容器的抽象封装），作为一个整体被部署到一个单一节点。同一个 pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷。</strong></p>
<ul>
<li>因为Pod的引入也使得k8s替换docker后，可以较为方便的迁移到其他容器技术栈比如containerd</li>
<li>一个Pod内包含一个或多个完成相同功能的容器，比如数据库应用，后端处理应用等等</li>
<li>Pod重新创建时其IP会改变，因此使用Pod IP进行沟通是不合适的，故引入<strong>Service组件</strong></li>
<li><strong>如果多个容器运行在一个POD中，就相当于这些容器运行在同一台主机中，需要注意端口占用问题。</strong></li>
<li>在与 Docker 结合使用时，一个 pod 中可以包含一个或多个 Docker 容器。<strong>但除了有紧密耦合的情况下，通常一个 pod 中只有一个容器，这样方便不同的服务各自独立地扩展</strong>。</li>
</ul>
</li>
<li><p><strong>Replication controller（复制控制器）： 控制一个 pod 在集群上运行的实例数量</strong>。</p>
</li>
<li><p>Service（服务）： 将服务内容与具体的 pod 分离。<strong>Kubernetes 服务代理负责自动将服务请求分发到正确的 Pod 处，不管 pod 移动到集群中的什么位置，甚至可以被替换掉</strong>。</p>
<ul>
<li>service具有固定IP，因此各个Pod之间的联系，可以通过Service层架进行联系，不必担心Pod的重建导致IP变更</li>
<li>当Pod有多份时，Service可以充当Pod之间的load balancer</li>
<li><strong>Endpoint</strong>是Service下的一个组件，当Service部署时，会自动创建一个与之同名的Endpoint组件，k8s使用此组件跟踪对应的Service，记录哪一个Pod是Service对应的成员（endpoints）</li>
</ul>
</li>
<li><p>Ingress 做请求转发到特定的Service，相当于是一个网关或者是前端路由，管理进出集群中的路由，可以对外提供基于特定服务域名的安全协议服务。</p>
</li>
<li><p>ConfigMap 将服务配置抽离于服务本身，之前的服务配置往往写在服务本身所在容器之中，但是一旦对应的服务的服务名称有改动，那么使用此服务的所有其他服务的容器都需要更新，需要经历镜像更新-》容器更新一系列的复杂过程，因此需要将服务配置抽离出来，可以进行灵活配置，比如数据库的url，数据库用户名等等</p>
</li>
<li><p>Secret：前边的ConfigMap可以用来存储应用配置，但是不应将秘钥，用户密码等信息存在那里，专门用来存储秘钥的组件为Secret</p>
<ul>
<li><strong>存储的内容必须实现经过base64编码</strong></li>
<li>内容加密并不是默认配置开启的，需要使用环境变量或者配置文件手手动配置开启</li>
</ul>
</li>
<li><p>Volume 与Docker中的volume一样，用来执行Pod的数据持久化</p>
<ul>
<li>可以是Pod所在的宿主机的磁盘，也可以是远程存储服务</li>
<li><strong>mention：k8s并不管理数据持久化的工作，需要自己维护数据持久化的正常工作</strong></li>
</ul>
</li>
<li><p>Deployment:</p>
<ul>
<li><p>replicaset：k8s中的Pod 可以进行复制，提高了扩展性，同时也避免Pod down掉或者更新时带来的服务不可用状态，提高可用性，replicateset用来管理Deployment下的Pod的replica个数</p>
<ul>
<li>replica有多多少份是通过Deployment配置的，相当于是Pod分布的blueprint，通过创建对应的Deployment来实现扩容与缩容</li>
<li>与Pod一样，replicateset不需要单独设置，直接通过Deployment配置即可</li>
</ul>
</li>
<li><p>综上Deployment是基于Pod之上的抽象层，<strong>直接操作Deployment而不是Pod</strong></p>
</li>
<li><p><strong>对于无状态的Pod可以任意复制，因为只是提供无状态的服务，但是对于有数据持久化需求或者说是有状态的Pod而言不能使用Deployment去执行复制，比如一个简单的数据库Pod，如果执行了replicate，两个Pod同时访问一块存储，可能会导致数据冲突的问题</strong></p>
<ul>
<li>解决有状态Pod的复制问题的组件叫做StatefulSet</li>
</ul>
</li>
<li><p><strong>总的来说Deployment是客户端与k8s打交道的抽象层，Deployment之下的所有抽象均由k8s管理</strong></p>
<img src="http://images.demoli.xyz/20201220202255.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>StatefulSet 有状态的Pod的创建，扩容，缩容使用StatefulSet，不过，<strong>最佳实践是把这种数据库应用放到k8s之外，只在k8s中部署无状态的应用</strong></p>
</li>
</ul>
</li>
<li><p>k8s支持插件机制，以下的几个是常用的插件</p>
<ul>
<li>kube-dns：负责为整个集群提供 DNS 服务</li>
<li>Ingress Controller：为服务提供外网入口</li>
<li>Heapster：提供资源监控</li>
<li>Dashboard：提供 GUI</li>
<li>Federation：提供跨可用区的集群</li>
<li>Fluentd-elasticsearch：提供集群日志采集、存储与查询</li>
</ul>
</li>
</ul>
<h2 id="k8s的部署"><a href="#k8s的部署" class="headerlink" title="k8s的部署"></a>k8s的部署</h2><ul>
<li>常见的Kubernetes部署方式有：<ul>
<li><strong>kubeadm：</strong>也是推荐的一种部署方式；</li>
<li><strong>二进制</strong></li>
<li><strong>minikube：</strong>在本地轻松运行一个单节点 Kubernetes 群集的工具。</li>
</ul>
</li>
</ul>
<h2 id="Minikube与Kubectl"><a href="#Minikube与Kubectl" class="headerlink" title="Minikube与Kubectl"></a>Minikube与Kubectl</h2><h3 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h3><ul>
<li>k8s的命令行配置工具</li>
<li>相当于是一个k8s的客户端，直接向master节点的api server请求服务</li>
</ul>
<h3 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h3><ul>
<li>相当于在一个节点中同时运行Master与Worker Node的进程,并且是通过Virtual Box或者其他虚拟化技术创建的虚拟机运行在物理机之上</li>
<li>通常用于测试或者是快速验证，而不是用作生产</li>
<li>总的来说就是一个单节点的k8s集群</li>
</ul>
<h4 id="在Mac上安装Minikube"><a href="#在Mac上安装Minikube" class="headerlink" title="在Mac上安装Minikube"></a>在Mac上安装Minikube</h4><ol>
<li><code>brew update</code></li>
<li><code>brew install hyperkit</code> 安装运行Minikube虚拟化引擎，不使用Virtual Box 而是hyperkit,因为其更轻量且性能更好</li>
<li><code>brew install minikube</code>，kubectl是其依赖项，所以不需要单独安装kubuectl了</li>
</ol>
<h4 id="创建并启动一个Minikube-单节点集群"><a href="#创建并启动一个Minikube-单节点集群" class="headerlink" title="创建并启动一个Minikube 单节点集群"></a>创建并启动一个Minikube 单节点集群</h4><ol>
<li><p><code>minikube start --vm-driver=hyperkit --registry-mirror $&#123;阿里云的镜像加速器地址&#125;</code>指定虚拟化引擎与Docker 镜像地址即可</p>
<ol>
<li><p>看起来就是使用Docker Machine创建了一个虚拟机，虚拟机中预装了 Docker Daemon</p>
</li>
<li><p>至此集群已经启动起来，可以使用kubectl发起请求了，Minikube 启动时会自动配置 kubectl，把它指向 Minikube 提供的 Kubernetes API 服务，可以使用下述命令确定</p>
<ol>
<li><code>kubectl config current-context</code></li>
</ol>
</li>
<li><p>如果你在第一次启动 Minikube 时遇到错误或被中断，后面重试仍然失败时，可以尝试运行 minikube delete 把集群删除，重新来过。</p>
<ol>
<li>经过实测，把电脑的DNS改为Google的DNS <code>8.8.8.8</code>即可，参考此<a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube/issues/9051">issue</a></li>
</ol>
</li>
<li><p>Minikube的作用就是启动或者删除一个k8s集群，具体的集群配置全部使用kubectl来完成</p>
</li>
<li><p>集群启动后，会自动创建一个Service，此Service配置文件如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-12-20T10:20:18Z&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">apiserver</span></span><br><span class="line">    <span class="attr">provider:</span> <span class="string">kubernetes</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;202&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">96540f7d-43cc-43f7-92e2-4be508285bbd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>推测此Service是服务于apiServer的Service，因为apiServer就默认监听在8443端口</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="使用kubectl发起请求"><a href="#使用kubectl发起请求" class="headerlink" title="使用kubectl发起请求"></a>使用kubectl发起请求</h4><h5 id="查看集群组件状态"><a href="#查看集群组件状态" class="headerlink" title="查看集群组件状态"></a>查看集群组件状态</h5><ul>
<li><code>kubectl get nodes</code> 获取nodes的状态，或者使用<code>minikube status</code>查看集群状态</li>
<li><code>kubectl version</code>查看k8s版本</li>
<li><code>kubectl get pods</code>查看Pod状态</li>
<li><code>kubectl get services</code>查看Service组件状态</li>
<li><code>kubectl get deployments</code> 查看Deployment的状态</li>
<li><code>kubectl get namespace</code> 查看命名空间状态</li>
<li><code>kubectl get all</code> 查看集群中的所有组件的状态信息</li>
<li>get指令可以设置<code>-o wide</code>参数可以显示更多信息，比如Pod的IP</li>
<li>get指令可以设置<code>-o yaml</code>参数可以获得更新后的yaml配置文件</li>
<li>get指令可以设置<code>--watch</code>参数可以动态更新状态</li>
<li><strong>get指令可以设置<code>-n</code>参数可以获取指定NS下的组件的状态，默认只获取default NS 下的资源</strong><ul>
<li>当某团队只被限制使用本团队的NS时，执行kubectl命令都得加上一个<code>-n $&#123;NS_name&#125;</code>比较麻烦，应当能设置当前环境下的默认NS，但是k8s没有提供支持，解决办法是：<ul>
<li>下载kubens工具<code>brew install kubectx</code></li>
<li><code>kubens</code>命令打印NS列表，并高亮当前NS</li>
<li><code>kubens $&#123;NS_name&#125;</code>切换到指定NS，此后执行kubectl不需要指定<code>-n</code>参数了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="创建集群组件"><a href="#创建集群组件" class="headerlink" title="创建集群组件"></a>创建集群组件</h5><ul>
<li>使用<code>kubectl create ...</code>相关的命令即可</li>
<li>首先是创建k8s的最基本单元–Pod，但是不要忘了Deployment是Pod之上的抽象封装，因此是创建Deployment而不是Pod</li>
<li><code>kubectl create deployment $&#123;deployment_name&#125; --image=$&#123;image_name&#125;</code><ul>
<li>在这里通过kubectl指定了创建Pod的blueprint，最基本的信息就是Depoyment的名字（Deployment对应的Pod的名字就是<code>$&#123;deployment_name&#125;-$&#123;replicateset_hash&#125;-$&#123;pod_hash&#125;</code>）和镜像名</li>
<li>其余配置都是默认的，当然也可以通过命令行配置，不过更好的方式是使用yaml配置文件进行声明</li>
<li><code>kubectl get replicasets</code> 查看Deployment下的replicate配置<ul>
<li>replicaset的名字是<code>$&#123;deployment_name&#125;-$&#123;replicateset_hash&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>使用kubectl直接编辑Deployment配置，会自动生成一份yaml格式的配置文件供编辑<ul>
<li><code>kubectl edit deployment $&#123;deployment_name&#125;</code></li>
<li>编辑保存之后，会自动执行更新</li>
</ul>
</li>
</ul>
<h5 id="Debugging-Pod"><a href="#Debugging-Pod" class="headerlink" title="Debugging Pod"></a>Debugging Pod</h5><ul>
<li><p>即获取Pod日志(实际上是获取Pod内的容器的日志)</p>
<ul>
<li><code>kubectl logs $&#123;pod_name&#125;</code></li>
</ul>
</li>
<li><p>如果要查看Pod内容器的状态</p>
<ul>
<li><p><code>kubectl describe pod $&#123;pod_name&#125;</code></p>
<p><img src="http://images.demoli.xyz/20201220183613.png"></p>
</li>
</ul>
</li>
<li><p>与原生Docker Command类似，使用kubectl也可以进入到Pod内部的容器命令行</p>
<ul>
<li><code>kubectl exec -it $&#123;pod_name&#125; -- /bin/bash</code></li>
<li>区别在于在command参数前这里多了<code>--</code></li>
</ul>
</li>
<li><p>下文介绍的配置文件中的statue节点的更新，也可以作为debug信息</p>
</li>
</ul>
<h5 id="删除Deployment与使用yaml配置文件声明Deployment"><a href="#删除Deployment与使用yaml配置文件声明Deployment" class="headerlink" title="删除Deployment与使用yaml配置文件声明Deployment"></a>删除Deployment与使用yaml配置文件声明Deployment</h5><ul>
<li><p>删除Deployment</p>
<ul>
<li><code>kubectl delete deployment $&#123;deployment_name&#125;</code></li>
<li>这里仅记录一个现象，Service并不依附于Pod存在，即便我删除了Deployment，Service并没有消除，实际上也可以说Service并不是Deployment之下的一个抽象层，而是一个单独的k8s组件</li>
</ul>
</li>
<li><p>使用yaml配置文件</p>
<ul>
<li><code>kubectl apply -f $&#123;yaml_file_path&#125;</code></li>
<li>如果需要改动，直接更改配置文件，再执行相同的命令即可</li>
<li>也可以通过制定配置文件来删除Deployment<ul>
<li><code>kubectl delete -f $&#123;yaml_file_path&#125;</code></li>
</ul>
</li>
<li>Deployment yaml配置文件案例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="comment"># 要部署的组件类型</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-depl</span></span><br><span class="line"><span class="comment"># deployment blueprint</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-depl</span></span><br><span class="line">  <span class="comment"># pod blueprint</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-depl</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Service yaml配置文件案例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">protoccol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="comment"># Service对其他Service暴露的端口是80</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="comment"># Service把请求转发到对应的Pod的port,对应的就是pod 配置中的containerPort</span></span><br><span class="line">        <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建Service后，可以使用<code>kubectl describe service nginx-service</code>查看Endpoints项目，是否有匹配的Pod，Pod IP 信息可用<code>kubectl get pod -o wide</code>查看</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="yaml配置文件详解"><a href="#yaml配置文件详解" class="headerlink" title="yaml配置文件详解"></a>yaml配置文件详解</h5><ul>
<li>事实上配置文件分为以下3部分：<ul>
<li>metadata<ul>
<li>要配置的组件（Deployment、Service etc）的元数据<ul>
<li>name：为此组件设置的名字</li>
<li>lables：此节点下可以是<strong>任意键值对</strong>，仅是用来匹配的，<del>Deployment的lables用来与Service的Selector进行匹配</del><ul>
<li><strong>需要注意的是：尽管Service与Deployment定义在不同的配置文件中，但是这个lable是全局的，意味着可以在其他配置文件中与此label进行匹配</strong></li>
<li><strong>Service中的selector与对应的Pod匹配</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>spec<ul>
<li>创建不同类型的组件对应的spec显然是不一样的<ul>
<li>对于常用的Deployment:<ul>
<li>replicas：replica的个数</li>
<li>selector：与lables一样用来联系组件，此处就是用来匹配Pod与Deployment<ul>
<li>matchLabels:<ul>
<li><strong>此节点下放置一个任意键值对，表示此Deployment匹配所有以这个键值对为lable的Pod</strong></li>
<li>需要注意的是如果此节点配置变更了，不能通过apply跟新配置，否则会有以下错误：<code>The Deployment &quot;nginx-depl&quot; is invalid: spec.selector: Invalid value: v1.LabelSelector&#123;MatchLabels:map[string]string&#123;&quot;app&quot;:&quot;nginx&quot;&#125;, MatchExpressions:[]v1.LabelSelectorRequirement(nil)&#125;: field is immutable</code>，应该删除后，重新创建才行</li>
</ul>
</li>
</ul>
</li>
<li>template：pod blueprint，用来具体设置Pod<ul>
<li>template的子结构与整个配置文件的结构类似<ul>
<li>metadata<ul>
<li>lables<ul>
<li>此节点下可以是<strong>任意键值对</strong>，仅是用来匹配的，上边案例中的是<code>app: nginx-depl</code></li>
</ul>
</li>
</ul>
</li>
<li>spec<ul>
<li>containers 列表结构<ul>
<li>image</li>
<li>name</li>
<li>ports 列表结构,与selector、lables一样用来联系组件<ul>
<li>containerPort</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>头部信息<ul>
<li>apiVersion<ul>
<li>不同的组件对应的apiVersion不一样，具体如何选择参考<a target="_blank" rel="noopener" href="https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-apiversion-definition-guide.html">此文章</a></li>
</ul>
</li>
<li>kind 要创建的组件的类型，比如：Service、Deployment、CronJob etc</li>
</ul>
</li>
<li>status<ul>
<li>此部分是不需要手动配置的，而是有k8s维护的</li>
<li>k8s会对spec部分声明的配置与实际的运行状况进行对比，并尝试使实际运行状况与生命的配置保持一致，这个也是k8s的self-healing特性的一部分，<strong>实际运行状况会被k8s持续维护在此status节点信息中</strong><ul>
<li>当然这种维护并不是直接写到我们自己的配置文件中,可以使用edit指令查看，但是不推荐，应该使用<code>kubectl get deployment $&#123;deployment_name&#125; -o yaml</code>来查看，如果要导出到文件中使用管道即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul>
<li><p>mongodb</p>
</li>
<li><p>mongo-express</p>
</li>
<li><p>展示典型的web应用的构建</p>
</li>
<li><p>基本的请求流程如下：</p>
<img src="http://images.demoli.xyz/20201220220313.png" style="zoom:67%;" />

<ul>
<li>mogodbURL存储在configMap中</li>
<li>mogodb的用户名密码存储在Secret中</li>
</ul>
</li>
</ul>
<ol>
<li><p>mongoDB相关</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongodb-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">mongo-root-username</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongodb-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">mongo-root-password</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yaml中的document隔离</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="comment"># 因为这里设置的同样是mongodb的默认端口，所以mongo-express中不用单独配置端口了</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">        <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="comment"># echo -n &#x27;username&#x27; | base64</span></span><br><span class="line">    <span class="attr">mongo-root-username:</span> <span class="string">dXNlcm5hbWU=</span></span><br><span class="line">    <span class="attr">mongo-root-password:</span> <span class="string">cGFzc3dvcmQ=</span></span><br></pre></td></tr></table></figure>



<ol>
<li>MongoDB Deployment</li>
<li>MongoDB Service</li>
<li>Secret</li>
<li>启动顺序很重要：因为Deployment中要引用Secret中的值，所以必须首先启动Secret，<strong>这种顺序要求，应该也能写在配置文件中，就像<code>docker compose</code>中一样</strong></li>
</ol>
</li>
<li><p>Mongo-express相关</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo-express</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-express-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongo-express</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongo-express</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mongo-express</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mongo-express</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8081</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ME_CONFIG_MONGODB_SERVER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongodb-configmap</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">database_url</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ME_CONFIG_MONGODB_ADMINUSERNAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongodb-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">mongo-root-username</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ME_CONFIG_MONGODB_ADMINPASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongodb-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">mongo-root-password</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yaml中的document隔离</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-express-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongo-express</span></span><br><span class="line">  <span class="comment"># 名字稍有歧义；通过给这个service一个external ip来让这个service可以接受集群外部请求</span></span><br><span class="line">  <span class="comment"># 默认的Service类型是CLuster IP 也就是Internal Service，可以不用指定</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">        <span class="attr">targetPort:</span> <span class="number">8081</span></span><br><span class="line">        <span class="comment"># extrnal ip的端口 必须在30000-32767之间</span></span><br><span class="line">        <span class="comment"># 本质上使用的是NodePort类型的Service</span></span><br><span class="line">        <span class="attr">nodePort:</span> <span class="number">30000</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="comment"># mogodb 的service name</span></span><br><span class="line">    <span class="attr">database_url:</span> <span class="string">mongo-service</span></span><br></pre></td></tr></table></figure>



<ol>
<li>Mongo-express Deployment</li>
<li>Mongo-express Service</li>
<li>configMap</li>
<li>启动顺序很重要：同理必须首先启动ConfigMap</li>
<li>在minikube中无法自动为service分配external ip，执行如下命令：<code>minikube service $&#123;Service_name&#125;</code><ol>
<li>执行此命令为Service分配一个external ip，并且自动打开浏览器访问对应Service external IP</li>
<li><strong>在实际的k8s集群中，此external ip应当是集群中该service运行所在节点的节点IP与节点的端口</strong><ol>
<li>这仅用于测试与快速部署，但是不能用于生产，生产环境下应该使用HTTS安全协议与域名，可以使用Ingress实现需求</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a>namespace 命名空间</h4><ul>
<li><p>namespace是一个用来组织k8s资源的逻辑分区，可以将其看作为k8s集群内部的小集群</p>
<img src="http://images.demoli.xyz/image-20201221083105953.png" alt="image-20201221083105953" style="zoom:80%;" /></li>
<li><p>当k8s集群创建后，默认创建4个namespace</p>
<ul>
<li><strong>default 用户自己创建的资源会被放置到此namespace中</strong></li>
<li>kube-node-lease  用来存储每一个node的心跳数据，这些心跳数据决定了这个node的可用性（是否存活）</li>
<li>kube-public  内部是可公共访问的资源，具体来说就是ConfigMap，其中存储了一些集群信息，不需要验证就可以访问其中的数据，可以使用<code>kubectl cluster-info</code>来访问到</li>
<li>kube-system 不要在此namespace中修改会添加资源，这个namespace中管理的是Master节点的一些进程和kubectl进程等等</li>
<li>kubernetes-dashboard 此namespace是由minikube创建，标准的k8s集群中不会默认创建</li>
</ul>
</li>
<li><p>除了这些默认的namespace之外，还可以创建自定义的命名空间，可以使用命令行<code>kubectl create namespace $&#123;namespace_name&#125;</code></p>
<ul>
<li><p><strong>只需要在其他资源，比如ConfigMap中的metadata节点中设置<code>namespace: $&#123;namespace_name&#125;</code>子节点，就可以将资源规划到对应namespace中</strong>或者是创建资源的使用指定NS：<code>kubectl apply -f configmap.yaml --namespace=my-namespace</code>，当然还是推荐第一种方法</p>
</li>
<li><p><strong>这里有一个小细节需要注意：当已经创建好一个default中的ConfigMap后，更改其配置文件将其配置到自定义的NS中，再执行apply后，之前的default中的ConfigMap不会被删除</strong></p>
</li>
</ul>
</li>
<li><p>namspace的意义，使用场景</p>
<ul>
<li><p>实际上就是为了从逻辑上组织k8s资源</p>
<ul>
<li><p>如果仅使用一个默认的namespace（或者说没有namespace这个概念）的话，当复杂系统创建的组件很多时，就变得难以管理</p>
<img src="http://images.demoli.xyz/image-20201221083452567.png" alt="image-20201221083452567" style="zoom:67%;" /></li>
<li><p>使用多个namespace进行业务逻辑划分，就变得更加容易管理</p>
<img src="http://images.demoli.xyz/image-20201221083618956.png" alt="image-20201221083618956" style="zoom:67%;" /></li>
<li><p>除了进行业务层面的划分，还可以进行人员组织上的逻辑划分，避免多个团队在集群中创建资源时发生冲突</p>
<ul>
<li>进一步的还可以进行namespace层面的访问控制，这意味着团队只能在自已的namespace中管理资源，而不能管理其他namespace的资源</li>
<li>再进一步，还可以设置namespace层面的资源配额管理</li>
</ul>
<img src="http://images.demoli.xyz/image-20201221083902926.png" alt="image-20201221083902926" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<p><img src="http://images.demoli.xyz/image-20201221083932782.png" alt="image-20201221083932782" style="zoom: 80%;" /><img src="http://images.demoli.xyz/image-20201221085147422.png" alt="image-20201221085147422"></p>
<p><img src="http://images.demoli.xyz/image-20201221085147422.png" alt="image-20201221085147422"></p>
<ul>
<li><p>可以在资源共享时使用namespace，比如要共享集群中的通用资源时，可以创建一个namespace来使用共享资源，而不用再创建另外一个集群去重复搭建相同的业务</p>
<img src="http://images.demoli.xyz/image-20201221084212305.png" alt="image-20201221084212305" style="zoom:67%;" />    </li>
<li><p>与上边的资源共享的例子类似的是，在集群中可以设置服务版本划分，比如当前服务版本与未来待发布版本，这些版本的服务都需要使用相同的共享服务，因此部署在一个集群中，用namespace划分即可</p>
<img src="http://images.demoli.xyz/image-20201221084816575.png" alt="image-20201221084816575" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>使用namespace中的一些注意事项</p>
<ul>
<li><p>当多个ns（A、B）想要使用共享的ns资源（比如数据库），A、B两个ns必须有自己独立的ConfigMap与Secret，不能一个ns（A）配置了这两个组件，另一个ns中（B）的Deployment从A中引用配置</p>
<img src="http://images.demoli.xyz/image-20201221090042209.png" alt="image-20201221090042209" style="zoom:80%;" />

<ul>
<li><p>前边说ConfigMap是不能跨NS引用的，事实上大部分NS的资源不能跨NS访问，但是Service组件是可以跨NS使用的，如下图所示，只要在引用时，指定Service所在的ns即可：${service_name}.${namespace_name}</p>
<img src="http://images.demoli.xyz/image-20201221090746389.png" alt="image-20201221090746389" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>并不是k8s中的所有资源都能被分配到NS中进行划分隔离,以下这些组件在k8s集群中是全局可访问的</p>
<ul>
<li>Volume</li>
<li>Node</li>
<li>etc</li>
<li>可以使用<code>kubectl api-resources --namespaced=false</code>进行查看</li>
</ul>
</li>
</ul>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><ul>
<li><p>前边demo所说，使用external service，可以向集群外部开放服务，生产环境下应该使用HTTS安全协议与域名，可以使用Ingress实现需求，external service可以退化为Internal service，由Ingress来接受外部请求与转发请求</p>
</li>
<li><p>Ingress配置文件实例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-express-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment"># 定制路由规则</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="comment"># 对于此host的请求会被转发到指定的backend中的serviceName:servicePort</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">mongo-express.com</span></span><br><span class="line">      <span class="comment"># 注意这里并不对应外界请求使用http或者https，而是对应ingress将请求转发到Internal Service用到的协议</span></span><br><span class="line">      <span class="attr">http:</span> </span><br><span class="line">        <span class="comment"># 定制URLpath</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">backend:</span> </span><br><span class="line">         <span class="attr">serviceName:</span> <span class="string">mongo-express-service</span></span><br><span class="line">         <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意host节点的域名应当是有效域名，并映射到集群中作为entrypoint的Node的IP（<strong>作为集群entrypoint的主机未必是集群中的Node也可以是集群外的某主机</strong>）</li>
</ul>
</li>
</ul>
<h5 id="Ingress配置与部署"><a href="#Ingress配置与部署" class="headerlink" title="Ingress配置与部署"></a>Ingress配置与部署</h5><ul>
<li><p>实际上Ingress的配置离不开另外一个组建的配合：Ingress Controller</p>
<ul>
<li>Ingress本身就像是一个接口，我们在这个接口中定义了规则，但是真正对请求进行规则匹配与流量转发的是Ingress Controller这个接口实现，IC是整个集群的entrypoint</li>
<li>Ingress Controller其实就是一个或多个特殊的Pod罢了</li>
<li>有许多Ingress Controller的第三方实现，可参考<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">官方网站</a></li>
</ul>
</li>
<li><p>对于实际部署中不同的服务器环境，也有不同的架构</p>
<ul>
<li><p>云服务厂商提供的服务器环境下：</p>
<img src="http://images.demoli.xyz/image-20201221134430442.png" alt="image-20201221134430442" style="zoom:80%;" /></li>
<li><p>Bear metal:</p>
<ul>
<li><img src="http://images.demoli.xyz/image-20201221134549715.png" alt="image-20201221134549715" style="zoom:80%;" /></li>
<li><p>需要自己提供entrypoint，并做好负载均衡，一般会使用一个集群外部的机器做代理服务器，可以软件代理服务器或者是硬件代理服务器</p>
<img src="http://images.demoli.xyz/image-20201221134808346.png" alt="image-20201221134808346" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>在minikube中部署Ingress是比较简单的</p>
<ol>
<li><p><code>minikube addons enable ingress</code>自动部署Ingress Controller 实现：Nginx Ingress Controller</p>
<ol>
<li>可在kube-system这个NS中查看pod会找到部署好的Ingress Controller</li>
<li>因为是第三方实现，其镜像仓库一般比较慢，可能出现<code> Exiting due to MK_ENABLE: run callbacks: running callbacks: [waiting for app.kubernetes.io/name=ingress-nginx pods: timed out waiting for the condition]</code>的异常，解决办法：<ol>
<li>可以使用上边的debug方法，首先检查下Pod状态（Ingress Controller就是一个Pod）<code>kubectl  get pod -A</code>，果然可以找到<code>kube-system            ingress-nginx-controller-558664778f-j6hs9   0/1     ImagePullBackOff</code>，再执行<code>kubectl describe pod ingress-nginx-controller-558664778f-j6hs9 --namespace=kube-system</code>找到其拉取的镜像名称，执行<code>minikube ssh</code>进入到minikube虚拟机手动执行镜像拉取 <code>docker pull ..</code></li>
<li>但是经过尝试可能image本身有错误，可以参考<a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube/issues/8756">issue</a>和<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904083992608776">掘金文章</a>来解决镜像不能下载的问题</li>
</ol>
</li>
</ol>
</li>
<li><p>初步尝试使用Ingress配置一个可以访问kubernetes-dashboard的路由（此dashborad服务是minikube自动配置的，你可以在这个同名的NS中找到其部署的Pod与Service，但是不能在集群外部访问，所以需要使用Ingress配置规则）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata:  name: dashboard-ingress  namespace: kubernetes-dashboardspec:    rules:    - host: dashboard.com      http:         paths:        - backend:</span>            <span class="comment"># 注意向后缩进           serviceName: kubernetes-dashboard           servicePort: 80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用apply进行部署后，会自动在集群内部为此域名分配对应解析的IP（因此可以推测出k8s内部应该有一个DNS系统维护），稍等片刻就能在ingress的info信息中出现，在本地将此解析加入（<code>/etc/hosts</code>）就能在浏览器中访问dashboard了</li>
<li><strong>补充一个异常信息：<code>error converting YAML to JSON: yaml: line 11: did not find expected key</code>这表示yaml文件的格式出现问题，最有可能出现的就是在map类型的节点没有向后添加空格，比如上述backend节点中的键值对是否向后缩进了</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>Default backend</p>
<ul>
<li><p>顾名思义，这个backend的意思就是<strong>对于任何不匹配rule的请求会被重定向到这个Service中</strong>，可以通过<code>kubectl describe ingress dashboard-ingress -n kubernetes-dashboard</code>查看</p>
</li>
<li><p>可以使用这个Service来配置定制化的错误界面等等</p>
</li>
<li><p>默认情况下，集群中没有此Service，需要自己创建，并创建对应的Pod处理请求即可</p>
<img src="http://images.demoli.xyz/image-20201221151117686.png" alt="image-20201221151117686" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>更多使用案例：</p>
<ul>
<li><p>Ingress在实际使用中肯定会指定更为复杂的rule，但是总的来说有以下两种</p>
<ul>
<li><p>path 区分</p>
<img src="http://images.demoli.xyz/image-20201221151753679.png" alt="image-20201221151753679" style="zoom:80%;" /></li>
<li><p>subdomian区分</p>
<img src="http://images.demoli.xyz/image-20201221151831171.png" alt="image-20201221151831171" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>配置HTTPS</p>
<ul>
<li><p>需要用到secret组件来存储证书</p>
<img src="http://images.demoli.xyz/image-20201221152022214.png" alt="image-20201221152022214" style="zoom:80%;" />

<ul>
<li>需要注意的是，Secret中数据的key必须是<code>tls.crt</code>与<code>tls.key</code>，不能修改为其他名字</li>
<li><strong>Secret与Ingress必须处于同一NS 否则Ingress无法访问到Secret</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h4><ul>
<li><p>helm是k8s中的包管理器</p>
<ul>
<li>所谓的包就是可以将集群中的多个yaml文件进行打包，并可以发布到公开的或私有的仓库中</li>
</ul>
</li>
<li><p>使用场景，为什么在k8s中需要包管理器</p>
<ul>
<li>比方说要在自己的k8s集群中使用ES stack(ES、kibana、logstash)，需要自己查询并手动创建相当多的组件才能运行起来，并且容易出错，因此可以将整个服务打包共享供他人使用，自己也可以方便的拿到打好的包部署运行</li>
<li>开发环境集群中开发好的微服务应用要部署到测试环境或生产环境中，可以直接打包好，并一键部署</li>
</ul>
</li>
<li><p>打好的包就叫做<code>Helm Charts</code></p>
</li>
<li><p>使用<code>helm search $&#123;keyword&#125;</code>来查询可用的包，或者去<a target="_blank" rel="noopener" href="https://artifacthub.io/">helm hub</a>搜索</p>
</li>
<li><p>Helm还有一个重要的特征就是其<strong>模板引擎</strong>的功能</p>
<ul>
<li><p>集群中的多个微服务的Yaml配置文件是十分相似的，只有在关键的一些配置上不同，为了减少配置的荣誉，可以使用Helm定义一个common blueprint，在关键的可替换节点处使用占位符标志，可以为占位符绑定动态的值（模板引擎）</p>
<img src="http://images.demoli.xyz/image-20201221161356116.png" alt="image-20201221161356116" style="zoom:80%;" />

<ul>
<li>动态值的来源是外部的一个yaml文件<ul>
<li>模板文件中的<code>.Values</code>不是与values.yaml的文件名匹配的，固定如此，values文件也有自己固定的位置，并且可以被覆盖，下边有介绍</li>
<li>除了从外部的yaml文件获取配置之外，还可以从<code>--set</code>参数中配置value</li>
</ul>
</li>
</ul>
</li>
<li><p>模板引擎的功能在 CI CD中是很有用的，可以在流程中更改value即可</p>
</li>
</ul>
</li>
<li><p>Helm chart打包的结构</p>
<ul>
<li>${Helm_Chart_Name}文件夹，chart的名字<ul>
<li>Chart.yaml chart的元信息，包括name version dependencoes等等</li>
<li>values.yaml 前边所说的template文件中的占位符的填充值存储在此文件中，此文件是chart中的默认的value文件，可以使用多种方式对其覆盖<ul>
<li><code>helm install --values=my-value.yaml $&#123;Helm_Chart_Name&#125;</code></li>
<li>`helm install –set version=2.0.0 ${Helm_Chart_Name}``</li>
</ul>
</li>
<li>charts 文件夹，内部包含chart的依赖，也就是当前chart依赖的其他chart会被存储在此文件夹下</li>
<li>templates文件夹，内部包含模板文件</li>
<li>README</li>
<li>license</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p>Helm中的Release Management</p>
<ul>
<li>主要是Helm的两个大版本的区分<ul>
<li>2<ul>
<li>Client( helm cli)</li>
<li>Server （Tiller）（运行在某k8s 集群中）<ul>
<li>会记录每一次chart的执行部署，并自动生成版本以进行版本维护<ul>
<li>因此可以执行版本升级以及回滚<ul>
<li><code>helm upgrade $&#123;Helm_Chart_Name&#125;</code></li>
<li><code>helm rollback $&#123;Helm_Chart_Name&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>每一次新的执行部署都会直接在原有的部署上更改，而不是产生一个新的</li>
<li><img src="http://images.demoli.xyz/image-20201221165911286.png" alt="image-20201221165911286" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li>3<ul>
<li><strong>显然Tiller作为集群的一部分拥有者很高的权限，会带来安全问题，因此在版本3中，Tiller就没了</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Helm Chart部署服务</p>
<ul>
<li><code>helm install $&#123;Helm_Chart_Name&#125;</code></li>
</ul>
</li>
</ul>
<h4 id="Volumes组件"><a href="#Volumes组件" class="headerlink" title="Volumes组件"></a>Volumes组件</h4><ul>
<li><p>k8s默认并未开启对于Pod的数据持久化，也就是说Pod每次重新创建都会导致其中数据的丢失，持久化存储应该不依赖于Pod的生命周期 </p>
</li>
<li><p>持久化存储必须在所有节点都是可用的，因为Pod可能被部署在任意一个节点上</p>
</li>
<li><p>持久化存储需要高可用，即便集群crash也可以恢复</p>
</li>
<li><p><strong>mention: volume组件不属于任何NS，是集群全局可访问的</strong></p>
</li>
<li><p>在k8s中集群数据持久化使用此组件，存储形式有以下三种：</p>
<ul>
<li><p>Persistent Volume</p>
<ul>
<li>可以将PV视为集群的资源，如果CPU RAM一样，因此在集群创建之处，在其他组件创建之前就应该已经创建好<ul>
<li><strong>补充：</strong><ul>
<li>在k8s中有两种用户角色：<ul>
<li>k8s系统管理员：<ul>
<li>创建并维护集群</li>
<li>保证集群资源足够可用（因此管理员负责获得可用的存储资源，并配置好volume）</li>
</ul>
</li>
<li>k8s系统使用者<ul>
<li>在集群中创建部署应用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同样使用Yaml创建部署</li>
<li>PV 支持存储层的一个抽象，真正的存储需要有实际的集群中的物理磁盘，或者集群外的nfs Server或者云存储服务（可以在配置文件中配置）<ul>
<li>k8s只提供PV这样的抽象服务，但是真正用什么存储以及存储过程需要自己管理，包括维护存储的可用性等等</li>
<li>可以把此Volume视为集群的一个插件</li>
<li>nfsServer:<img src="http://images.demoli.xyz/image-20201221183600917.png" alt="image-20201221183600917" style="zoom:80%;" /></li>
<li>Google Cloud: <img src="http://images.demoli.xyz/image-20201221183954543.png" alt="image-20201221183954543"></li>
<li>localStorage: <img src="http://images.demoli.xyz/image-20201221184015654.png" alt="image-20201221184015654"><ul>
<li><strong>对于数据库的持久化应该使用remote storage因为localStorage是绑定在某个特定节点的，不能保证每个节点都能访问使用，并且在集群崩溃后不能保证数据可用</strong></li>
</ul>
</li>
<li>除此之外，k8s还支持很多存储 </li>
</ul>
</li>
<li>场景举例： Pod应用要访问的数据文件夹或配置文件夹</li>
</ul>
</li>
<li><p>Persistent Volume Claim</p>
<ul>
<li><p>其作用于集群应用于PV之间，用来声明应用使用哪个PV</p>
</li>
<li><p>同样使用yaml文件进行配置</p>
</li>
<li><img src="http://images.demoli.xyz/image-20201221185904305.png" alt="image-20201221185904305" style="zoom:80%;" /></li>
<li><p>PVC声明了应用要使用何种类型的存储，并声明好访问方式，需求的容量等等，满足此声明要求的PV都可以成为这个应用实际上使用的PV</p>
</li>
<li><p>既然PVC声明了应用的需求，那么在Pod或者Deployment的配置中也要声明自己使用的指定的PVC</p>
</li>
<li><img src="http://images.demoli.xyz/image-20201221190606415.png" alt="image-20201221190606415" style="zoom:80%;" />

<ul>
<li>在Pod的配置文件中，volumes节点声明合适的PV会挂载到本Pod中，volumeMounts节点声明合适的PV挂载到Pod中的所有的或者部分容器的某文件系统位置处（name节点匹配对应的Volume_name）</li>
</ul>
</li>
<li><p>换句话说Pod通过PVC来请求PV，由PVC帮助Pod寻找符合声明的PV，并使得Volume可以访问PV</p>
<img src="http://images.demoli.xyz/image-20201221190940657.png" alt="image-20201221190940657" style="zoom:80%;" /></li>
<li><p><strong>mention: PVC必须和引用自己的Pod处于同一个NS中，否则不可跨NS引用</strong></p>
</li>
<li><p>之所以引入PVC这一层是有好处的：</p>
<ul>
<li>集群的使用者不用关心实际的存储是怎么提供的，只需要说明自己的需求，就足够了</li>
</ul>
</li>
</ul>
</li>
<li><p>Storage Class</p>
<ul>
<li><p>developer通过提出PVC，请求PV，这要求在developer的应用部署之前，system admin就要进行大量的存储实现配置，PV配置等等，比较繁琐，因此引入第三方的一个组件–Storage Class，动态的根据需求创建PV</p>
</li>
<li><p>使用yaml进行配置</p>
</li>
<li><p>因为SC执行对于PV的自动创建，所以PV中对于实际存储后台的配置一般都要同样在SC中配置好</p>
<img src="http://images.demoli.xyz/image-20201221193546876.png" alt="image-20201221193546876" style="zoom:80%;" />

<ul>
<li><p>通过指定provisioner节点来告诉k8s如何自动创建与指定的存储形式（nfs、Google Cloud etc）匹配的PV</p>
<ul>
<li>每一种存储形式都有其对应的provisioner节点的值，此值由k8s执行，以<code>kubernetes.io</code>开头</li>
<li>当然也有第三方的provisioner</li>
</ul>
</li>
<li><p>parameter节点声明了需要的PV的一些具体参数，比如文件系统类型等等，与PV 配置中的类似</p>
</li>
<li><p>SC相当于执行了PV的自动化构建，需求仍然是来自于PVC，因此还是在PVC中指定SC，使用<code>storageClassName</code>节点匹配即可</p>
<img src="http://images.demoli.xyz/image-20201221194449598.png" alt="image-20201221194449598" style="zoom:80%;" />

<ul>
<li>此过程就是PVC指定一个SC创建出匹配PVC要求的PV供Pod使用（主动的，自动的创建，而不是等待系统管理员事先准备好）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实际上与Volume类似的，ConfigMap与Secret都是存储相关的组件，但是这两个与Volume差别很大：</p>
<ul>
<li>使用本地存储</li>
<li>不是通过PV、PVC创建</li>
<li>由k8s管理，保证其可用性</li>
<li><strong>除了之前的案例中使用的ConfigMap、Secret的键值对的存储形式外，也可以将其挂载到Pod中</strong></li>
<li><img src="http://images.demoli.xyz/image-20201221192235053.png" alt="image-20201221192235053"></li>
</ul>
</li>
</ul>
</li>
<li><p>Pod可以同时使用多种类型的Volume</p>
<p><img src="http://images.demoli.xyz/image-20201221192552950.png" alt="image-20201221192552950"></p>
<p><img src="http://images.demoli.xyz/image-20201221192644059.png" alt="image-20201221192644059"></p>
</li>
</ul>
<h4 id="k8s-StatefulSet"><a href="#k8s-StatefulSet" class="headerlink" title="k8s StatefulSet"></a>k8s StatefulSet</h4><ul>
<li><p>与Deployment对立，针对有状态应用的的抽象管理（Pod管理，replicaset等等）</p>
</li>
<li><p>什么是有、无状态应用呢？</p>
<ul>
<li>有状态应用<ul>
<li>所有的数据库应用</li>
<li>需要记录数据以得到应用状态的应用</li>
</ul>
</li>
<li>无状态应用<ul>
<li>不记录应用状态</li>
<li>每一次提供服务都与之前的服务无关</li>
</ul>
</li>
</ul>
</li>
<li><p>Deployment与StatefulSet的区别</p>
<ul>
<li><p>使用Deployment部署stateless应用是很简单的，可以随意的创建删除、扩容缩容，因为这些Pod都是一模一样的</p>
</li>
<li><p>StateFulSet管理的stateful应用中的pod并不是完全一致的，因此并不能随意的创建与删除，实际上其Pod的都有自己特定的ID用以标识其身份，并且是不可更改的ID（**格式是：<code>$&#123;statefulset name&#125;-$&#123;从0开始的序号&#125;</code>**）（比如重新规划Pod之后，ID也不会更改）（Deployment中的Pod ID 就是任意的哈希值）</p>
<ul>
<li><p>StateFulSet管理的Pod并不是平等的，这是因为对于比如数据库这样的有状态应用来说，当有多个Pod时，不会允许这些Pod同时读或者写数据库，因为可能造成数据冲突，只会允许特定ID的Pod执行写操作，这个特定的Pod即为Master，其余的就是slaves </p>
</li>
<li><p>除了身份上的不同之外，这些Pod（以数据库应用为例）对应的存储层的PV也不会是同一个物理存储位置，也就是每一个Pod都有自己对应的数据存储位置（这里不仅存储实际上的业务数据，也存储着该Pod的身份信息等元信息，<strong>因此当一个Pod down掉重新创建后其ID不更改，对应的数据存储也能与之重新建立联系,同样的，建议使用remote Storage 而不是local storage，如果Pod重新创建在其他Node，将不能与之前的另外一个Node的数据重新建立联系</strong>），因此，需要不断地维持这些Pod对应的多个数据存储位置中的数据的一致性</p>
<img src="http://images.demoli.xyz/image-20201221203440229.png" alt="image-20201221203440229" style="zoom:80%;" />

<ul>
<li>实际上只有master对应的存储允许写操作，会发生状态更改，因此slave节点需要维持持续的同步操作，以保证状态更改后的下一次请求获得的是最新的数据</li>
</ul>
</li>
<li><p>新加入的Pod会clone前一个Pod（注意不是任一个，而是按照ID的前一个）的数据，随后维持更改同步</p>
</li>
<li><p>类似的在Pod创建时，后一个Pod的创建的前提是前一个Pod创建并运行成功，按照次序有条件的创建，<strong>序号为0的Pod一般是Master Pod</strong></p>
</li>
<li><p>类似的在Pod删除时，从序号的最后一个开始，后一个Pod完全停止运行后，才会轮到前一个</p>
</li>
<li><p>在Service层级，Service可以作为Statefulset中多个Pod的loadbalancer，但是与Deployment不同的是，每一个Pod都有一个单独的Dns Service提供域名解析服务，域名解析服务的名字的格式是<code>$&#123;pod name&#125;.$&#123;loadbalancer service name&#125;</code></p>
<img src="http://images.demoli.xyz/image-20201221205501875.png" alt="image-20201221205501875" style="zoom:80%;" />

<ul>
<li>这意味着当Pod重启后，IP会改变但是其名字和endpoint（可以理解为域名）不会变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以上的众多机制，都是为了维护Pod的状态</p>
</li>
<li><p><strong>但是机制是复杂的，k8s也没有提供足够完善的机制，比如数据同步等操作k8s是不负责的，所以有状态应用尽量变得无状态，实在不行还是部署在外部服务中，而不是k8s集群中</strong></p>
</li>
</ul>
<h4 id="k8s中的Service"><a href="#k8s中的Service" class="headerlink" title="k8s中的Service"></a>k8s中的Service</h4><ul>
<li><p>固定的静态IP，代替Pod为外界提供稳定的服务</p>
</li>
<li><p>对内，对多个Pod之间执行负载均衡操作</p>
</li>
<li><p>有以下4种类型的Service</p>
<ul>
<li><p>Cluster IP</p>
<ul>
<li><p>默认的Service类型</p>
</li>
<li><p>使用场景分析：</p>
<p><img src="http://images.demoli.xyz/image-20201221213343427.png" alt="image-20201221213343427"></p>
<ul>
<li><p>假设一个Pod有两个容器，部署在Node2</p>
</li>
<li><p>每一个Node都会在集群内部被分配到一个范围内的IP用于对内分配到Pod</p>
</li>
<li><p>在Service中注册的Pod称为Service的<code>endpoint</code></p>
</li>
<li><p>可以把此类型的Service，视为Internal Service</p>
<p><img src="http://images.demoli.xyz/image-20201221215502999.png" alt="image-20201221215502999"></p>
</li>
<li><p>Service配置案例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Servicemetadata:  name: mongo-servicespec:  selector:      app: mongodb  ports:      - name: mongodb        protocol: TCP        port: 27017        targetPort: 27017      - name: mongodb-exporter        protocol: TCP        port: 9216        targetPort:</span> <span class="number">9216</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>mention: 当作为endpoint的Pod中有多个容器并且都对外监听端口时，以为着Service也要开启多个端口进行监听转发</strong>，当设置多个端口的Service时，配置文件中应为Port分配对应的name属性，如果只有单端口开放的话，不需要设置name</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>headless</p>
<ul>
<li>Cluster IP会默认做负载均衡，但是如果想直接怼特定的Pod进行通信的话，就需要此类型的Service</li>
<li><strong>部署Stateful应用，比如数据库时，需要这样的Service，因为不同的Pod身份不一样，能执行的操作也不一样</strong></li>
<li>如果要访问特定的Pod，就必须知道要访问的Pod的IP，请求端获取IP的方法是使用<code>DNS Lookup</code>，对集群内部维护的DNS 服务发起对Service的lookup请求会返回Service的IP，但是如果把Service配置文件中的clusterIP节点设置为None后，返回的就是Service中注册的Pod的IP</li>
<li><strong>mention:创建此类型的Service只需要把clusterIP设置为None即可，不用设置type属性，实际上也不能设置为headless</strong><ul>
<li>type属性只能设置为：<ul>
<li>ClusterIP</li>
<li>NodePort</li>
<li>LoadBalancer</li>
</ul>
</li>
</ul>
</li>
<li><img src="http://images.demoli.xyz/image-20201221220724685.png" alt="image-20201221220724685"><ul>
<li>对于stateful应用来说，Cluster IP 与headless两种类型的Service一般是共存的</li>
</ul>
</li>
</ul>
</li>
<li><p>NodePort类型</p>
<ul>
<li><img src="http://images.demoli.xyz/image-20201221221225300.png" alt="image-20201221221225300" style="zoom:80%;" />

<ul>
<li><p>集群外部的流量可以直接通过特定的Node的端口访问到Service的特定端口</p>
</li>
<li><p>在创建NodePort类型的Service后会自动（隐式）创建一个ClusterIP 类型的Service（<strong>上图中的绿色部分</strong>）</p>
</li>
<li><p>当Pod分布在多个Node上时：</p>
</li>
<li><p><img src="http://images.demoli.xyz/image-20201221222139529.png" alt="image-20201221222139529"></p>
<ul>
<li>自动创建的绿色部分的ClusterIP类型的Service仍然发挥负载均衡的作用，并且只接受来自NodePort Service的流量</li>
</ul>
</li>
<li><p>显然此类型的Service不安全，更好的向集群外部提供服务的Service类型是LoadBalancer类型，在实际使用中只有在快速测试时会用到NodePort类型的Service，生产环境下有如下两个选择以暴露服务：</p>
<p><img src="http://images.demoli.xyz/image-20201221223301567.png" alt="image-20201221223301567"></p>
</li>
</ul>
</li>
<li><p>LoadBalancer类型</p>
<ul>
<li><img src="http://images.demoli.xyz/image-20201221222519829.png" alt="image-20201221222519829"><ul>
<li>通过云厂商提供的负载均衡服务器来访问</li>
<li>类似的LoadBalancer类型的Service（蓝色部分）创建后会自动创建（隐式）对应的NodePort（灰色边界未画出）、ClusterIP（绿色部分）类型的Service<ul>
<li>类似的 此时NodePort类型的Service只会接受来自LoadBalancer的流量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/home/">k8s官网</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">ssh端口转发配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:14:24 / Modified: 15:14:40" itemprop="dateCreated datePublished" datetime="2021-07-11T15:14:24+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用autossh进行端口转发设置"><a href="#使用autossh进行端口转发设置" class="headerlink" title="使用autossh进行端口转发设置"></a>使用autossh进行端口转发设置</h1><h2 id="1-1-端口转发"><a href="#1-1-端口转发" class="headerlink" title="1.1 端口转发"></a>1.1 端口转发</h2><p>ssh端口转发也称作ssh隧道，通过SSH登陆之后，在SSH客户端与SSH服务端之间建立了一个隧道，从而进行通信。SSH隧道是非常安全的，因为SSH是通过加密传输数据的(SSH全称为Secure Shell)</p>
<h3 id="1-1-1-端口转发分类"><a href="#1-1-1-端口转发分类" class="headerlink" title="1.1.1 端口转发分类"></a>1.1.1 端口转发分类</h3><p>端口转发分为以下3种：</p>
<ol>
<li>本地端口转发<ol>
<li>所谓本地端口转发，就是将发送到本地端口的请求，转发到目标端口。这样，就可以通过访问本地端口，来访问目标端口的服务</li>
</ol>
</li>
<li>远程端口转发<ol>
<li>所谓远程端口转发，就是将发送到远程端口的请求，转发到目标端口</li>
</ol>
</li>
<li>动态端口转发<ol>
<li>可用于科学上网，使用远程主机作为proxy，进行请求转发</li>
</ol>
</li>
</ol>
<h2 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h2><h3 id="1-2-0-跳板机配置"><a href="#1-2-0-跳板机配置" class="headerlink" title="1.2.0 跳板机配置"></a>1.2.0 跳板机配置</h3><p>跳板机是可以被远程连接并用来访问内网主机的代理主机，一般是拥有公网IP的服务器，需要对其ssh服务做一下配置：</p>
<ol>
<li>在跳板机执行：</li>
</ol>
<p>vi /etc/ssh/sshd_config # 添加以下代码，或者解开其注释，否则无法正常实施端口映射功能GatewayPorts clientspecified # 重启ssh服务 sudo service ssh restart</p>
<ol>
<li>将内网主机的公钥放到跳板机服务器的***/root/.ssh/authorized_keys***中，直接换行加入即可，不要删除文件中的原有的其他公钥 </li>
<li>在内网主机使用ssh连接到跳板机，*<strong>ssh root@${跳板机IP} -p ${跳板机ssh端口}*</strong> 直到不用输入yes交互为止</li>
<li>开启跳板机端口（阿里云或者腾讯云控制台更改或者进行防火墙更改）</li>
</ol>
<h3 id="1-2-1-本地端口转发"><a href="#1-2-1-本地端口转发" class="headerlink" title="1.2.1 本地端口转发"></a>1.2.1 本地端口转发</h3><p>公网主机A部署了监听在3000端口的web服务，但是使用防火墙只开放了22（ssh）端口，其他网域的主机B想要访问web服务，有两种方法： </p>
<ol>
<li>更改公网主机的防火墙设置，添加允许主机B的IP，但是如果主机B是内网IP的话，真实访问的IP是动态的，无法有效配置防火墙</li>
<li>使用本地端口转发，通过建立A与B的ssh隧道，完成B对A的3000端口的访问</li>
</ol>
<p>本地端口转发的配置方法：</p>
<p>在主机B执行：</p>
<p>ssh -L ${主机B的IP，即主机B的网卡IP可以省略（冒号也一同省略）}:2000:${主机A的网卡IP，一般是localhost，同样可省略}:3000 root@${主机A公网IP}</p>
<p>将对于主机B的2000端口的访问代理到主机A的3000端口</p>
<p>注意事项：</p>
<ul>
<li>主机B的网卡地址localhost可以省略，即可以将对B主机上的任意网卡的2000端口进行代理</li>
<li>其他场景：<ul>
<li>主机B可以通过同一内网的主机C去访问主机A：</li>
</ul>
</li>
</ul>
<p>在主机B执行：</p>
<p>ssh -L ${主机C内网IP}:2000:localhost:3000 root@${主机A IP}</p>
<p>此时直接访问主机C的内网IP:2000就可以访问到主机A的3000端口</p>
<ul>
<li>同理的，主机B也可以通过访问和主机A同一子网的主机D去间接访问主机A：在主机B执行：</li>
</ul>
<p>ssh -L 2000:${主机A内网IP}:3000 root@${主机D的公网IP}</p>
<ul>
<li>当使用本地端口映射的时候不能同时使用-N -f参数（autossh），这两个参数只能作用于远程端口转发，所以只要关闭端口转发的终端，整个复杂端口转发就会立即失效</li>
</ul>
<h2 id="1-2-远程端口转发"><a href="#1-2-远程端口转发" class="headerlink" title="1.2 远程端口转发"></a>1.2 远程端口转发</h2><p>没有公网IP的内网主机B部署了监听在3000端口的web服务，需要通过公网主机A去代理此服务，以将服务暴露到公网，供任意其他主机访问</p>
<p>远程端口转发的配置方法：</p>
<p>在主机B执行：</p>
<p>ssh -R ${公网主机A 网卡IP一般设置为0.0.0.0 可省略}:2000:${内网主机B的网卡 IP一般为 localhost}:3000 root@${主机A 公网IP}</p>
<p>将对于主机A的2000端口的访问代理到主机B的3000端口</p>
<p>注意事项：</p>
<ul>
<li>类似的，冒号前后的两个主机也可以进行更改，比如内网主机IP换成是与主机B同一内网的主机C，那么可以通过访问主机A访问到主机C的服务</li>
<li>直接使用ssh会有超时断连的可能，因此常使用autossh工具，此工具会使用一个本地主机的端口去监控是否断连，并尝试进行重连，使用步骤如下：<ol>
<li>在内网主机执行</li>
</ol>
</li>
</ul>
<p>autossh -N -f -M ${监听端口} -i /root/.ssh/id_rsa -R 0.0.0.0:${跳板机端口}:localhost:${内网机端口，比如 22} root@${跳板机公网IP} -p ${跳板机的ssh 端口，一般为了安全，不会使用默认的22端口}</p>
<p>​            参数解释：</p>
<ul>
<li>-f表示后台运行 </li>
<li>-N不执行远程命令，只进行端口转发，意思就是指进行端口转发而不接入远程shell </li>
<li>-R表示是远程端 口映射（反向代理）区别于-L 本地端口映射（正向代理），根本区别在于映射的方向</li>
</ul>
<p>注意事项：</p>
<ul>
<li>注意各个参数的顺序，不要随意更改</li>
<li>-M 后的端口尽量随机，保证这个端口以及其附近端口没有被占用（因为autossh会默认使用此端口以及此端口+1的端口）</li>
<li>autossh有-o参数，可以指定一些属性，但是经过测试，在centos上这些-o属性失效，有待验证。如果要使用-o参数的话，可参考<a target="_blank" rel="noopener" href="https://reid.red:233/w/Ubuntu_%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%BF%9E%E6%8E%A5">wiki</a></li>
<li>一般来说验证autossh有没有生效的方法就是查看进程中有没有对应的ssh命令，***ps -aux | grep ssh***看看除了autossh之外，有没有自动执行其他的ssh命令，如果有的话，就是执行成功了，如果失败可以尝试更换 -M 后的端口</li>
<li>务必带上 -f -N参数，只有这样端口转发才可以作为一个后台的服务运行，这样只要设置自启动就可以无阻碍使用了，而不用担心关闭终端之后导致的端口转发失效</li>
<li>如果在内网机器上执行SSH连接公网主机失败，提示：Warning: remote port forwarding failed for listen port，可以在跳板机上把这端口对应的进程 kill 掉，然后重新尝试连接</li>
</ul>
<ol>
<li>设置自启动</li>
</ol>
<h2 id="1-3-动态端口转发"><a href="#1-3-动态端口转发" class="headerlink" title="1.3 动态端口转发"></a>1.3 动态端口转发</h2><ul>
<li>对于本地端口转发和远程端口转发，都存在两个一一对应的端口，分别位于SSH的客户端和服务端，而动态端口转发则只是绑定了一个本地端口，而目标地址:目标端口则是不固定的，由发起的请求决定</li>
<li>可以将在本地主机A发起的请求，转发到远程主机B，而由B去真正地发起请求（对主机B的本机服务，或者是其他服务，比如主机B在海外，就可以访问Google等等）</li>
</ul>
<p>动态端口转发的步骤：</p>
<ol>
<li>在内网主机执行</li>
</ol>
<p>ssh -D ${内网网卡IP}:${内网代理端口} root@${公网IP}</p>
<ol>
<li>本地发起的请求，需要由Socket代理(Socket Proxy)转发到内网代理端口。以Firefox浏览器为例，配置Socket代理需要找到首选项&gt;高级&gt;网络&gt;连接-&gt;设置:</li>
</ol>
<p><img src="http://images.demoli.xyz/rwj4cwziDZTSJuN0aGGclxW8QFU6BE2nQxbmgReyw8_vebsdlTJkMhKS4Kd9FvWyxba2VHeeTx3qmH3N5fG0wFswEg9BiBOViOKaltmsxNKsicjAJGdNfxipVk4HzuW6Obo17esm.png" alt="img"></p>
<p>这样的话，Firefox浏览器发起的请求都会转发到2000端口，然后通过SSH转发到真正地请求地址。若Node.js服务运行在远程云主机上，则在Firefox中访问localhost:${Node.js服务端口}即可以访问服务。如果主机B1能够访问外网的话，则可以科学上网</p>
<h2 id="1-4-链式端口转发"><a href="#1-4-链式端口转发" class="headerlink" title="1.4 链式端口转发"></a>1.4 链式端口转发</h2><p>所谓的链式端口转发，就是将本地端口转发与远程端口转发结合起来，适用于如下场景：</p>
<p>内网主机C将发往本机的某端口的请求转发到另一个内网的主机D的某端口的某服务，需要公网主机A做中转</p>
<ul>
<li>使用本地端口转发，建立主机C与公网主机A的连接</li>
<li>使用远程端口转发，建立主机A与内网主机D的连接 </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/exporter-Grafana-Prometheus%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/exporter-Grafana-Prometheus%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">exporter+Grafana+Prometheus系统监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:12:10 / Modified: 15:13:00" itemprop="dateCreated datePublished" datetime="2021-07-11T15:12:10+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文经过作者亲自验证，如果读者实践时出错，欢迎在评论区指出</p>
<h1 id="1-安装node-exporter"><a href="#1-安装node-exporter" class="headerlink" title="1 安装node_exporter"></a>1 安装<a target="_blank" rel="noopener" href="https://github.com/prometheus/node_exporter">node_exporter</a></h1><p>目标监控主机操作系统：Ubuntu Server 20.04</p>
<p>一键安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd --no-create-home --shell /bin/<span class="literal">false</span> node_exporter \</span><br><span class="line">&amp;&amp; <span class="built_in">cd</span> /opt &amp;&amp; wget https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz \</span><br><span class="line">&amp;&amp; tar xvf node_exporter-0.18.1.linux-amd64.tar.gz \</span><br><span class="line">&amp;&amp; sudo mv node_exporter-0.18.1.linux-amd64 /opt/node_exporter \</span><br><span class="line">&amp;&amp; sudo chown node_exporter:node_exporter /opt/node_exporter -R \</span><br><span class="line">&amp;&amp; sudo touch /etc/systemd/system/node_exporter.service \</span><br><span class="line">&amp;&amp; sudo <span class="built_in">echo</span> <span class="string">&#x27;[Unit]</span></span><br><span class="line"><span class="string">Description=Node Exporter</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string">After=network-online.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">User=node_exporter</span></span><br><span class="line"><span class="string">Group=node_exporter</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">ExecStart=/opt/node_exporter/node_exporter --collector.systemd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target&#x27;</span> &gt; /etc/systemd/system/node_exporter.service \</span><br><span class="line">&amp;&amp; sudo systemctl daemon-reload  \</span><br><span class="line">&amp;&amp; sudo systemctl <span class="built_in">enable</span> node_exporter \</span><br><span class="line">&amp;&amp; sudo systemctl start node_exporter \</span><br><span class="line">&amp;&amp; sudo journalctl -f --unit node_exporter</span><br></pre></td></tr></table></figure>

<p>安装完成后访问：<code>http://$&#123;host&#125;:9100/</code>，确认服务正常启动，如下图所示：</p>
<p><img src="https://lh3.googleusercontent.com/Y014MRf9ESaKzQDTpnXj9WwyDgLAEIvBV_0BfYbMd57Dhm6Bt9PG8KPA3X1PYfu9x2Aw3EN3_LaGZo-u_rKoV1mngEqIfOtKkY0I7fp-LnZxxsEAudGS6LruV1XgJ48Js8KbG7Bj" alt="img"></p>
<h1 id="2-安装Prometheus时间序列数据库"><a href="#2-安装Prometheus时间序列数据库" class="headerlink" title="2 安装Prometheus时间序列数据库"></a>2 安装Prometheus时间序列数据库</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a4acb61ce35">Prometheus</a>通过基于HTTP的pull方式采集时序数据，可以通过服务发现或者静态配置去获取要采集的目标服务器，支持单主节点工作，支持多种可视化图表及仪表盘。</p>
<p>在<strong>中控节点</strong>安装Prometheus，一键安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /opt/promethes \</span><br><span class="line">&amp;&amp; touch /opt/promethes/promethes.yml \</span><br><span class="line">&amp;&amp; sudo <span class="built_in">echo</span> <span class="string">&#x27;global:</span></span><br><span class="line"><span class="string">  scrape_interval:     15s</span></span><br><span class="line"><span class="string">  external_labels:</span></span><br><span class="line"><span class="string">    monitor: &#x27;</span>codelab-monitor<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scrape_configs:</span></span><br><span class="line"><span class="string">  - job_name: &#x27;</span>prometheus<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    scrape_interval: 5s</span></span><br><span class="line"><span class="string">    static_configs:</span></span><br><span class="line"><span class="string">      - targets: [&#x27;</span>localhost:9090<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">  - job_name: &#x27;</span>node<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    scrape_interval: 5s</span></span><br><span class="line"><span class="string">    static_configs:</span></span><br><span class="line"><span class="string">      - targets: [&#x27;</span><span class="variable">$&#123;host1&#125;</span>:9100<span class="string">&#x27;,&#x27;</span><span class="variable">$&#123;host2&#125;</span>:9100<span class="string">&#x27;, ...]</span></span><br><span class="line"><span class="string">&#x27;</span> &gt; /opt/promethes/promethes.yml \</span><br><span class="line">&amp;&amp; docker run -d --restart=always \</span><br><span class="line">  -p 9090:9090 \</span><br><span class="line">  -v /opt/promethes/promethes.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">  prom/prometheus</span><br></pre></td></tr></table></figure>

<ul>
<li>加粗的targets的值是待监控的主机列表</li>
</ul>
<p>安装完成后访问：<code>http://$&#123;host&#125;:9090/</code>，确认服务正常启动，如下图所示：</p>
<p><img src="https://lh4.googleusercontent.com/rm0EnLb7R6lBDMvXSa7UjtonyarFQ1OjYKUPhBQL9JhZbITnPFeosKQ3FtNuZpxIJkEKAuymkxviLm8MWWq2eM6oR9ps9-2r5BdQ3QYQccM12gGf10xhyNLVNolxj3UPf32ZYqJr" alt="img"></p>
<h1 id="3-安装Grafana图形化监控控制台"><a href="#3-安装Grafana图形化监控控制台" class="headerlink" title="3 安装Grafana图形化监控控制台"></a>3 安装Grafana图形化监控控制台</h1><ul>
<li>Grafana是一个开源的度量分析与可视化套件。 纯Javascript 开发的前端工具，通过访问库（如InfluxDB），展示自定义报表、显示图表等。Grafana的UI更加灵活，有丰富的插件，功能强大。</li>
</ul>
<p>在中控节点(host0)安装Grafana，一键安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y apt-transport-https \</span><br><span class="line">&amp;&amp; sudo apt-get install -y software-properties-common wget \</span><br><span class="line">&amp;&amp; wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add - \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;deb https://packages.grafana.com/oss/deb stable main&quot;</span> | sudo tee -a /etc/apt/sources.list.d/grafana.list \</span><br><span class="line">&amp;&amp; sudo apt-get update</span><br><span class="line">&amp;&amp; sudo apt-get install grafana</span><br></pre></td></tr></table></figure>

<p>安装完成后访问：<code>http://$&#123;host0&#125;:3000/</code>，确认服务正常启动</p>
<h2 id="3-1-配置默认Prometheus数据源"><a href="#3-1-配置默认Prometheus数据源" class="headerlink" title="3.1 配置默认Prometheus数据源"></a>3.1 配置默认Prometheus数据源</h2><p>左侧菜单<code>Configuration → Data Sources</code>，点击/编辑默认Prometheus数据源，配置URL为：<code>http://localhost:9090</code>，Save &amp; Test</p>
<h2 id="3-2-安装Node-Exporter-Dashboard"><a href="#3-2-安装Node-Exporter-Dashboard" class="headerlink" title="3.2 安装Node Exporter Dashboard"></a>3.2 安装Node Exporter Dashboard</h2><ul>
<li><p>插件地址：<a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards/11074">https://grafana.com/grafana/dashboards/11074</a></p>
</li>
<li><p>如何安装：<a target="_blank" rel="noopener" href="https://grafana.com/docs/grafana/latest/reference/export_import/">https://grafana.com/docs/grafana/latest/reference/export_import/</a></p>
</li>
<li><p>以配置文件的方式导入，<a target="_blank" rel="noopener" href="https://blog.demoli.xyz/node_exporter_dashborad-json/">配置文件</a></p>
</li>
</ul>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/nwesterhausen/d06a772cbf2a741332e37b5b19edb192">nwesterhausen/node_exporter_setup.md</a></li>
<li><a target="_blank" rel="noopener" href="https://songjiayang.gitbooks.io/prometheus/content/exporter/nodeexporter.html">Node Exporter 接口说明</a></li>
<li><a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/installation/">Prometheus Installation</a></li>
<li><a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/getting_started/">Prometheus Getting Started</a></li>
<li><a target="_blank" rel="noopener" href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter">使用Node Exporter采集主机数据</a></li>
<li>[Grafana Install on Debian or Ubuntu](</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/Bind%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/Bind%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Bind自定义域名解析服务器的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:10:50 / Modified: 15:11:19" itemprop="dateCreated datePublished" datetime="2021-07-11T15:10:50+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>使用docker-bind搭建私有的DNS服务器，在整个内网集群中使用域名来管理服务器已经进行服务配置</li>
<li><strong>以下说明是基于Ubuntu20.04的，如果要构建在树莓派上运行的docker镜像，参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6932782304075251726">文章</a></strong></li>
</ul>
<h2 id="配置与安装"><a href="#配置与安装" class="headerlink" title="配置与安装"></a>配置与安装</h2><h3 id="本机DNS配置"><a href="#本机DNS配置" class="headerlink" title="本机DNS配置"></a>本机DNS配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/resolved.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改为以下内容</span></span><br><span class="line"><span class="comment"># 假设docker-bind所在服务器IP地址为192.168.3.37</span></span><br><span class="line">[Resolve]</span><br><span class="line">DNS=192.168.3.37</span><br><span class="line"><span class="comment">#FallbackDNS=</span></span><br><span class="line"><span class="comment">#Domains=</span></span><br><span class="line"><span class="comment">#LLMNR=no</span></span><br><span class="line"><span class="comment">#MulticastDNS=no</span></span><br><span class="line"><span class="comment">#DNSSEC=no</span></span><br><span class="line"><span class="comment">#DNSOverTLS=no</span></span><br><span class="line"><span class="comment">#Cache=no</span></span><br><span class="line">DNSStubListener=no</span><br><span class="line"><span class="comment">#ReadEtcHosts=yes</span></span><br><span class="line"></span><br><span class="line">sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参考 <a target="_blank" rel="noopener" href="https://bynss.com/codes/381916.html/amp">怎样释放<code>systemd-resoved</code>使用的53端口</a></p>
</li>
<li><p>配置后，此时<code>/etc/resolv.conf</code>的内容为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is managed by man:systemd-resolved(8). Do not edit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is a dynamic resolv.conf file for connecting local clients directly to</span></span><br><span class="line"><span class="comment"># all known uplink DNS servers. This file lists all configured search domains.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Third party programs must not access this file directly, but only through the</span></span><br><span class="line"><span class="comment"># symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,</span></span><br><span class="line"><span class="comment"># replace this symlink by a static file or a different symlink.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See man:systemd-resolved.service(8) for details about the supported modes of</span></span><br><span class="line"><span class="comment"># operation for /etc/resolv.conf.</span></span><br><span class="line"></span><br><span class="line">nameserver 192.168.3.37</span><br><span class="line">nameserver 192.168.3.1</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个是我们指定的bind构建的dns服务器</li>
<li>第二个是本地的子网的网管的dns服务器</li>
<li><strong>注意先后顺序不能更改，如果内容并非如此的话，可以删除<code>/etc/resolv.conf</code>并重新执行<code>sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf</code></strong></li>
<li><strong>如果并没有<code>/run/systemd/resolve/resolv.conf</code>文件，说明执行了<code>systemctl disable systemd-resolved</code>或<code>service systemd-resolved stop</code>，因此执行<code>systemctl enable systemd-resolved</code>和<code>service systemd-resolved start</code>并重启即可</strong></li>
</ul>
</li>
</ul>
<h3 id="docker-bind安装"><a href="#docker-bind安装" class="headerlink" title="docker-bind安装"></a>docker-bind安装</h3><p>选定集群中用作搭建DNS服务器的服务器执行下列命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在关闭本机解析服务之前拉取镜像</span></span><br><span class="line">docker pull sameersbn/<span class="built_in">bind</span>:9.16.1-20200524</span><br><span class="line"><span class="comment"># 使用docker容器部署bind服务</span></span><br><span class="line">docker run \ </span><br><span class="line">--name <span class="built_in">bind</span> \ </span><br><span class="line">-d \</span><br><span class="line">--restart=always \</span><br><span class="line">--publish 53:53/tcp \</span><br><span class="line">--publish 53:53/udp \ </span><br><span class="line">--publish 10000:10000/tcp \ </span><br><span class="line">--volume docker-bind:/data \</span><br><span class="line">sameersbn/<span class="built_in">bind</span>:9.16.1-20200524</span><br></pre></td></tr></table></figure>



<h3 id="docker-bind配置"><a href="#docker-bind配置" class="headerlink" title="docker-bind配置"></a>docker-bind配置</h3><ul>
<li><p>假设服务器IP地址为<code>192.168.3.37</code>，本地根域名为<code>dev</code>。</p>
</li>
<li><p>访问Webmin管理界面，地址为：<a target="_blank" rel="noopener" href="https://192.168.3.37:10000/%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%9A%60root%60%EF%BC%8C%E5%AF%86%E7%A0%81%EF%BC%9A%60password%60%EF%BC%8C%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">https://192.168.3.37:10000/，默认用户名：`root`，密码：`password`，相关设置如下：</a></p>
</li>
</ul>
<ol>
<li>Servers → BIND DNS Server → Global Server Options → Access Control Lists，添加：<ol>
<li>allow-query any</li>
</ol>
</li>
<li>Servers → BIND DNS Server → Global Server Options → Forwarding and Transfers → Global forwarding and zone transfer options，添加转发dns服务器IP地址：<ol>
<li>8.8.8.8</li>
<li>8.8.4.4</li>
<li><strong>暂时只添加了Google的DNS。添加其他的一些国内的DNS（如AliDNS），反而会有问题（ntp 服务器访问失败等等）</strong></li>
</ol>
</li>
<li>Servers → BIND DNS Server → Existing DNS Zones → Create Master Zone<ol>
<li>Zone type: Forward (Names to Addresses)</li>
<li>Domain name / Network: dev</li>
<li>Master server: a.dev</li>
<li>Email address: admin@dev</li>
</ol>
</li>
<li>Servers → BIND DNS Server → Existing DNS Zones → Create Master Zone<ol>
<li>Zone type: Reverse (Addresses to Names)</li>
<li>Domain name / Network: <strong>192.168.3</strong></li>
<li>Master server: a.dev</li>
<li>Email address: admin@dev</li>
</ol>
</li>
<li>Servers → BIND DNS Server → Existing DNS Zones → dev<ol>
<li>Address中添加DNS记录<ol>
<li>Name: a，Address: 192.168.3.37，点击Create，会自动添加并更新逆向地址记录</li>
<li>按需添加其他DNS记录<ol>
<li><strong>可能需要重启容器才会是新添加的DNS记录生效</strong></li>
</ol>
</li>
</ol>
</li>
<li>Servers → BIND DNS Server → Existing DNS Zones → dev→ Name Server确认存在域名服务器地址<ol>
<li>Zone Name: dev.</li>
<li>Name Server: a.dev.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>更新本机nameservers设置，设定为服务器IP地址，并执行以下命令检查DNS服务器工作是否正常</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br><span class="line">nslookup a.dev</span><br><span class="line">nslookup b.dev</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果出现<code>;; Got recursion not available from 192.168.3.37, trying next server</code>的问题，执行下述操作（<strong>更方便的做法是按照文件的内容 在dashboard中进行修改：Servers → BIND DNS Server → Global Server Options → Edit Config File</strong>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">docker cp  <span class="built_in">bind</span>:/etc/<span class="built_in">bind</span>/named.conf.options ./</span><br><span class="line">docker cp  <span class="built_in">bind</span>:/etc/<span class="built_in">bind</span>/named.conf ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别对两文件进行修改</span></span><br><span class="line"><span class="comment"># named.conf</span></span><br><span class="line"></span><br><span class="line">acl trusted &#123;</span><br><span class="line">    192.168.0.0/16;</span><br><span class="line">    10.153.154.0/24;</span><br><span class="line">    localhost;</span><br><span class="line">    localnets;</span><br><span class="line">    &#125;;</span><br><span class="line">// This is the primary configuration file <span class="keyword">for</span> the BIND DNS server named.</span><br><span class="line">//</span><br><span class="line">// Please <span class="built_in">read</span> /usr/share/doc/bind9/README.Debian.gz <span class="keyword">for</span> information on the</span><br><span class="line">// structure of BIND configuration files <span class="keyword">in</span> Debian, *BEFORE* you customize</span><br><span class="line">// this configuration file.</span><br><span class="line">//</span><br><span class="line">// If you are just adding zones, please <span class="keyword">do</span> that <span class="keyword">in</span> /etc/<span class="built_in">bind</span>/named.conf.local</span><br><span class="line"></span><br><span class="line">include <span class="string">&quot;/etc/bind/named.conf.options&quot;</span>;</span><br><span class="line">include <span class="string">&quot;/etc/bind/named.conf.local&quot;</span>;</span><br><span class="line">include <span class="string">&quot;/etc/bind/named.conf.default-zones&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># named.conf.options</span></span><br><span class="line">options &#123;</span><br><span class="line">        directory <span class="string">&quot;/var/cache/bind&quot;</span>;</span><br><span class="line"></span><br><span class="line">        // If there is a firewall between you and nameservers you want</span><br><span class="line">        // to talk to, you may need to fix the firewall to allow multiple</span><br><span class="line">        // ports to talk.  See http://www.kb.cert.org/vuls/id/800113</span><br><span class="line"></span><br><span class="line">        // If your ISP provided one or more IP addresses <span class="keyword">for</span> stable</span><br><span class="line">        // nameservers, you probably want to use them as forwarders.</span><br><span class="line">        // Uncomment the following block, and insert the addresses replacing</span><br><span class="line">        // the all-0<span class="string">&#x27;s placeholder.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // forwarders &#123;</span></span><br><span class="line"><span class="string">        //      0.0.0.0;</span></span><br><span class="line"><span class="string">        // &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        //========================================================================</span></span><br><span class="line"><span class="string">        // If BIND logs error messages about the root key being expired,</span></span><br><span class="line"><span class="string">        // you will need to update your keys.  See https://www.isc.org/bind-keys</span></span><br><span class="line"><span class="string">        //========================================================================</span></span><br><span class="line"><span class="string">        dnssec-validation auto;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        listen-on-v6 &#123; any; &#125;;</span></span><br><span class="line"><span class="string">        forwarders &#123;</span></span><br><span class="line"><span class="string">                8.8.8.8;</span></span><br><span class="line"><span class="string">                8.8.4.4;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">        allow-query &#123; any; &#125;;</span></span><br><span class="line"><span class="string">        allow-recursion &#123; trusted; &#125;;</span></span><br><span class="line"><span class="string">        allow-query-cache &#123; trusted; &#125;;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 写回到容器中</span></span><br><span class="line"><span class="string">docker cp  ./named.conf.options bind:/etc/bind/named.conf.options</span></span><br><span class="line"><span class="string">docker cp  ./named.conf bind:/etc/bind/named.conf</span></span><br><span class="line"><span class="string"># 重启容器</span></span><br><span class="line"><span class="string">docker restart bind</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参考 <a target="_blank" rel="noopener" href="https://github.com/sameersbn/docker-bind/issues/14">issue</a></li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/sameersbn/docker-bind">sameersbn / docker-bind</a></li>
<li><a target="_blank" rel="noopener" href="https://kifarunix.com/setup-bind-dns-using-webmin-on-debian-10/">Setup Bind DNS Using Webmin on Debian 10</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.codepre.com/how-to-6994.html">在CentOS 8上使用Webmin配置BIND DNS服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://tweenpath.net/dns-forwarder-transfer-bind-webmin/">DNS Forwarder and Transfer using Bind and Webmin</a></li>
<li><a target="_blank" rel="noopener" href="https://doxfer.webmin.com/Webmin/BIND_DNS_Server">BIND DNS Server</a></li>
<li>[DNS之BIND使用小结(Forward转发)](</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/OpenResty%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/OpenResty%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">OpenResty的部署与使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:09:03 / Modified: 15:09:34" itemprop="dateCreated datePublished" datetime="2021-07-11T15:09:03+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OpenResty是什么"><a href="#OpenResty是什么" class="headerlink" title="OpenResty是什么"></a>OpenResty是什么</h2><ul>
<li><p>OpenResty是什么，官网是这样介绍的：</p>
<blockquote>
<p>通过 Lua 扩展 NGINX 实现的可伸缩的 Web 平台</p>
</blockquote>
<p>的确，OpenResty可以简单的理解为Nginx + Lua，通过Lua库引入数据库访问能力，真正的让Nginx向搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关这一目标迈出了重要的一步</p>
</li>
</ul>
<h2 id="OpenResty的配置"><a href="#OpenResty的配置" class="headerlink" title="OpenResty的配置"></a>OpenResty的配置</h2><ul>
<li>OpenResty的配置可以分为2类<ul>
<li>lua脚本</li>
<li>Nginx配置文件</li>
</ul>
</li>
<li>下面列举几个常见场景的Nginx配置</li>
</ul>
<h3 id="静态文件（页面）服务器配置"><a href="#静态文件（页面）服务器配置" class="headerlink" title="静态文件（页面）服务器配置"></a>静态文件（页面）服务器配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 以dvclab.com作为主网站域名，完全匹配</span></span><br><span class="line">    <span class="attribute">server_name</span> <span class="variable">$&#123;hostname&#125;</span>;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$&#123;hostname&#125;</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="variable">$&#123;hostname&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl证书文件位置(常见证书文件格式为：crt/pem)</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /etc/nginx/ssl/<span class="variable">$&#123;hostname&#125;</span>.pem;</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># ssl证书key位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/nginx/ssl/<span class="variable">$&#123;hostname&#125;</span>.key;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span>        /etc/nginx/dist;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将静态页面文件放到OpenResty容器内的<code>/etc/nginx/dist</code>内即可，后续会使用Docker Compose的yaml配置文件做路径映射</li>
</ul>
<h3 id="一般反向代理"><a href="#一般反向代理" class="headerlink" title="一般反向代理"></a>一般反向代理</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="variable">$&#123;hostname&#125;</span>;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$&#123;hostname&#125;</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>          <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>     <span class="variable">$&#123;hostname&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl证书文件位置(常见证书文件格式为：crt/pem)</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /etc/nginx/ssl/auth-cert.pem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ssl证书key位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/nginx/ssl/auth-cert.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    </span><br><span class="line">         <span class="attribute">proxy_set_header</span>  Host  $host;</span><br><span class="line">         <span class="attribute">proxy_set_header</span>  X-Forwarded-Proto $scheme;</span><br><span class="line">         <span class="attribute">proxy_set_header</span>  X-Forwarded-For $host;</span><br><span class="line">         <span class="attribute">proxy_set_header</span>  Upgrade $http_upgrade;</span><br><span class="line">         <span class="attribute">proxy_set_header</span>  Connection <span class="string">&#x27;Upgrade&#x27;</span>;</span><br><span class="line">    		 <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">         <span class="attribute">proxy_set_header</span>  X-Real-IP $remote_addr;</span><br><span class="line">         </span><br><span class="line">         <span class="attribute">proxy_pass</span>    http://<span class="variable">$&#123;target&#125;</span>/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>${target}就是反向代理的目标服务器地址或域名，注意不要丢掉后边的<code>/</code></strong></li>
</ul>
<h3 id="动态路由设置"><a href="#动态路由设置" class="headerlink" title="动态路由设置"></a>动态路由设置</h3><ul>
<li>大致的请求-相应流程如下</li>
</ul>
<p><img src="http://images.demoli.xyz/image-20210314234123950.png" alt="image-20210314234123950"></p>
<ul>
<li><strong>需求说明：根据请求参数动态转发到不同的服务器、端口</strong>，比如<code>hostname/users/1/info/2</code> 转发到<code>hosname1:9200</code>，<code>hostname/users/3/info/4</code>转发到<code>hostname2:8080</code></li>
</ul>
<p>在/opt/openresty/lua/目录下创建 split.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&#x27;</span></span><br><span class="line"><span class="string">--[[ </span></span><br><span class="line"><span class="string">拆分字符串 </span></span><br><span class="line"><span class="string">e.g. /a/b/c  </span></span><br><span class="line"><span class="string">table[1] a</span></span><br><span class="line"><span class="string">table[2] b</span></span><br><span class="line"><span class="string">table[3] c</span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string">function split(str, pat)</span></span><br><span class="line"><span class="string">    local t = &#123;&#125;</span></span><br><span class="line"><span class="string">    local fpat = &quot;(.-)&quot; .. pat</span></span><br><span class="line"><span class="string">    local last_end = 1</span></span><br><span class="line"><span class="string">    local s, e, cap = str:find(fpat, 1)</span></span><br><span class="line"><span class="string">    while s do</span></span><br><span class="line"><span class="string">        if s ~= 1 or cap ~= &quot;&quot; then</span></span><br><span class="line"><span class="string">            table.insert(t, cap)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        last_end = e + 1</span></span><br><span class="line"><span class="string">        s, e, cap = str:find(fpat, last_end)</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    if last_end &lt;= #str then</span></span><br><span class="line"><span class="string">        cap = str:sub(last_end)</span></span><br><span class="line"><span class="string">        table.insert(t, cap)</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    return t</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function split_path(str)</span></span><br><span class="line"><span class="string">    return split(str, &#x27;</span>[\\/]+<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&#x27;</span> &gt; /opt/openresty/lua/split.lua</span><br></pre></td></tr></table></figure>

<p>在/opt/openresty/lua/目录下创建 query_redis.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&#x27; </span></span><br><span class="line"><span class="string">-- redis结果解析,导入redis.parser脚本</span></span><br><span class="line"><span class="string">local parser = require &quot;redis.parser&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- ngx.var.uri只包含路径参数，不包含主机与端口</span></span><br><span class="line"><span class="string">-- 调用worker启动时引入的lua脚本中提供的函数</span></span><br><span class="line"><span class="string">local parameters = split_path(ngx.var.uri)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 访问的是根路径</span></span><br><span class="line"><span class="string">if(#parameters == 0) then</span></span><br><span class="line"><span class="string">   ngx.exit(ngx.HTTP_FORBIDDEN)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 拆分出查询参数</span></span><br><span class="line"><span class="string">user_id = parameters[2]</span></span><br><span class="line"><span class="string">container_id = parameters[4]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;user_id---&gt;&quot;, user_id)</span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;container_id---&gt;&quot;, container_id)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 组合参数</span></span><br><span class="line"><span class="string">key = &quot;DYNA&quot;</span></span><br><span class="line"><span class="string">id = user_id .. &quot;_&quot; .. container_id</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 向redis查询</span></span><br><span class="line"><span class="string">res = ngx.location.capture(</span></span><br><span class="line"><span class="string">           &quot;/redis&quot;, &#123; args = &#123; key = key, id = id &#125; &#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 查询失败</span></span><br><span class="line"><span class="string">if res.status ~= 200 then</span></span><br><span class="line"><span class="string">           ngx.log(ngx.ERR, &quot;redis server returned bad status: &quot;,</span></span><br><span class="line"><span class="string">               res.status)</span></span><br><span class="line"><span class="string">           ngx.exit(res.status)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 结果为空</span></span><br><span class="line"><span class="string">if not res.body then</span></span><br><span class="line"><span class="string">           ngx.log(ngx.ERR, &quot;redis returned empty body&quot;)</span></span><br><span class="line"><span class="string">           ngx.exit(500)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- raw tcp response from redis server</span></span><br><span class="line"><span class="string">-- 共2条返回所以应该使用parse_replies(res.body, 2)</span></span><br><span class="line"><span class="string">-- OK</span></span><br><span class="line"><span class="string">-- 172.17.144.4:8080</span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;raw response -----&gt;&quot;, res.body)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local results = parser.parse_replies(res.body, 2)</span></span><br><span class="line"><span class="string">for i, result in ipairs(results) do</span></span><br><span class="line"><span class="string">if i == 2 then</span></span><br><span class="line"><span class="string">      server = result[1]</span></span><br><span class="line"><span class="string">      typ = result[2]</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 检查结果类型</span></span><br><span class="line"><span class="string">if typ ~= parser.BULK_REPLY or not server then</span></span><br><span class="line"><span class="string">           ngx.exit(500)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 返回value为空</span></span><br><span class="line"><span class="string">if server == &quot;&quot; then</span></span><br><span class="line"><span class="string">           server = &quot;default.com&quot;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ngx.var.target = server</span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;key---&gt;&quot;, key)</span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;id---&gt;&quot;, id)</span></span><br><span class="line"><span class="string">ngx.log(ngx.EMERG, &quot;service---&gt;&quot;, server)</span></span><br><span class="line"><span class="string">&#x27;</span>   &gt; /opt/openresty/lua/query_redis.lua</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>上述的lua脚本中，假设Redis存储着以<code>DYNA</code>为key的hash表，hash表的key是由用户请求中解析出的user_id和container_id使用<code>_</code>组合而成，对应的value就是要转发到的目标target</strong></li>
</ul>
<p>在/opt/openresty/conf.d/目录下创建dynamicRouter.conf</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string"># 启用主进程后，在每次Nginx工作进程启动时运行指定的Lua代码</span></span><br><span class="line"><span class="string">init_worker_by_lua_file /usr/local/openresty/nginx/lua/split.lua;</span></span><br><span class="line"><span class="string">server &#123;</span></span><br><span class="line"><span class="string">   listen       443;</span></span><br><span class="line"><span class="string">   server_name  <span class="variable">$&#123;hostname&#125;</span>;</span></span><br><span class="line"><span class="string">   # redis交互库是openresty的内置的库</span></span><br><span class="line"><span class="string">   location = /redis &#123;</span></span><br><span class="line"><span class="string">       # Specifies that a given location can only be used for internal requests</span></span><br><span class="line"><span class="string">       internal;</span></span><br><span class="line"><span class="string">       redis2_query auth <span class="variable">$&#123;redis_password&#125;</span>;</span></span><br><span class="line"><span class="string">       # 解析请求参数</span></span><br><span class="line"><span class="string">       set_unescape_uri $id $arg_id;</span></span><br><span class="line"><span class="string">       set_unescape_uri $key $arg_key;</span></span><br><span class="line"><span class="string">       # 执行redis查询请求</span></span><br><span class="line"><span class="string">       redis2_query hget $key $id;</span></span><br><span class="line"><span class="string">       # 查询请求转发到指定的redis_server</span></span><br><span class="line"><span class="string">       redis2_pass redis:6379;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   location / &#123;</span></span><br><span class="line"><span class="string">      # 设置一个内嵌脚本的共享变量</span></span><br><span class="line"><span class="string">      set $target &#x27;</span><span class="string">&#x27;;  </span></span><br><span class="line"><span class="string">      # 引入内嵌脚本</span></span><br><span class="line"><span class="string">      access_by_lua_file /usr/local/openresty/nginx/lua/query_redis.lua;</span></span><br><span class="line"><span class="string">      resolver 8.8.8.8;</span></span><br><span class="line"><span class="string">      # 进行请求转发（反向代理）</span></span><br><span class="line"><span class="string">      proxy_set_header  Host  $host;</span></span><br><span class="line"><span class="string">      proxy_set_header  X-Forwarded-For $host;</span></span><br><span class="line"><span class="string">      # 如果客户端请求升级，将代理WebSocket</span></span><br><span class="line"><span class="string">      proxy_set_header  Upgrade $http_upgrade;</span></span><br><span class="line"><span class="string">      proxy_set_header  Connection &#x27;</span>Upgrade<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">      proxy_set_header  X-Forwarded-Proto $scheme;</span></span><br><span class="line"><span class="string">      proxy_set_header  X-Real-IP $remote_addr;</span></span><br><span class="line"><span class="string">      proxy_http_version 1.1;</span></span><br><span class="line"><span class="string">      # 最后的斜杠勿丢 </span></span><br><span class="line"><span class="string">      proxy_pass http://$target/;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> &gt; /opt/openresty/conf.d/dynamicRouter.conf</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>${redis_password}是redis访问的密码</li>
</ul>
<h4 id="动态路由的使用"><a href="#动态路由的使用" class="headerlink" title="动态路由的使用"></a>动态路由的使用</h4><ul>
<li><p>在部署OpenResty服务后，就可以通过读写Redis的方式来实现动态路由转发了</p>
</li>
<li><p>在shell命令行使用 docker exec命令结合redis-cli即可完成动态配置，举例如下：</p>
<ul>
<li><p>目的：将 /users/<strong>${user_id}</strong>/containers/<strong>${container_id}</strong> 映射到 <strong>${host}</strong>:<strong>${port}</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it or-redis /bin/bash</span><br><span class="line">redis-cli --askpass</span><br><span class="line"><span class="comment"># 输入redis密码</span></span><br><span class="line">hset DYNA <span class="variable">$&#123;user_id&#125;</span>_<span class="variable">$&#123;container_id&#125;</span> <span class="variable">$&#123;host&#125;</span>:<span class="variable">$&#123;port&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：**${host}<strong>:</strong>${port} 不加最后的/；不用加协议头，默认是HTTP，同样也支持WebSocket的协议升级**</li>
</ul>
</li>
</ul>
</li>
<li><p>或者使用Redis-Java API 接口完成动态路由的设置</p>
</li>
</ul>
<h2 id="OpenResty的安装部署"><a href="#OpenResty的安装部署" class="headerlink" title="OpenResty的安装部署"></a>OpenResty的安装部署</h2><ul>
<li>本文章使用docker-compose进行OpneResty的安装部署</li>
</ul>
<h3 id="Docker-Compose的安装"><a href="#Docker-Compose的安装" class="headerlink" title="Docker Compose的安装"></a>Docker Compose的安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加可执行权限</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<ul>
<li>具体的最新的版本，可以去Docker官网查看</li>
</ul>
<h3 id="Docker-Compose-部署OpenResty服务"><a href="#Docker-Compose-部署OpenResty服务" class="headerlink" title="Docker Compose 部署OpenResty服务"></a>Docker Compose 部署OpenResty服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">echo</span> <span class="string">&#x27;version: &quot;3&quot;</span></span><br><span class="line"><span class="string">services:</span></span><br><span class="line"><span class="string">  redis:</span></span><br><span class="line"><span class="string">    image: redis</span></span><br><span class="line"><span class="string">    restart: always</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - /opt/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line"><span class="string">    command: redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string">    ports:</span></span><br><span class="line"><span class="string">      - &quot;61379:6379&quot;</span></span><br><span class="line"><span class="string">    container_name: or-redis</span></span><br><span class="line"><span class="string">  openresty:</span></span><br><span class="line"><span class="string">    image: openresty/openresty</span></span><br><span class="line"><span class="string">    restart: always</span></span><br><span class="line"><span class="string">    depends_on:</span></span><br><span class="line"><span class="string">      - redis</span></span><br><span class="line"><span class="string">    container_name: openresty</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - /opt/openresty/ssl/:/etc/nginx/ssl/</span></span><br><span class="line"><span class="string">      - /opt/openresty/conf.d/:/etc/nginx/conf.d/</span></span><br><span class="line"><span class="string">      - /opt/openresty/lua/:/usr/local/openresty/nginx/lua/</span></span><br><span class="line"><span class="string">      - /opt/static/:/etc/nginx/dist/</span></span><br><span class="line"><span class="string">    ports:</span></span><br><span class="line"><span class="string">      - &quot;443:443&quot;</span></span><br><span class="line"><span class="string">      - &quot;80:80&quot;</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="string">&gt;</span> <span class="string">/etc/openresty/openresty.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">/opt/openresty.yaml</span> <span class="string">up</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>/opt/openresty/ssl/</code> 目录是用来放域名的HTTPS证书的，当然也可以使用更方便的<code>Let&#39;s Encrypt</code>服务，可参考使用<a target="_blank" rel="noopener" href="https://github.com/auto-ssl/lua-resty-auto-ssl">lua-resty-auto-ssl</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module#nginx-log-level-constants">lua-nginx-module</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/openresty/redis2-nginx-module">redis2-nginx-module</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-redis-parser">lua-redis-parser</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx/admin-guide/monitoring/logging/">nginx-logging</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ts学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:05:28 / Modified: 15:05:52" itemprop="dateCreated datePublished" datetime="2021-07-11T15:05:28+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TS-学习笔记"><a href="#TS-学习笔记" class="headerlink" title="TS 学习笔记"></a>TS 学习笔记</h1><h2 id="TS是什么"><a href="#TS是什么" class="headerlink" title="TS是什么"></a>TS是什么</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs">官方文档</a>，多用多看</li>
<li>js的超集，构建于js之上的一种语言</li>
<li>在js的基础上引入类型系统等不错的特性，其中包括js的新特性（ES6或之后的）<ul>
<li>在开发过程中 vscode就会提示错误，而不是在运行时从控制台发现错误</li>
<li>ts的编译器会自动将js新特性编译成即使在旧版本的浏览器中也支持运行的js代码，取代了babel的功能</li>
<li><strong>js是动态类型语言，其变量的数据类型是在运行时确定的，而ts是静态类型语言，其类型在开发时就已经确定了，不会在运行时变动</strong></li>
</ul>
</li>
<li>ts不仅仅是一种语言，也可以视作是一个工具，可以将ts编译为js，以运行在browser或者nodejs中<ul>
<li>因此最终运行的还是js，所以ts的所有能力不能超出js所能提供的范围，ts只是在js之上引入了一些优秀特性，由编译器将这些特性转化为相对复杂的js代码</li>
<li>使用<code>npm install typescript -g</code>安装typescript支持，也会自动安装typescript的编译器</li>
<li>执行<code>tsc xx.ts</code>即可完成将ts编译为js<ul>
<li><strong>如果在开发中，IDE报错，但是并没有处理，而是直接编译，最终可以得到编译好的js，但是编译过程会报错</strong></li>
</ul>
</li>
<li>ts编译器提供了丰富的可配置选项</li>
</ul>
</li>
<li>ts不仅引入类型系统，还引入了接口，泛型以及元编程的概念（修饰器）</li>
<li>VSCode等现代IDE有了ts加持后，甚至可以在非ts的代码编辑中进行类型相关的智能的提示</li>
<li><strong>ts的类型系统只在编译时支持，在运行时是不会支持的，因为并没有支持ts运行的执行引擎，只有支持js运行的执行引擎</strong></li>
<li><strong>ts是开发、编译时的类型检查，而js是运行时的类型检查</strong></li>
</ul>
<h2 id="Demo引入"><a href="#Demo引入" class="headerlink" title="Demo引入"></a>Demo引入</h2><ul>
<li><p>简单的加法器，具体注释参考源码</p>
</li>
<li><p>如果使用js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> num2 !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Incorrect input!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有错误</p>
<ul>
<li>加法运算符对于js的字符串来说是字符串拼接，对于number类型才是加法运算，然而value属性是string类型</li>
</ul>
</li>
<li><p>修改错误</p>
<ul>
<li><p>添加<code>+</code>转换类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>如果使用ts</p>
<ul>
<li><p>IDE提示出错</p>
<ul>
<li><p><code>Property &#39;value&#39; does not exist on type &#39;HTMLElement&#39;</code>，HTMLElement对象未必有value属性，只有inputElement有此属性，ts要求我们确认input1与input2的属性，经过确认，二者是HtmlInputElement属性，有value属性，为表确认，使用<code>typecasting</code>标识</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在函数声明中，我们想明确，参数应该是number类型，而不是string类型，同样做好声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: number, num2: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(input1.value, input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此时，下边的函数调用处果然出错，value属性是string，不是要求的number，因此使用<code>+</code>转换类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting 类型断言</span></span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>)! <span class="keyword">as</span> HTMLInputElement; </span><br><span class="line"><span class="keyword">const</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>)! <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: number, num2: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>此时，IDE不再提示错误，查看编译后的js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">// typecasting</span></span><br><span class="line"><span class="keyword">var</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> input2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line"><span class="comment">// 类型声明 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用+将string类型转为number类型</span></span><br><span class="line">    <span class="built_in">console</span>.log(add(+input1.value, +input2.value));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以发现实际上与我们自己写的并无太大差异，<strong>ts正是使用这种明确的类型检查与声明确认的形式迫使开发者检查并声明类型，解决了其中的逻辑问题，但是最后的实现实际上可能比较简单，重点是发现并解决逻辑问题（即<code>+</code>的使用)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改错误</p>
</li>
<li><p>运行无错误</p>
</li>
</ul>
</li>
</ul>
<h2 id="开发前的设置"><a href="#开发前的设置" class="headerlink" title="开发前的设置"></a>开发前的设置</h2><ol>
<li><p>ts的学习是依托于前端环境的，所以需要有html文件，然后引入js文件，但是每次修改都需要在浏览器刷新看效果，比较麻烦，所以需要安装<code>lite-server</code>依赖，可以开启一个服务器，并监听文件变动，一旦变动会自动刷新执行更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在项目目录</span></span><br><span class="line">npm init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 安装依赖</span></span><br><span class="line">npm install --save-dev lite-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 修改配置文件 package.json，在scripts节点添加： <span class="string">&quot;start&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,随后执行：</span></span><br><span class="line">npm start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会自动server本目录下的index.html到localhost:3000</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项<strong>name length这样的变量名,会提示重复定义,这是因为<a target="_blank" rel="noopener" href="https://github.com/Microsoft/vscode/issues/22436">https://github.com/Microsoft/vscode/issues/22436</a></strong></p>
</li>
<li><p>安装debugger for Chrome可以在vscode而不是Chrome的dev tools中进行调试，start debugging，并将配置文件进行如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Chrome against localhost&quot;</span>,</span><br><span class="line">            <span class="comment">// 此处改为lite-server运行的3000端口</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;webRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意配置ts配置文件中的sourceMap为true</strong></li>
<li><strong>此扩展应该也可以进行nodejs的debug！！！</strong></li>
</ul>
</li>
</ol>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ol>
<li><p>ts支持的js原生类型：</p>
<ol>
<li><p>boolean</p>
<ol>
<li>true、false</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p>number</p>
<ol>
<li>所有的数字类型都归纳为number，没有Integer或float、double等<ol>
<li>实际上所有的number类型默认被视作float类型，因此5===5.0 为true</li>
</ol>
</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p>string</p>
<ol>
<li>使用””、’’、``定义都可<ol>
<li>最后一个是ES6中引入的，可以创建模板字符串</li>
</ol>
</li>
<li>ts支持的原生js类型</li>
</ol>
</li>
<li><p><strong>type inference机制</strong>，也就是类型猜测机制（可以将鼠标移动到变量处查看其类型）</p>
<ol>
<li><p>const类型：固定不变的类型 （由初始值确定），固定不变的值，<strong>实际上就是字面量类型</strong></p>
</li>
<li><p>var、let：固定不变的类型（由初始值确定），值可以变动，但是<strong>初始化之后，此变量就已经与与推测的类型绑定，再赋予其他类型的值的时候会报错</strong>，<strong>如果只声明不初始化，也不显示指定类型，默认指定为any类型</strong>，如下所言：</p>
</li>
<li><p><strong>若只声明而不进行初始化，则建议显式声明类型<code>let number1: number;</code>，否则变量是any类型，就失去了类型机制的检查作用（注意此处说的类型检查是失去了对此any类型的变量进行赋值时的类型检查，当any类型的变量被赋值到其他变量的时候，是会有类型检查的，详见any部分的说明）</strong></p>
</li>
<li><p>若使用<code>:</code>显式指定了类型则使用指定的类型而不是推测的类型</p>
</li>
<li><p>使用原则</p>
<ol>
<li><p>除了初始化的场景，还有诸多场景中，类型猜测机制都会其作用，很强大，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;    <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,    <span class="attr">age</span>: <span class="number">23</span>,    <span class="attr">hobbies</span>: [<span class="string">&#x27;study&#x27;</span>, <span class="string">&#x27;game&#x27;</span>]&#125;;<span class="comment">// console.log(person) for (let hobby of person.hobbies) &#123;    // hobby为string类型    console.log(hobby.toUpperCase());&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>应当可以这么认为，只有类型猜测机制无法作用的地方需要显式指定类型，比如函数参数和函数类型以及变量只声明而不初始化的场景；以及开发者明确需要进行类型限制的场景（不能靠猜，要明确确定，只有进行显式的初始化的时候是明确类型的，但是如果是间接初始化的时候，并不清楚所赋值的类型，此时必须显式指定变量的类型才行（其实类似于函数形参的使用场景）），ts能自动推测并给予必要的类型检查</strong></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Object类型表示<strong>非原始类型</strong>,所谓的非原始类型就是指除了undefined null symbol string number boolean 之外的类型</p>
<ol>
<li>object类型的类型声明是这样的<code>let obj:&#123;a:number;c:string&#125; = &#123;a:12,c:&quot;李佳&quot;&#125;</code><ol>
<li>可以<code>let obj:object = &#123;a:12,c:&quot;李佳&quot;&#125;</code>，但是如此写的话会丢失object的细节，ts也不知道obj变量的具体的属性有哪些<ol>
<li> <strong>因此导致使用<code>.</code>索引属性名时，IDE不会有明确的属性名提示</strong></li>
<li> <strong>因此导致即便索引了确实存在的属性名也会报错</strong></li>
</ol>
</li>
<li> <strong>object的精确类型的形式不是一个js object实例，并且分隔号是<code>;</code>不是<code>,</code>（虽然用<code>,</code>好像也可以）</strong></li>
</ol>
</li>
<li> Object类型也支持<code>type inference</code>，<strong>并且类型推测得到的是精确地类型而不是objecct</strong></li>
<li> 关于Symbol类型，参考<a target="_blank" rel="noopener" href="https://typescript.bootcss.com/symbols.html">官网</a></li>
</ol>
</li>
<li><p>Array  数组(有两种定义方式，其实对应两种数组的类型表达)，<strong>补补基础：js中的数组可以混合存储多种类型的数据</strong></p>
<ol>
<li><p>let list: <strong>元素类型[]</strong> = […] 比如: <code>let list: number[] = [1,2,3,4]</code></p>
<ol>
<li><p>type: number[]</p>
</li>
<li><p>混合数组类型： (number|string)[] （<strong>联合类型的数组，注意联合类型本身应与中括号用小括号隔离</strong>）</p>
<ol>
<li><p>当然此处也可以灵活使用any类型，但是谨慎使用any，因为使用any会使代码退化到js </p>
</li>
<li><p>混合类型的数组的类型推断就是联合类型的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const array: (string | number | boolean | Date)[]const array = [1,&#x27;&#x27;,true,new Date()]; </span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>使用数组泛型 let list:Array&lt;元素类型&gt; = […] 比如: <code>let list: Array&lt;number&gt; = [1,2,3]</code></p>
<ol>
<li>type: Array<number></li>
<li><strong>泛型也可以是联合类型</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>元组 Tuple （元组类型以下的类型都不是js原生支持的类型，而是ts引入的类型）</p>
<ol>
<li><p>元组类型与Array的区别与相似之处在于：</p>
<ol>
<li><strong>元组指定特定的长度与特定的类型（位置对应）</strong></li>
<li><strong>元组的使用场景显然是要求对于数据结构要求比较严格的场景中</strong></li>
<li>元组对于元素的访问方式与数组是一样的</li>
<li><strong>元组类型本质上与数组类型一样，其相关的限制实际上是ts添加的，但是编译成的js中元组实际上就是数组</strong></li>
</ol>
</li>
<li><p>如果直接初始化，ts的类型推测并不能区分出Array（或者是联合类型的Array）与元组，所以一般需要显式设定元组类型，如下案例所示</p>
<ol>
<li>联合类型的type是：<code>(string|number)[]</code></li>
<li>元组的类型是：<code>[string, number]</code></li>
</ol>
</li>
<li><p><strong>元组的使用中有一些坑</strong>，即对于元组与联合类型的数组的区分不是很强：</p>
<ol>
<li><p>元组的长度限制仅限于初始化，如果使用push方法，并不会有限制（仅有类型上的限制，但是没有元组长度的限制）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [number,string] = [<span class="number">1</span>,<span class="string">&#x27;123&#x27;</span>];tuple[<span class="number">0</span>] ++ ;tuple.push(<span class="string">&#x27;2&#x27;</span>);<span class="comment">// [2,&#x27;123&#x27;,&#x27;2&#x27;]console.log(tuple)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Enum 枚举</p>
<ol>
<li><p>枚举的含义实际上就是一个从0开始编号数组,数组里的每一个值都有自己的名字,可通过名字获得值,也可以通过值获得名字</p>
</li>
<li><p>默认从0开始编号,但是也可以自己指定（通过制定第一个成员的值即可）</p>
</li>
<li><p>注意枚举中中的各个项的本质就是被编号的几个全局Enum类型常量</p>
</li>
<li><p><strong>实际上是在创建自定义的类型（通过鼠标查看是，其类型不是enum二十自定义的名字），所以此变量应该首字母大写</strong></p>
<ol>
<li> <strong>除了自定义的enum类型名应该首字母大写，类型中定义的常量应该全部大写</strong></li>
<li> 设置定义的enum常量的值也可以是string，并且可以混用，enum的本质就是一个有实际意义的label而已</li>
<li> 如下的案例涉及到了enum常量与其对应的值的相互索引，注意不是位置索引（本来也不是数组），是内容索引</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;RED = <span class="number">1</span>,GREEN=<span class="number">3</span>,BLUE&#125;<span class="built_in">console</span>.log(Color[<span class="number">4</span>]) <span class="comment">// BLUEconsole.log(Color.red) // 1</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Any</p>
<ol>
<li><p>足够灵活，但谨慎使用</p>
</li>
<li><p>Any类型的变量不会在编译阶段被类型检查,适用的情况包括<code>用户输入,第三方代码库,现阶段不清楚的变量类型</code>，<strong>除以上三种情况，其他情况应该禁止使用any类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果指定any类型，下边可以索引任何属性，哪怕是不存在，也不会报错，因为不会对person的相关操作执行类型检查const person:any = &#123;    name: &#x27;lee&#x27;,    age: 23,    hobbies: [&#x27;study&#x27;, &#x27;game&#x27;],    role: Role.ADMIN&#125;;console.log(person.role);</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>如果实在不知道用哪个类型就用unknown类型即可，不推荐用any</strong></p>
</li>
<li><p><strong>any类型的变量只是在对自身进行赋值的时候，没有类型检查，可以赋予任意类型的值，但是当其被用作赋值给其他变量时：</strong></p>
<ol>
<li><p><strong>一旦对any类型的变量赋值，变量的类型就自动迁移到对应的值的类型（也属于类型猜测机制），并且当次变量被赋予到其他变量时进行对应的类型检查</strong></p>
</li>
<li><p><strong>如果any类型的变量只声明，而没有进行赋值初始化，当其被赋值到其他变量时，其类型自动转为undefined</strong></p>
</li>
<li><p>只在被用到时发生自动类型转换，其余场景自动从特定的类型转化为any</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时为any类型let userName;// 此时为any类型userName = &#x27;jia&#x27;;// 此时为any类型userName = true;// 此时为boolean类型 报错let var2:string = userName;// 此时为any类型userName = &quot;23&quot;;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>在从数据库或者前后端获取数据的时候，一般数据的类型都是type类型，此时并没有有效的类型支持，但是如果有预先设定好的数据格式，作为开发者，应该告诉ts具体的数据格式，从而协助ts为开发者提供更好的类型支持，并且如果数据格式比较复杂，可以只声明开发用到的属性结构，保持兼容即可（参考Google Map项目）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RequestHandler&#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;<span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&#x27;../models/Todo&#x27;</span>;<span class="keyword">const</span> TODOS: Todo[] = [];<span class="keyword">export</span> <span class="keyword">const</span> getTodoListHandler:RequestHandler = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;    <span class="comment">// 自定义前端传来的数据结构为&#123;text: string&#125;     const text = (req.body as &#123;text: string&#125;).text;    let todo = new Todo(Math.random().toString(), text);&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Union联合类型</p>
<ol>
<li><p>此类型适用在函数参数等需要满足多个可选类型的变量定义中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">var1: number|string, var2: number|string</span>) </span>&#123;		<span class="comment">// 不得不引入运行时类型检查，实际上此运行时类型判断即为ts的特性之一 type guard    if (typeof var1 === &#x27;number&#x27; &amp;&amp; typeof var2 === &#x27;number&#x27;) &#123;        // 如果直接相加，会报错，因为ts只检测到了对Union类型使用+，而不会探究Union内部的类型，所以        // 暂时引入类型判断(type guard)        return var1 + var2;    &#125; else &#123;        // 可以对Union类型使用toString 方法，因为不管其到底是Union内部的哪一种类型，都有此方法        return var1.toString() + var2.toString()    &#125;    &#125;console.log(add(1, 2));console.log(add(&#x27;李&#x27;, &#x27;佳&#x27;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意上述的运行时的类型判断即为type guard，<strong>应是对于ts的开始时类型检查的补充，使得ts应对联合类型这样的复杂类型时，能够保证进行精准的类型分类，对于不同的具体类型，执行具体的差异化的操作</strong></p>
<ul>
<li><p>除了使用typeof进行类型检查外（<strong>适用于对于基础类型的检查</strong>），还有以下的进行type guard的方法（<strong>实际上使用typeof只能判断string number boolean这几个基础类型，其余的类型（包括自定义类型）只能识别为object，而无法得知具体细节，比如属性等</strong>）</p>
<ul>
<li><p>if in （普通的type(object字面量)或者interface或者class）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Admin = &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;type Employee = &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;type Combainable = Admin | Employee;<span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">p: Combainable</span>) </span>&#123;    <span class="comment">// 共有属性    console.log(p.name);    // type guard    // ts检查到此判断后，认识到当运行到此if中时，Comabinable类型的实例p一定是Admin类型，并拥有属性privileges   // 需要注意的是，此属性字符串即便写错了也会被检查出来，因为不允许任意写，一定必须是Combainable类型中可能存在的属性之一    if (&#x27;privileges&#x27; in p) &#123;        console.log(p.privileges);    &#125;    &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>instanceof （仅对于class来说）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;    drive () &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;the car is driving&#x27;</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Truck</span> </span>&#123;    drive () &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;the car is driving&#x27;</span>);    &#125;    loadCargo (amount: number) &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;amount loading: &#x27;</span> + amount);    &#125;&#125;type Vechile = Car | Truck;<span class="keyword">let</span> car = <span class="keyword">new</span> Car();<span class="keyword">let</span> truck = <span class="keyword">new</span> Truck();<span class="function"><span class="keyword">function</span> <span class="title">useVechile</span> (<span class="params">v: Vechile</span>) </span>&#123;    v.drive();    <span class="comment">// class中的方法也可以使用if-in的方式判断    // if (&#x27;loadCargo&#x27; in v) &#123;    //     v.loadCargo(12);    // &#125;    // 但是更优雅的方式是使用instanceof    if (v instanceof Truck) &#123;        v.loadCargo(13);    &#125;&#125;useVechile(car);useVechile(truck);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof是typeof的升级版，可以使用自定义class判断，但是仅限于class，因为实际上<strong>无论是typeof还是instanceof都是在js的运行时环境中使用的，ts并不能使用其进行类型检查，只是使用type guard将类型检查转移到了运行时，在js中instanceof的工作原理是使用构造器函数进行匹配，因此在ts中只能使用class（编译成的js中使用构造器函数实现class）而不能使用interface进行类型检查（因为interface是完全的ts概念，不会在js中以任何形式体现）</strong></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000730982">typeof与instanceof的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><p>type guard除了上述的几种类型外，还有一个特殊的方式，就是<strong>Discriminated Unions（可辨识类型）</strong></p>
<ul>
<li><p>对于interface与class都可用，与if-in相比的进步在于，不用写一堆类型的字符串名字，容易写错</p>
</li>
<li><p>本质上就是在多个interface或者class内部定义一个相同的属性，此属性用来描述此类型（类型的字面量名字），可以使用此属性来分辨类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;    <span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>;    flyingSpeed: number;&#125;interface Horse &#123;    <span class="attr">type</span>: <span class="string">&#x27;horse&#x27;</span>;    runningSpeed: number;&#125;type Animal = Bird | Horse;<span class="function"><span class="keyword">function</span> <span class="title">animalRun</span> (<span class="params">a: Animal</span>) </span>&#123;    <span class="keyword">switch</span> (a.type) &#123;        <span class="keyword">case</span> <span class="string">&#x27;bird&#x27;</span> :            <span class="built_in">console</span>.log(<span class="string">&#x27;bird flying speed: &#x27;</span> + a.flyingSpeed);            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="string">&#x27;horse&#x27;</span>:            <span class="built_in">console</span>.log(<span class="string">&#x27;horse running speed:&#x27;</span> + a.runningSpeed);            <span class="keyword">break</span>;    &#125;&#125;animalRun(&#123;<span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>, <span class="attr">flyingSpeed</span>: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>type属性实际上会和对应的类型在ts层面绑定，当使用type属性的时候，只会提示Bird或Horse</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>literal type 也就是字面量类型</p>
<ol>
<li><p>最常见的字面量类型就是使用const定义的变量的类型，这样的常量的类型不是<code>const</code>，而是常量对应的字面量</p>
</li>
<li><p><strong>字面量类型一般与连个类型共同使用，因为如果只是有一个可选常量的话，硬编码即可，或者有比较多的可选常量的话，理应选择enum</strong></p>
</li>
<li><p>在下面的案例中，假设要定义以何种格式返回结果（number or string）（换种说法就是引入返回类型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">var1: number | string, var2: number | string, resultFormat:<span class="string">&#x27;as number&#x27;</span>| <span class="string">&#x27;as string&#x27;</span></span>) </span>&#123;  <span class="keyword">let</span> result;  <span class="keyword">if</span> (<span class="keyword">typeof</span> var1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> var2 === <span class="string">&quot;number&quot;</span>) &#123;    result = var1 + var2;  &#125; <span class="keyword">else</span> &#123;    result = var1.toString() + var2.toString();  &#125;  <span class="keyword">if</span> (resultFormat === <span class="string">&#x27;as string&#x27;</span>) &#123;      <span class="keyword">return</span> result.toString();  &#125; <span class="keyword">else</span> &#123;    <span class="keyword">return</span> + result;  &#125;&#125;<span class="comment">// 3console.log(add(1, 2, &#x27;as string&#x27;));// 12console.log(add(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;as number&#x27;));// 李佳console.log(add(&quot;李&quot;, &quot;佳&quot;, &#x27;as string&#x27;));</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型别名</p>
<ol>
<li>部分类型的名字比较长，可以设置类型别名：<code>type $&#123;自定义类型名&#125;= $&#123;其他类型&#125;</code>，例如：<code>type Combinable = number |string</code></li>
</ol>
</li>
<li><p>void（<strong>函数返回值类型的引入</strong>）</p>
<ol>
<li>ts同样可以使用type inference推测出函数的返回值，也可以使用如下方式显式指定，但是还是同样的道理，如无必要，尽量使用type inference机制</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>void类型的变量只能被赋值为null或者undefined</p>
</li>
<li><p><strong>比较神奇的一点是：当尝试打印void返回值类型的函数的返回值的时候会得到undefined值</strong></p>
</li>
<li><p>函数无返回值的时候通常用void类型做返回值类型</p>
</li>
<li><p>实际上也可以使用undefined作为函数返回值类型，但与void的含义不同，前者表示返回一个空值，后者表示不返回任何东西，<strong>或者说可以在函数体返回任意值，但是函数外部不会接收到此返回值也不在意返回值是什么（这个描述仅在返回值是void的情况下成立，在返回值是void与其他类型的联合类型的情况下不成立）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFormat</span> (<span class="params">num: number</span>):<span class="title">undefined</span> </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;The result is &#x27;</span> + num);    <span class="comment">// 没有这一句就会报错    return;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);    return;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);    return num;&#125;function printFormat (num: number):void &#123;    console.log(&#x27;The result is &#x27; + num);&#125;// error 只能无return或return;或return number类型数据，而不是其他类型的数据function printFormat (num: number): void|number  &#123;    console.log(&#x27;The result is &#x27; + num);  	return &#x27;hello&#x27;;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>null 同undefined</p>
</li>
<li><p>undefined</p>
<ol>
<li><strong>null和undefined是所有类型的子类型,可以赋值给所有类型的变量,但是当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自所属的同名类型。</strong></li>
</ol>
</li>
<li><p>Function函数类型</p>
<ol>
<li><p>这里涉及到函数编程的概念，函数本身可以被当做值赋予给某变量（或者是用在回调函数中），正因如此，在ts的类型系统中需要引入函数类型这一概念</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;<span class="function"><span class="keyword">function</span> <span class="title">printFormat</span> (<span class="params">num: number</span>):<span class="title">undefined</span> </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;The result is &#x27;</span> + num);    <span class="keyword">return</span>;&#125;printFormat(add(<span class="number">1</span>, <span class="number">2</span>));<span class="keyword">let</span> var1 = add;printFormat(var1(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>和Object类型一样，function类型可以使用<code>Function</code>（大写）指定，也可以明确指定函数的函数声明（参数）+返回值类型作为其函数类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">n1: number, n2: number</span>): <span class="title">number</span> </span>&#123;    <span class="keyword">return</span> n1 + n2;&#125;<span class="comment">// 注意使用箭头分隔返回值类型，类似于箭头函数的形式，参数列表中的参数名任意// 表示var1变量可以接受任意的有两个number类型的参数并且返回number类型的值的函数let var1: (a: number, b: number) =&gt; number = add;</span></span><br></pre></td></tr></table></figure></li>
<li><p>回调函数的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要随便使用关键字，比如var做参数名function addAndHandle (n1: number, n2: number, cb:(n: number) =&gt; void) &#123;    const result = n1 + n2;    cb(result);&#125;// 使用箭头函数addAndHandle(1, 2, (n) =&gt; &#123;    console.log(&#x27;result is &#x27; + n);&#125;);</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>unknown类型</p>
<ol>
<li><p>常用在接受用户输入，在赋值的操作上与any类型类似，可以为any类型的变量赋予任意类型的值，但是与any不同的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo:unknown;<span class="keyword">let</span> userName;userInfo = <span class="number">12</span>;userInfo = <span class="string">&#x27;lee&#x27;</span>;userName = <span class="string">&#x27;jia&#x27;</span>;<span class="keyword">let</span> var2:string = userName;<span class="comment">// Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;var2 = userInfo;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以发现any类型的变量可以赋值给特定类型的变量（<strong>如果any类型的变量之前做赋值的时候已经前移到了此特定的类型中</strong>），但是对于unknown类型的变量，因为不确定变量，所以肯定不能随意给特定类型的变量赋值</li>
</ul>
</li>
<li><p>相对于any类型，当不明确类型的时候更推荐使用unknown类型：</p>
<ol>
<li><p>unknown类型有更明确的类型检查，而不是完全不检查</p>
</li>
<li><p>可以加入额外的类型判断机制，以对unknown进行下一步的操作，目的更明确，行为也更安全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo:unknown;<span class="keyword">let</span> userName;userInfo = <span class="number">12</span>;<span class="comment">// userInfo = &#x27;lee&#x27;;userName = &#x27;jia&#x27;;let var2:string = userName;if (typeof userInfo === &#x27;string&#x27;) &#123;    var2 = userInfo;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>never类型</p>
<ol>
<li><p>表示永远不存在的值的类型</p>
</li>
<li><p>never常做函数的返回值类型,使用的依据是:<strong>返回never的函数必须存在无法达到的终点</strong></p>
<ol>
<li><p>什么叫做函数存在无法到达的重点呢,意思就是这个函数执行的时候,就不可能执行到末尾,<strong>比方说函数内部是一个while死循环,比方说函数内部恒有异常抛出,而无法执行到函数的末尾</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateError</span> (<span class="params">message: string, code: number</span>) </span>&#123;    <span class="keyword">throw</span> &#123;<span class="attr">message</span>: message, <span class="attr">errCode</span>: code&#125;;&#125;<span class="built_in">console</span>.log(generateError(<span class="string">&#x27;something error occured!&#x27;</span>, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用鼠标查看函数类型的时候，其返回值是void，但是打印后并没有undefined值，这意味着其根本无法到达函数结束的位置，所以返回值类型实际上是<code>never</code></li>
<li>在这种场景下，因为ts预测返回值类型是void类型，更明确的做法是，显式指定为never类型</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>类型断言,实际上就是把不确定类型的变量(比如 any或者null)转为其他明确类型的过程,<strong>表明程序员自己明确这个变量的类型,只是对于编译器的一个明确而已,对运行过程无影响</strong>，最典型的应用场景就是对于HTML元素的判断（ts不会分析html，所以在ts中进行DOM操作时，常常需要用到类型断言）。</p>
<ol>
<li>尖括号</li>
<li>as</li>
</ol>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> demo:<span class="built_in">any</span> = <span class="string">&#x27;123&#x27;</span><span class="keyword">let</span> len:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt; demo).lengthconsole.log(len)<span class="keyword">let</span> len1:<span class="built_in">number</span> = (demo <span class="keyword">as</span> <span class="built_in">string</span>).lengthconsole.log(len1)<span class="comment">// 类型断言是as ..前边的！也是一种断言，表示其前边的对象肯定存在，非null，如果不确定非null，则加上显式的if check运行时判断，ts也能理解并不再报错// as的作用是告诉ts此dom对象是HTMLInputElement对象，有value属性，所以下方调用value属性不会报错const input1 = document.getElementById(&quot;num1&quot;! as HTMLInputElement; // const input1 = &lt;HTMLInputElement&gt; document.getElementById(&quot;num1&quot;)!;console.log(input1.value);</span></span><br></pre></td></tr></table></figure>

<h2 id="ts编译器的配置"><a href="#ts编译器的配置" class="headerlink" title="ts编译器的配置"></a>ts编译器的配置</h2><ul>
<li><p>watch mode</p>
<ul>
<li>使用light-server 解决了开发中不得不刷新页面查看页面设置的问题，但是每一次修改ts文件，都需要手动执行<code>tsc **.ts</code>才能得到编译的结果，因此引入ts编译器的监听模式，监听工程内文件的内容变动，自动触发编译过程</li>
<li><code>tsc **.ts -w</code>或<code>tsc **.ts --watch</code>使用监听模式，监听某特定文件的变动，此时命令行会阻塞，不要关闭<ul>
<li><strong>注意这种环境下就不要打开vscode的自动保存模式了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>配置文件</p>
<ul>
<li><p>有没有更灵活的配置方式呢？只监听一个文件实际上也不常用，一个项目中可能会编辑多个源文件    </p>
</li>
<li><p>在工程所在项目中执行<code>tsc --init</code>告诉编译器，此文件夹就是ts项目的根目录，并创建一个<code>tsconfig.json</code>作为配置文件</p>
</li>
<li><p>在根目录执行<code>tsc</code>会编译项目中所有的ts文件，<code>tsc -w</code>会监听项目中的所有的ts文件的文件变动，以触发重新编译</p>
</li>
<li><p>注意，配置文件的配置只会在使用<code>tsc</code>命令是生效，而不会在<code>tsc **.ts</code>这种编译单个文件而不是编译整个工程的命令中生效</p>
</li>
<li><p>配置文件详述：</p>
<ul>
<li><p>配置文件的可配置项肯定是一直更新的，最权威的最新的解释，参考<a target="_blank" rel="noopener" href="https://www.staging-typescript.org/tsconfig">官方网站</a></p>
</li>
<li><p>exclude</p>
<ul>
<li><p>默认tsc把项目目录下的所有的ts文件视为项目源文件，可以使用此配置排除特定的ts文件，此后，执行<code>tsc</code>不会对特定文件进行编译操作</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    ..  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;**/*.dev.ts&quot;</span>  ]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用通配符</li>
<li>一般会把<code>node_modules</code>文件夹排除，<strong>但是这是默认的配置</strong>，如果显式指定此key的话，应带上<code>node_modules</code></li>
</ul>
</li>
</ul>
</li>
<li><p>include</p>
<ul>
<li>将特定文件添加到项目中    </li>
<li><strong>默认是添加根目录中的所有文件，所以如果显式配置此节点的话，需要把项目中所有的文件列到此节点中（有点麻烦）</strong></li>
<li>如果include与exclude出现冲突，文件的包含情况是：<strong>include - exclude</strong></li>
</ul>
</li>
<li><p>files</p>
<ul>
<li>类似于include，但是只能添加单个文件，而不能添加文件夹，因为适用于小项目，实际上并不常用</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>此key时最关键的部分，可以定义具体的编译行为</p>
<ul>
<li><p>target 编译为哪个版本的js</p>
</li>
<li><p>module 模块的组织方式</p>
</li>
<li><p>lib：<strong>默认是被注释的，但是默认会加载DOM Api，以及target中设置的js版本中的一些默认对象方法</strong>，如果打开注释自定义，默认的就会失效，比方说要写nodejs的代码，就不用加载dom</p>
<ul>
<li>默认情况下，lib应该包含以下几个包（全部用标识符标，而不会是路径什么的）</li>
<li>“DOM”</li>
<li>“ES6”</li>
<li>“DOM.Iterable”</li>
<li>“ScriptHost”</li>
</ul>
</li>
<li><p>allowJS，对js结尾的文件也进行编译</p>
</li>
<li><p>checkJs，对js结尾的文件进行审查并在编译时进行错误报告</p>
</li>
<li><p>jsx React框架设置相关</p>
</li>
<li><p>declaration 在编写第三方lib的时候，设置为true会自动生成.d.ts的manifest文件</p>
</li>
<li><p>declarationMap与declaration类似</p>
</li>
<li><p><strong>sourceMap</strong>，针对ts文件生成.map文件，其作用在于：在Chrome控制台的Source中进行源代码的debug时，默认只能看到js，并只能在js中进行debug，有了对应的.map文件后，浏览器就能展示对应的ts文件，并能在ts上进行断点调试</p>
</li>
<li><p>outFile 暂时未说明</p>
</li>
<li><p>outDir  将输出导入到指定文件中</p>
</li>
<li><p>rootDir</p>
<ul>
<li>以上两个的设置目的为：<br>在实际工程中常常把js与ts分开放置，ts放在src文件夹，编译出的js放在dist文件夹，但是默认情况下，js会编译到ts的同目录中，因此可以在outDir中进行配置</li>
<li>outDir会维持与源代码所在目录的一样的目录结构</li>
<li>rootDir设置的就是源代码路径，ts只会编辑此目录下的ts文件，其作用也可以使用include和exclude实现</li>
</ul>
</li>
<li><p>removeComments 编译好的js文件中不会携带ts文件中的注释</p>
</li>
<li><p>noEmit 只进行编译检查，但是不创建js结果文件</p>
</li>
<li><p>downlevelIteration 当target是ES5甚至ES3时，对于for-of的支持可能有问题，此时开启此选项来获得更详细的编译信息 </p>
</li>
<li><p>noEmitOnError 默认为false，此时，即便es编译出错，也会产生对应的js文件，应用场景在于，开发者明确知道即便ts异常报错，但是ts编译器担心的事情是肯定不会发生的，所以直接产出js也可以（其实是不太好的做法）；如果设置为true，编译出错则不会有对应的js产出（推荐）</p>
<ul>
<li>注意，设置为true后，一个文件编译失败，整个工程的文件都不会有js产出</li>
</ul>
</li>
<li><p>strict 执行严格的类型检查</p>
<ul>
<li><p>默认为true，设置此项目为true相当于设置所有的<code>Strict Type-Checking Options</code>选项为true，如果要单独进行精细控制的话，不必要把此项设置为false，直接在下边的选项中配置false即可</p>
<ul>
<li><p>noImplicitAny，如果在函数形参中不指定类型（any类型），就会报错，但是对于变量的any类型则不会报错，这是因为，变量的类型是可以跟踪和自动转化的，但是对于函数形参的类型并不能自动跟踪，并且跟踪也无意义，因为不同的类型在函数中都应有不同的行为，或者根本只能接受特定类型的形参。</p>
<ul>
<li><p>并不是所有的函数定义中的形参不指定类型都会报错，比如下边的案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);<span class="keyword">if</span> (button) &#123;    <span class="comment">// ts明确知道 addEventListener函数执行回调函数时的传入的参数值的类型，所以不需要自己在回调函数中特意指定参数类型    button.addEventListener(`click`, event =&gt; console.log(event));&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>strictNullChecks对于可能为null的变量报错，比如前边例子中的button对象的获取，因为不能确定趋势存在此button，所以是潜在的null，因此报错，<strong>可以使用<code>!</code>断言符号进行非null的断言声明以避免此error，或者自己并不十分肯定不为null，可以添加if检查，此时ts也会检查到风险能被控制住，亦不会报错</strong></p>
</li>
<li><p>alwaysStrict 生成的js文件使用strict模式（js文件开头会有<code>&quot;use strict&quot;;</code>）</p>
<ul>
<li>关于strict模式，参考<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-strict.html">菜鸟网站的介绍</a></li>
</ul>
</li>
<li><p>strictFunctionTypes 与class和interface相关</p>
</li>
<li><p>strictBindCallApply 与bind函数、call函数和apply函数相关，这三个函数用来更改js中的运行时环境，也就是更改this指向的对象，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coco1s/p/4833199.html">具体参考此篇文章</a>，印象笔记也有对应的收藏</p>
<ul>
<li><p>此配置用来检查，以上三个函数的调用中，是否传入了合适的参数，举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saySomething</span> (<span class="params">message: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&quot;say: &quot;</span> + message);&#125;<span class="comment">// 此处第二个参数如果不与saySomething的参数匹配就会报错saySomething.call(null, &#x27;hello&#x27;);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>strictPropertyInitialization 与class和interface相关</p>
</li>
<li><p>noImplicitThis 和this相关</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Additional Checks相关，此部分的配置可以用来提高代码质量，而并非严格的检查，比如不能有未使用的局部变量等等</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TS-中的支持的Modern-JS特性"><a href="#TS-中的支持的Modern-JS特性" class="headerlink" title="TS 中的支持的Modern JS特性"></a>TS 中的支持的Modern JS特性</h3><ul>
<li>所谓的Modern JS指的是ES6或者其他更新版本的js</li>
<li>如果要查看Modern JS 语法或者关键词在何种开发、编译环境和浏览器环境的支持程度，可以查看<a target="_blank" rel="noopener" href="https://kangax.github.io/compat-table/es6/">此网站</a></li>
<li><strong>在ts中介绍modern js特性的意义在于知晓ts支持这些新特性，并且也能将其编译成旧版本的不支持这些特性的js脚本，以支持在旧版本的浏览器中运行</strong></li>
</ul>
<ol>
<li><p>使用let代替var</p>
<ol>
<li><p>var的作用域是全局作用域（定义在函数外部）或者函数作用域（定义在函数内部）</p>
</li>
<li><p>let的好处就是引入了块级作用域（全局作用域与函数作用域与var类似）,看看下边的令人匪夷所思的js代码吧</p>
</li>
<li><p>一个需要更改的操作就是之前经常在var定义之前就去访问变量,<strong>但是在let定义的时候,在其代码块内,声明语句之前就是暂时性死区,不能访问</strong>但是也有看似特殊的情况</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error console.log(a);function demo ()&#123;    // 无error    return a;&#125;// 下边定义的a与函数中的a位于同一个作用域,所以函数内可以访问,并且函数在每调用的时候可以设计为访问变量,但是必须确保函数调用的时候,变量已经定义好了let a: number = 1;// 1console.log(demo());</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在同一个块作用域里,只能定义一次变量,不能重复定义同名变量,但是在嵌套的块作用域里可以有同名的变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;&#123;    <span class="keyword">let</span> a = <span class="number">12</span>;    <span class="comment">// 12    console.log(a);&#125;// 0console.log(a);</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>let变量在循环体中的每一次迭代都是一个新的环境</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);&#125;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>用var定义的变量,在每一次迭代的环境都会被保存下来,因此每次执行setTimeout函数时,延迟时间都是正常的,但是循环结束后i已经是10了此时延时到了执行的时候就会打印一堆10出来</p>
</li>
<li><p>用let定义的变量每次迭代都会有一个独有的环境,不会随着i的变化而进行更新保留,所以打印输出的是0-9</p>
</li>
</ol>
</li>
<li><p>const</p>
<ol>
<li> const修饰符<strong>实际上其作用域规则与let一样（同样拥有块作用域）</strong>,但是其修饰的变量只能被赋值一次</li>
<li> <strong>如果const修饰的是一个对象的话,那么实际上只要对象的引用地址不变即可,对象内部的属性的值是可以任意改变的, 当然也可以设置对象成员是只读</strong></li>
<li> <strong>什么时候使用let,什么时候使用const?就跟Java中使用private一样,没必要访问/改变的全部弄成const类型</strong></li>
</ol>
</li>
<li><p>箭头函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b;<span class="comment">// 注意此处，当箭头函数的参数只有一个，并且要使用如下的简化写法的时候，不能在参数处直接指定类型，而必须在函数变量处指定类型// 除非ts明确调用函数的时候，函数的参数的类型，比如下边的button的案例const printS: (msg: string | number) =&gt; void = messgae =&gt; console.log(messgae);printS(addFunc(1, 2));const button = document.querySelector(&#x27;button&#x27;);if (button) &#123;    // ts明确知道 addEventListener函数执行回调函数时的传入的参数值的类型，所以不需要自己在回调函数中特意指定参数类型    button.addEventListener(`click`, event =&gt; console.log(event));&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数参数默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number=<span class="number">1</span>, b: number = <span class="number">2</span></span>) =&gt;</span> a + b;<span class="built_in">console</span>.log(addFunc(<span class="number">2</span>, <span class="number">3</span>));<span class="built_in">console</span>.log(addFunc());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>格式就是在形参后加上<code>= 默认值</code>即可</p>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>可以全部参数都赋予默认值，但是如果只有部分参数赋予默认值的情况下，必须是后边的参数赋予默认值，而不是排在前边的，其原因在于<strong>实参是按照参数顺序对应到形参的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function">(<span class="params">a: number=<span class="number">1</span>, b: number</span>) =&gt;</span> a + b;<span class="comment">// okconsole.log(addFunc(2, 3));// error 因为a 被赋予2 但是b没有默认值，应该也被赋予一个值，但是这样的话默认值的设置也没有意义了console.log(addFunc(2));</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>除了使用上述的方式实现函数参数默认值的设置外，还有另外一种类似的方式，即使用解构来实现函数参数默认值（严格来说不是函数参数，但是形式类似，所以就放在这）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?:用来表示不确定属性是否存在,或者说在类型检查中不强求有此属性,或者说是设置属性为可选属性// 可以在接口 抽象类或者自定义类型中使用// 可以在属性上使用，也可以在方法上使用function func (obj:&#123;a:string,b?:number&#125;):void &#123;    // 使用结构间接设定了默认值    // 相当于ab声明的时候，b先初始化再赋值，而a是声明粥通过解构进行初始化    let &#123;a,b=12&#125; = obj    console.log(a,b)&#125;func(&#123;a:&quot;李佳&quot;,b:12&#125;) // 李佳 12func(&#123;a:&quot;李佳&quot;&#125;) // 李佳 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>展开</p>
<ol>
<li><p>使用<code>...</code>来执行展开操作，或者说<strong>从数组或对象中获取值，将数组或对象中的成员拆散为单个的成员，也可以理解为把数组和对象拆解为以逗号分隔的对个成员对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;cook&#x27;</span>, <span class="string">&#x27;play&#x27;</span>];<span class="comment">// 方法0 在定义新array时放入旧的arrayconst newarray = [&#x27;learn&#x27;, ... array];// 目的为将array导入到newarray中// 方法1newarray.push(array[0], array[1]);// 方法2newarray.push(... array);const person1 = &#123;    name: &#x27;lee&#x27;,    age: 20&#125;;// 复制上边的person1对象，注意是实体赋值而不是指针的赋值const person2 = &#123; ... person1&#125;;console.log(person2);</span></span><br></pre></td></tr></table></figure></li>
<li><p>展开相对于解构就变得索然无味了，但是还是有不少的坑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj:&#123;<span class="attr">a</span>:number,<span class="attr">c</span>:string&#125; = &#123;<span class="attr">a</span>:<span class="number">12</span>,<span class="attr">c</span>:<span class="string">&quot;李佳&quot;</span>&#125;<span class="keyword">let</span> obj1 = &#123;...obj,<span class="attr">a</span>:<span class="number">22</span>&#125; <span class="comment">// 后边的a属性值为22会覆盖展开后的a属性为12// a: 22 c: &quot;李佳&quot;console.log(obj1);class Demo &#123;    a:string = &quot;李佳&quot;    function ():void &#123;        console.log(this.a)    &#125;&#125;let demo:Demo = new Demo()let demo1 = &#123;...demo&#125;console.log(demo1) //你会发现方法体丢了，只剩下属性a</span></span><br></pre></td></tr></table></figure></li>
<li><p>将展开操作符作用与函数形参的时候，就能实现函数形参的参数扩展符，<strong>此过程可以视作是展开的逆操作，即把以逗号分隔的参数打包为数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...会将调用此函数时传入的以逗号相隔的参数打包成数组并赋予形参，然后在内部处理此数组const addFunction = (...numbers: number[]) =&gt; &#123;    let result = 0;    for (let num of numbers) &#123;        result += num;    &#125;    return result;&#125;console.log(addFunction(1,2,3,4,5,6,7));const addFunction = (name: string, ...numbers: number[]) =&gt; &#123;    let result = 0;    for (let num of numbers) &#123;        result += num;    &#125;    return result;&#125;console.log(addFunction(&#x27;Lijia&#x27;,1,2,3,4,5,6,7));const addFunction = (...numbers: number[]) =&gt; &#123;		// 使用数组的reduce方法更加简洁    return numbers.reduce((curResult, curValue) =&gt; &#123;        return curResult + curValue;    &#125;, 0);&#125;console.log(addFunction(1,2,3,4,5,6,7));// 明确需要限定个数的参数时，也可以使用元组类型const addFunction = (...numbers: [number, number, number]) =&gt; &#123;		// 元组类型本质上与数组类型一样    return numbers.reduce((curResult, curValue) =&gt; &#123;        return curResult + curValue;    &#125;, 0);&#125;console.log(addFunction(1,2,3));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，<strong>当在函数定义中发现此<code>...</code>时，如上边的案例，不要把参数类型当做数组，函数接受的应该是以逗号分隔的一系列参数，而不是参数数组</strong></li>
</ul>
</li>
<li><p>在数组或函数参数中使用展开语法时, 该语法只能用于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator">可迭代对象</a></p>
<ol>
<li>典型的比如：object类型的对象不是可迭代对象</li>
</ol>
</li>
</ol>
</li>
<li><p>解构</p>
<ol>
<li><p>什么是解构?</p>
<ol>
<li><p><strong>与展开一样，解构也是针对数组与对象的，与展开的区别在于，展开是整体的展开，只能获得一堆分散的数据，但是这些分散的数据必须仍然整体起作用，如果想获得其中离散的个体对象的话需要使用解构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];<span class="keyword">const</span> [n1, n2, ...remainnumber] = array;<span class="built_in">console</span>.log(array, n1, n2, remainnumber);<span class="keyword">const</span> person2 = &#123;    <span class="attr">firstName</span>: <span class="string">&#x27;lee&#x27;</span>,    <span class="attr">age</span>: <span class="number">23</span>&#125;<span class="comment">// 数组的解构是严格按照顺序的，但是object的解构不能保证顺序，所以需要指定与key同名的变量才能执行解构const &#123;firstName, age&#125; = person2;console.log(firstName, age);// 如果不想使用同名的属性可以使用js原生支持的属性别名设置const &#123;firstName: userName, age&#125; = person2;// 此时就可以使用userName这个变量了console.log(userName, age);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意解构后的原对象、数组没有被更改</strong></li>
<li><strong>解构的过程也是变量创建并初始化的过程</strong></li>
</ul>
</li>
<li><p>解构有以下几种使用场景：</p>
<ol>
<li><p>变量做交换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的解构一直出错....let c = &#x27;lee&#x27;;let d = &#x27;jia&#x27;;[c, d] = [d,c];// jia leeconsole.log(c, d);</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组的解构,创建剩余变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略任意位置的元素let [,second,,last] = [1,2,3,4]console.log(second,last) // 2,4</span></span><br></pre></td></tr></table></figure></li>
<li><p>作为函数参数 (在传参的过程中完成解构)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用于函数参数function demo ([a,b]:[number,number]):void &#123;    console.log(a,b)    &#125;let c:[number,number] = [1,2]demo(c)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><ol>
<li>接口是由ts提供的，原生js中无接口</li>
<li>接口中的成员变量不能初始化<ol>
<li><strong>与Java不同，Java中接口如果定义了成员变量则必须初始化</strong></li>
</ol>
</li>
<li>实际上接口定义与object类型声明除了用了<code>interface</code>关键字之外就是一模一样，但是interface更多的是做类的抽象，定义类的结构，赋予类功能（必须实现特定方法）</li>
<li>与Java一样，同样支持多实现</li>
<li>在接口中只能使用<code>readonly</code>这一种修饰符，不能使用其他的修饰符（public、protected、private等等）<ol>
<li><strong>对于接口中定义的变量，其实现类中对于该变量的实现只能使用public修饰（假设如果使用其他修饰符修饰的话，此变量则不能自有访问，那么接口就失去了其意义）</strong></li>
<li>在object对象类型的声明中也可以使用<code>readonly</code>修饰符</li>
</ol>
</li>
<li>与Java一样，同样支持并建议使用面向接口的编程，将提升程序的扩展性</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;    name: <span class="built_in">string</span>;&#125;<span class="keyword">interface</span> Greetable <span class="keyword">extends</span> Named&#123;    <span class="keyword">readonly</span> content: <span class="built_in">string</span>;    greet (context: <span class="built_in">string</span>): <span class="built_in">void</span>&#125;<span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Greetable</span> </span>&#123;        <span class="title">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> content:<span class="built_in">string</span></span>) &#123;    &#125;    <span class="function"><span class="title">greet</span>(<span class="params">context: <span class="built_in">string</span></span>)</span> &#123;        <span class="built_in">console</span>.log(context + <span class="string">&#x27;hey! this is&#x27;</span> + <span class="built_in">this</span>.name);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Greetable</span> </span>&#123;        <span class="title">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> content:<span class="built_in">string</span></span>) &#123;    &#125;    <span class="function"><span class="title">greet</span>(<span class="params">context: <span class="built_in">string</span></span>)</span> &#123;        <span class="built_in">console</span>.log(context + <span class="string">&#x27;wow! wo wow wow&#x27;</span> + <span class="built_in">this</span>.name);    &#125;&#125;<span class="keyword">const</span> greetActionObject: Greetable = <span class="keyword">new</span> Person(<span class="string">&#x27;lee&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>);greetActionObject.greet(<span class="string">&#x27;##%&#x27;</span>);<span class="keyword">const</span> greetActionObject1: Greetable = <span class="keyword">new</span> Dog(<span class="string">&#x27;TD&#x27;</span>, <span class="string">&#x27;wangwang&#x27;</span>);greetActionObject1.greet(<span class="string">&#x27;##%#@%$@&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>在字面量对象中，方法可以直接定义出来，而不是必须赋给一个属性</strong>，对应的在对object类型的类型描述中，也有两种描述方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person:&#123;    <span class="attr">name</span>: string;    age: number;    <span class="comment">// 函数类型声明    greet: () =&gt; void;    // 函数声明    func(): void&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li><p>与Java一样，同样支持接口继承，<strong>并且同样支持接口的多继承</strong></p>
</li>
<li><p>js中的接口除了可以作为class（object）的模板之外，还可以作为函数的模板（因为函数也只是对象而已），与函数类型相似</p>
<ol>
<li><p>本质上把函数看做一个拥有特定函数的对象，将此对象抽象成接口即可（但是也包含特殊语法，就是略去函数名）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type addFn = (a: number, b: number) =&gt; number;interface addFn &#123;    // 无函数名指定    (a:number, b:number) : number&#125;const add:addFn = (n1: number, n2: number) =&gt; n1 + n2;const result = add(1, 2);</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>可选属性与方法（<strong>可以用在接口中，也可以用在object类型声明中，当然也可以用在class定义中</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此接口的实现类可以没有displayName属性和showName方法interface Named &#123;    name: string;    // 可选符号等价于 displayName: string | undefined     displayName?: string;    showName ?(): void&#125;// no error    let obj: &#123;a?: string; b: number&#125; = &#123;    b: 12&#125;;  class Man &#123;    name: string;    carrer ?: string		// 以下两种构造器都可实现构造器方法中参数可选，前者默认参数为undefined，后者默认参数是指定参数        // constructor (name: string, carrer?: string) &#123;    //     this.name = name;    //     this.carrer = carrer;    // &#125;    constructor (name: string, carrer: string = &#x27;None&#x27;) &#123;        this.name = name;        this.carrer = carrer;    &#125;&#125;let man:Man = new Man(&#x27;lee&#x27;);</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>当编译选项选择es5时，查看编译结果会发现，interface完全是ts提供的编译期的一个辅助特性，es5之前的js中完全无此概念</strong></p>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p>在ts的角度看，实际上就是创建了一个新的类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string ;		// 构造器函数不是必须的，默认是空参数的构造器    // 子类中的构造器函数默认是直接调用父类构造器super(参数列表，如果有的话)    constructor (n: string) &#123;        this. name = n;    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果父类的构造器函数被protected修饰，子类中的构造器函数必须显示声明</li>
<li><strong>java中也是类似的机制,不同之处在于父类构造函数被protected修饰的时候,子类中的构造函数还是可以省略的,与正常的子类继承一致</strong></li>
</ul>
</li>
<li><p>TypeScript里的类只是<strong>JavaScript ES6</strong>里常用的基于原型面向对象编程的简写(语法糖)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params">n</span>)</span> &#123;        <span class="built_in">this</span>.name = n;    &#125;&#125;<span class="keyword">const</span> accounting = <span class="keyword">new</span> Department(<span class="string">&#x27;Accounting&#x27;</span>);<span class="built_in">console</span>.log(accounting);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了类属性不能直接定义外，其余的都一样，但是如果编译的target是es5的话，实现就不一样了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Department = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">// 此内部函数就是构造器函数    function Department(n) &#123;        this.name = n;    &#125;    return Department;&#125;());var accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>es6中的class 不过就是上述代码过程的语法糖</li>
</ul>
</li>
</ul>
</li>
<li><p>类方法中的this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;       name: string;    <span class="title">constructor</span> (<span class="params">n: string</span>) &#123;        <span class="built_in">this</span>. name = n;    &#125;    <span class="comment">// 方法之间不用加;隔开    describe () &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);console.log(accounting);accounting.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如上注释，在类内方法中引用类字段时，必须使用this关键字，<strong>但是此this是有坑的，this指向的是执行当前方法的对象，谁执行此方法，this对象指向谁（并非所有场景下都是如此，可以参考修饰器章节中关于类方法修饰器返回值案例中的描述）</strong></p>
<ul>
<li><p>在前边的例子中，this执行accounting这个Department类型的实例</p>
</li>
<li><p>另外的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this. name = n;    &#125;    // 方法之间不用加;隔开    describe () &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);// 创建字面量对象// 此处仅将方法引用传递给dedcribe属性，与accounting这个实例无任何关系const accountingCopy = &#123;describe: accounting.describe&#125;;// Department: undefined// 此时执行的方法确实是Department class中定义的方法，但是与accounting实例无关，且其中的this指向的是方法的调用者accountingCopy，而其并无name属性，所以是undefinedaccountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二个案例的解决方案：</p>
<ul>
<li><p>当类中的方法内部使用了this关键字时候，实际上，this作为一个隐形的形参，在方法被被调用时，调用者的引用会被赋予到此形参，我们可以显式指定this形参，并为其添加类型检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this. name = n;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;const accounting = new Department(&#x27;Accounting&#x27;);const accountingCopy = &#123;describe: accounting.describe&#125;;// error accountingCopy的类型不是Department，因此在执行函数时，会因参数的类型检查组织accountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ts是如何检查类型是否一致的？</p>
<ul>
<li><p>无论是class与class还是class与字面量对象的比较，比较原则就判断是否有一样的属性，因此只要在上述的字面量对象中添加name属性即可避免报错</p>
<ul>
<li><p><strong>有相同的属性是最高比较原则，如果提供的值的类型中不仅有对应的属性，还有其他更多的属性，ts认为其仍然满足类型筛查</strong>，以下就是案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;    <span class="comment">// 可以通过=设置属性的默认值，或者使用构造器为其赋值，否则会报错    name: string;    constructor (n: string) &#123;        this.name = n;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;&#125;class DepartmentCopy &#123;        name: string;    num: number;    constructor (n: string, num: number) &#123;        this.name = n;        this.num = num;    &#125;    // 方法之间不用加;隔开    describe (this: Department) &#123;        // 不能直接这样引用类属性，只会这样引用函数域内的局部变量或者类外的全局变量，而name本身确实是一个全局变量，这里应该使用this.name        console.log(&#x27;Department: &#x27; + this.name);    &#125;    func () &#123;    &#125; &#125;// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Accounting&#x27;);// 创建字面量对象// 此处仅将方法引用传递给dedcribe属性，与accounting这个实例无任何关系const accountingCopy = new DepartmentCopy(&#x27;lee&#x27;, 12);// Department: undefined// 此时执行的方法确实是Department class中定义的方法，但是与accounting实例无关，且其中的this指向的是方法的调用者accountingCopy，而其并无name属性，所以是undefinedaccountingCopy.describe();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>综上，尽量不要这样class与字面量混用吧</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>当一个类型中有private或者protected类型的成员的时候,与其比较的类型中必须也有对应的成员,并且都是来自同一处声明（同一类或者是继承关系）才行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;    protected name: string;    <span class="function"><span class="title">constructor</span>(<span class="params">theName: string</span>)</span> &#123; <span class="built_in">this</span>.name = theName; &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Rhino</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">super</span>(<span class="string">&quot;Rhino&quot;</span>); &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;    protected name: string;    <span class="function"><span class="title">constructor</span>(<span class="params">theName: string</span>)</span> &#123; <span class="built_in">this</span>.name = theName; &#125;&#125;<span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">&quot;Goat&quot;</span>);<span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();<span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>);animal = rhino;       <span class="comment">// private或者protected都可以// animal = employee; // 错误: 因为protected和private属性 Animal 与 Employee 不兼容.尽管结构一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修饰符（public，private，protected，readonly（可与前边的混合使用））</p>
<ol>
<li>与Java中的含义类似<ol>
<li>如果不指定private，默认就是public，没有Java中所谓的包作用域</li>
<li><strong>事实上，js中只有public修饰符，其余的是ts引入的，也只能在编译时进行限制</strong></li>
<li><strong>需要注意的是只读属性必须在声明的时候,或者在构造函数中被初始化</strong></li>
<li><strong>protected与private类似，前者是只能在本类中访问，后者是在本类以及子类中访问，注意二者都是在类内部访问，在类外部访问是不允许的</strong></li>
</ol>
</li>
<li>除了传统的构造函数的使用方法之外（比较麻烦，所有的需要初始化的属性都需要添加在构造器中并在构造器中进行赋值）,<strong>在构造函数的参数中直接使用public或private修饰符,等同于创建了同名的成员变量</strong>，并且在使用new关键字创建实例时，就完成了对属性的初始化</li>
</ol>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;        <span class="keyword">private</span> employee: <span class="built_in">string</span>[] = [];    <span class="title">constructor</span> (<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> id: <span class="built_in">string</span>, <span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;            &#125;        describe (<span class="built_in">this</span>: Department) &#123;                <span class="built_in">console</span>.log(<span class="string">&#x27;Department: &#x27;</span> + <span class="built_in">this</span>.name);    &#125;    addEmployee (employee: <span class="built_in">string</span>) &#123;        <span class="built_in">this</span>.employee.push(employee);    &#125;    describeEmployee () &#123;        <span class="built_in">console</span>.log(<span class="built_in">this</span>.employee);    &#125;&#125;<span class="comment">// 此accounting变量的类型是自定义的Department类型const accounting = new Department(&#x27;Dp1&#x27;,&#x27;Accounting&#x27;);accounting.addEmployee(&#x27;lee&#x27;);accounting.addEmployee(&#x27;song&#x27;);accounting.describeEmployee();</span></span><br></pre></td></tr></table></figure>

<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><ul>
<li><p>与Java中是同样的概念</p>
</li>
<li><p>同样只能单继承而不能多继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span></span>&#123;    <span class="comment">// 与Java一样子类会获得所有的父类方法，并且有默认的构造函数与属性，并且在默认的构造函数中自动调用父类的构造方法，如果要自定义子类构造器的话，需要首先显式执行父类构造器方法    // 此处id不用加修饰符，是因为父类中已经有同名成员变量，虽然是private，但是也不允许子类中出现命名冲突    constructor (id :string, public admins: string []) &#123;        super(id, &#x27;IT&#x27;);    &#125;    &#125;class AccountingDepartment extends Department &#123;    constructor (id: string, private reports: string []) &#123;        super(id, &#x27;Accounting&#x27;);    &#125;    addReports (text: string) &#123;        this.reports.push(text);    &#125;    printReports () &#123;        console.log(this.reports);    &#125;&#125;const it = new ITDepartment(&#x27;Dp1&#x27;,[&#x27;lee&#x27;]);it.addEmployee(&#x27;lee&#x27;);it.addEmployee(&#x27;song&#x27;);it.describeEmployee();console.log(it);const account = new AccountingDepartment(&#x27;Account1&#x27;, []);account.addReports(&#x27;something goes wrong&#x27;);account.printReports();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于子类中的构造器函数：<ul>
<li>在Java中如果父类的构造器函数不是默认的空参数，那么子类必须显式声明构造器函数，并首先调用super函数</li>
<li><strong>但是在ts中，如果父类的构造器函数不是默认的空参数，子类也不用显式声明自己的构造器函数，因为此时子类的默认的构造器函数已经是包含参数并且内部调用super，除非有自己的其他的处理逻辑，否则不需要显式声明</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>复写</p>
<ul>
<li>成员变量</li>
<li>成员函数<ul>
<li>与Java中的类似，但是注意这个在IDE中并没有提示，自己知道就行</li>
</ul>
</li>
</ul>
</li>
<li><p>getter和setter</p>
<ul>
<li><p>js类中的getter与setter与Java中的概念一致，但是有自己的独特的标识方式，并且可以用属性的方式调用（<strong>不用在调用时加括号</strong>）</p>
<ul>
<li>getter：使用get关键字，必须有返回值，调用方式是访问属性</li>
<li>setter：使用set关键字，不需要返回值，调用方式是为属性赋值，<strong>setter与getter的名字可以一致，类似于Java中的方法重载</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter    get recentReports () &#123;        if (!this.lastReport) &#123;            throw new Error(&#x27;no lastReport.&#x27;);        &#125;        return this.lastReport;    &#125;    // setter    set recentReports (report: string) &#123;        if (!report) &#123;            throw new Error(&#x27;please set valid report&#x27;);        &#125;        this.addReports(report);    &#125;const account = new AccountingDepartment(&#x27;Account1&#x27;, []);account.recentReports = &#x27;end year report&#x27;;console.log(account.recentReports);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态属性与方法</p>
<ul>
<li>同样的使用static修饰符即可</li>
<li><strong>在静态方法中也可以使用this关键字来调用静态方法与属性，此时该this关键字的指向不再是实例，而是指代的类本身，与直接使用类名调用效果一样</strong></li>
<li>静态属性可以不初始化，但是非静态属性不初始化（无显示初始化，并且也没有在构造器中初始化）会报错</li>
</ul>
</li>
<li><p>抽象类与抽象方法</p>
<ul>
<li><p>同样使用abstract关键字，抽象方法只能定义在抽象类中，抽象类中抽象方法与普通方法可以共存</p>
<ul>
<li><strong>可以使用abstract关键字修饰成员变量，并且可以不初始化，即要求此属性在子类中必须得到初始化赋值</strong></li>
<li><strong>在Java中此关键字不能用来修饰成员变量</strong></li>
</ul>
</li>
<li><p><strong>抽象类的子类必须复写或者说实现对应的抽象方法</strong></p>
</li>
<li><p>抽象方法没有方法体，但是必须明确定义出方法参数列表与返回值类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract describe (<span class="built_in">this</span>: Department):<span class="keyword">void</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>抽象类不能被实例化</strong></p>
</li>
<li><p><strong>抽象类与接口一样，其内部的方法都可以使用?来表示非必须</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract configure ?(): <span class="keyword">void</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单例模式</p>
<ul>
<li>与Java类似<ul>
<li>构造函数私有化，设置静态实例变量</li>
<li>设置静态获取实例方法<ul>
<li>判断是否已经初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ts中的复杂类型"><a href="#ts中的复杂类型" class="headerlink" title="ts中的复杂类型"></a>ts中的复杂类型</h2><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li><p>与联合类型是类似的方向，联合类型是或的关系，而复合类型是与的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Admin = &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;type Employee = &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;<span class="comment">// 复合类型// 此类型拥有两种类型的全部属性type ElevaltedEmployee = Admin &amp; Employee;</span></span><br></pre></td></tr></table></figure></li>
<li><p>复合类型也可以使用接口的继承来实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Admin  &#123;    <span class="attr">name</span>: string;    privileges: string []&#125;interface Employee  &#123;    <span class="attr">name</span>: string;    startDate: <span class="built_in">Date</span>;&#125;interface ElevaltedEmployee <span class="keyword">extends</span> Admin, Employee&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复合类型运算符可以作用于任意两个类型，包括自定义类型和默认类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type a = number | string;type b = number | boolean;<span class="comment">// 本质上c就是number类型// 对于两个联合类型来说，其复合类型就是两个联合类型的共有类型type c = a &amp; b;// type errorlet var1:c = &#x27;1&#x27;;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>用以构建更加灵活的对象，即只指定对象中的属性的存在与属性的类型，但是并不指定属性的名称属性的个数（甚至可以是0个，或者说使用索引类型构建的结构中的属性都是可选的），以此种类型的蓝图构建的对象可以更加灵活</p>
<ul>
<li>此特性用在设计对象结构当中，所以适用于interface定义与自定义type定义（字面量对象类型的结构定义）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此类型的对象中可以存储String类型的键值对，键的类型可以修改为除了boolean之外的其他类型(string number symbol)interface ErrorContainer &#123;    [prop: string]:string;&#125;let error_bag: ErrorContainer = &#123;    // 12可以被当做是String类型，但是反之不可    12: &#x27;email not valid&#x27;,    username: &#x27;user not fund&#x27;    // value的类型必须是string类型    // username: 12  // error&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ts中的函数重载"><a href="#ts中的函数重载" class="headerlink" title="ts中的函数重载"></a>ts中的函数重载</h2><ul>
<li><p>ts中的函数重载与Java中的不一样，目的一样，但是实现并不一样</p>
</li>
<li><p>ts中的函数重载只包含函数签名的重载，但是函数体不能重载，也就是说对于不同的函数签名，函数体都是同一个函数体</p>
<ul>
<li><strong>因此函数签名的形式应该与函数体对应，比如，原本函数中有两个参数，现在重载为1个参数，此时，如果函数体中在任何情况下都需要2个参数参与，则此重载是不被允许的</strong></li>
</ul>
</li>
<li><p>并且ts也不支持Java的那种重载，会报函数重复定义的错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上边的两行就是对于add函数的重载说明，function add (a: number, b: number):number;function add (a: string, b: string):string;function add (var1: number|string, var2: number|string) &#123;    // 不得不引入运行时类型检查，实际上此运行时类型判断即为ts的特性之一 type guardif (typeof var1 === &#x27;number&#x27; &amp;&amp; typeof var2 === &#x27;number&#x27;) &#123;    // 如果直接相加，会报错，因为ts只检测到了对Union类型使用+，而不会探究Union内部的类型，所以    // 暂时引入类型判断(type guard)    return var1 + var2;&#125; else &#123;    // 可以对Union类型使用toString 方法，因为不管其到底是Union内部的哪一种类型，都有此方法    return var1.toString() + var2.toString()&#125;&#125;console.log(add(1, 2));// no overload match this call console.log(add(1, &#x27;&#x27;));console.log(add(&#x27;李&#x27;, &#x27;佳&#x27;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述例子中，add原函数会的返回值是联合类型（这会导致，无法使用特定类型的方法），但是在参数类型确定的情况下，返回值的类型实际上也是确定的，然而ts并不能正确预测其类型，可以使用类型断言解决此问题，也可以使用上述的重载解决此问题</li>
<li>关于重载，有趣的是：上述的例子中，本来参数可以是number或String，但是一旦指定重载后，函数就只匹配重载的两种形式了，不能是(number, String)或(string, number)，除非再定义这两种的函数重载形式</li>
</ul>
</li>
</ul>
<h3 id="Optional-Chaining-可选链"><a href="#Optional-Chaining-可选链" class="headerlink" title="Optional Chaining(可选链)"></a>Optional Chaining(可选链)</h3><ul>
<li>前边的案例中实际已经用过，就是<code>?</code>，但是前边的使用都是用作可选的参数或者属性，这里用来在嵌套对象中进行判断<ul>
<li>对于未知来源的数据或者说是<strong>未定义在ts中的嵌套对象的数据结构</strong>，在js中需要使用多层嵌套的if-check来保证属性确实存在，在ts中可简洁的使用可选链达到这个目的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*userData: &#123;  job: &#123;    title: &#x27;&#x27;  &#125;,  ...&#125;if (fetchUserDataFromBackened &amp;&amp; fetchUserDataFromBackened.job) &#123;  const title = fetchUserDataFromBackened.job.title;&#125;*/</span><span class="comment">// fetchUserDataFromBackened是一类变量，可能是从用户输入拿到的或者是从后端拿到的数据，总之ts不清楚其具体的数据结构无法在编译时进行检查const title = fetchUserDataFromBackened?.job?.title;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>?</code>前的对象是undefined或null，那么就不会再继续向后使用<code>.</code>进行对象索引</li>
</ul>
<h3 id="Nullish-Coalescing-空值合并"><a href="#Nullish-Coalescing-空值合并" class="headerlink" title="Nullish Coalescing 空值合并"></a>Nullish Coalescing 空值合并</h3><ul>
<li>与上边的可选链是同样的使用情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fetchedUserData = &#123;    name: &#x27;lee&#x27;,    age: 12&#125;*/</span><span class="comment">// 如果fetchedUserData不是null或者undefined，那么就返回默认数据// 注意过滤null或undefined，不包含空字符串等console.log(fetchedUserData?? &#x27;DEFAULT DATA&#x27;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>空值合并与可选链的编译结果实际上就是用连续的逻辑判断来实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(fetchedUserData?.name);console.log(fetchedUserData === null || fetchedUserData === void 0 ? void 0 : fetchedUserData.name);// console.log(fetchedUserData?? &#x27;DEFAULT DATA&#x27;);console.log(fetchedUserData !== null &amp;&amp; fetchedUserData !== void 0 ? fetchedUserData : &#x27;DEFAULT DATA&#x27;);</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以发现二者的逻辑是一样的，只是使用场景不一样</p>
<ul>
<li>可选链用于多层数据结构的属性引用的场景</li>
<li>空值合并用于直接的（非null非undefined）判断</li>
</ul>
</li>
</ul>
<h2 id="ts中的泛型"><a href="#ts中的泛型" class="headerlink" title="ts中的泛型"></a>ts中的泛型</h2><ul>
<li><p>泛型同样仅在ts中支持，与原生js无关</p>
</li>
<li><p>ts中对于泛型的支持，可以从两个类型开始</p>
<ul>
<li><p>Array</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise: <span class="built_in">Promise</span>&lt;string&gt; = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;        resolve(<span class="string">&#x27;job is done&#x27;</span>);    &#125;, <span class="number">2000</span>);&#125;);promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>泛型的意义在于以下两者的结合</p>
<ul>
<li>向ts提供更丰富的类型信息，便于ts提供更好的类型支持</li>
<li>扩展函数或者class的功能，相当于引入了动态类型</li>
</ul>
</li>
<li><p>在函数中使用泛型</p>
<ul>
<li><p>定义一个merge函数用来执行类型复合的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*// ts只知道返回类型是objectfunction merge (objA: object, objB: object) &#123;    return Object.assign(objA, objB);&#125;*/</span><span class="comment">// 通过泛型的方式，将详细的类型信息告知了ts// ts推测返回类型是 T &amp; Vfunction merge&lt;T, V&gt; (objA: T, objB: V) &#123;    return Object.assign(objA, objB);&#125;// mergeresult类型是&#123;name: string; age: number&#125;const mergeResult = merge(&#123;name: &#x27;lee&#x27;&#125;, &#123;age: 23&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>并不是只有class中的泛型能够在初始化时使用尖括号的形式进行声明，函数的也可以，但是当函数参数已经指定了泛型的类型时，就不必显式指定了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>泛型中的type Constrain</p>
<ul>
<li><p>其实就是Java中使用的上下界通配符<code>extends</code>和<code>super</code></p>
</li>
<li><p>其作用就是为泛型引入<strong>类型限制</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">V</span> <span class="title">extends</span> <span class="title">object</span>&gt; (<span class="params">objA: T, objB: V</span>) </span>&#123;    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(objA, objB);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样的例子，如果泛型T和V不做限制的话，可以传递任意类型的值，但是函数体内的assign函数只接受object类型，因此，需要使用泛型中的类型限制</li>
<li>extends后边的类型可以灵活的设置为string、number、自定义类型、联合类型等等</li>
</ul>
</li>
<li><p>使用类型限制的一个案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接受字符串或数组并得到其长度，并返回长度信息元组，接受的参数是多元参数，可以使用联合参数，更灵活的就使用泛型为了明确表示，T类型有length属性，尝试使用类型限制自定义一个接口，并定义length属性，表示只接受有length属性的对象*/</span>interface Lengthy &#123;    <span class="attr">length</span>: number;&#125;<span class="comment">// 如果不显示指定返回类型，默认被推测为联合类型的数组function countAndDescribe&lt;T  extends Lengthy &gt; (elements: T) :[T, string]&#123;    let descibeMessage = &#x27;there is no value&#x27;;    if (elements.length == 1) &#123;        descibeMessage = `there is 1 element`;    &#125; else if (elements.length &gt; 1) &#123;        descibeMessage = `there are $&#123;elements.length&#125; element`;    &#125;    return [elements, descibeMessage];&#125;console.log(countAndDescribe([1,2,3]));</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>keyof</code>做类型限制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传入一个对象参数，与其中的一个key获取对应的value1. 可以是任何object,可以使用泛型2. 必须保证对象中有特定的属性，使用keyof*/</span><span class="function"><span class="keyword">function</span> <span class="title">extractAndConvert</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">V</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt; (<span class="params">obj: T, key: V</span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;the value of key &#x27;</span> + key + <span class="string">&#x27; is &#x27;</span> + obj[key];&#125;<span class="built_in">console</span>.log(extractAndConvert(&#123;<span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>&#125;, <span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在class中使用泛型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据存储的类型，当然希望能存储各种类型，所以用到泛型*/</span><span class="class"><span class="keyword">class</span> <span class="title">DataStorage</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">string</span> | <span class="title">number</span> | <span class="title">boolean</span>&gt; </span>&#123;    private data: T[] = [];    getData () &#123;        <span class="keyword">return</span> [... <span class="built_in">this</span>.data];    &#125;    addData (item: T) &#123;        <span class="built_in">this</span>.data.push(item);    &#125;    removeData (item: T) &#123;        <span class="comment">// T 可以是任意类型，当然也可以是一个字面对象，但是会涉及到指针传递的问题        // indexof无法找到时，会返回-1，splice接受到-1参数后，会从尾部元素开始删除        this.data.splice(this.data.indexOf(item), 1);    &#125;&#125;const textStorage = new DataStorage&lt;string&gt; ();textStorage.addData(&#x27;lee&#x27;);textStorage.addData(&#x27;jia&#x27;);textStorage.removeData(&#x27;jia&#x27;);console.log(textStorage.getData());// const objectStorage = new DataStorage&lt;object&gt; ();// objectStorage.addData(&#123;name: &#x27;lee&#x27;&#125;);// objectStorage.addData(&#123;name: &#x27;jia&#x27;&#125;);// // 是指针传递而非值传递，因此传入参数的不是一模一样的对象，而是一个全新的对象的指针，所以并不会索引到此对象// // 因此可能需要适时的引入泛型的类型限制（当然也可以引入其他机制解决此引用传递的问题，这里这是强调在泛型中使用类型检查的重要性）// objectStorage.removeData(&#123;name: &#x27;lee&#x27;&#125;);// console.log(objectStorage.getData());</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>每当使用泛型时，都应注意，是否需要做类型限制，不要让泛型过于自由</strong></li>
<li>class中的方法也可以灵活定义属于自己的泛型</li>
</ul>
</li>
<li><p>ts中支持的一些常用的使用泛型的工具类（使用泛型提供便利的工具类）</p>
<ul>
<li><p>Partial，一个包装类，用来表示<strong>泛型指定的类型中的属性都是可选的，其使用场景在于可以单独设置指定类型的参数，而不用一次性设定（默认情况下ts会报错，参考下边的案例）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface CourseGoal &#123;    <span class="attr">title</span>: string;    description: string;    completeUntil: <span class="built_in">Date</span>&#125;<span class="comment">/** 创建CourseGoal对象，对象的属性可能来自于数据库或者用户输入*/</span><span class="function"><span class="keyword">function</span> <span class="title">createCourseGoal</span> (<span class="params">title: string, description: string, date: <span class="built_in">Date</span></span>) : <span class="title">CourseGoal</span></span>&#123;    <span class="comment">// 首先初始化一个空对象    // 在程序中会一步一步的设置对象的属性，但是在初始化时创建对象后就不允许赋值为空对象,此时需要使用Partial包装类    // 告诉ts，CourseGoal的属性都是可选的，不必在初始化时操作，后续该有的属性都会酌情添加    let courseGoal: Partial&lt;CourseGoal&gt; = &#123;&#125;;    // ... 数据库获取或用户输入    courseGoal.title = &#x27;ts&#x27;;    // ... 数据库获取或用户输入    courseGoal.description = &#x27;up up&#x27;;    // ... 数据库获取或用户输入    courseGoal.completeUntil = new Date();    // 返回的类型是Partial类型会报错，但是开发者知道返回的对象就是CourseGoal形式的对象，因此直接使用断言即可    return courseGoal as CourseGoal;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>ReadOnly，设置任意对象为只读，前边学到的readonly（或者说定义变量时使用的const）是class中的类成员修饰符，当修饰一个对象时，不可更改的是对象的地址，而对象内部的属性是可以任意更改的，ReadOnly类就可以使用泛型标记一个泛型的对象为完全只读，其内部的属性也不可能更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">// okarray.push(5);const arrayReadOnly:Readonly&lt;number []&gt; = [1,2,3];// errorarrayReadOnly.push(5);</span></span><br></pre></td></tr></table></figure></li>
<li><p>更多参考<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/utility-types.html">ts中支持泛型的工具类</a></p>
</li>
</ul>
</li>
<li><p>泛型与联合类型的区分</p>
<ul>
<li>许多情况下，在使用泛型时，实际上只是接受多个特定类型而已，而不一定接受所有类型，这种情况下，貌似使用联合类型也能解决，毕竟也实现了接受多个类型，但是最关键的不同在于<strong>泛型所代表的类型一旦确定，就是唯一接触的类型，同一时间只对这一种类型服务，而联合类型永远支持多个类型</strong></li>
</ul>
</li>
</ul>
<h2 id="ts中的装饰器"><a href="#ts中的装饰器" class="headerlink" title="ts中的装饰器"></a>ts中的装饰器</h2><ul>
<li><p>注意，如果要在ts中使用装饰器，需要在tsconfig.json中打开以下的配置<code>&quot;experimentalDecorators&quot;: true</code></p>
</li>
<li><p>装饰器更确切的说是一个函数，可以用来修饰一个类（<strong>包括类属性类方法等等</strong>），从名字来看与Java中的装饰者模式类似（使用方法上更像是springboot中的注解）</p>
</li>
<li><p>这里涉及到元编程的概念，可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B">维基百科</a>以及相关的其他介绍</p>
<ul>
<li><p>元编程是一种计算机程序可以将代码看待成数据的能力</p>
</li>
<li><p>元编程赋予了编程语言更加强大的表达能力，通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。归根结底就是一种使用代码生成代码的思想，消灭重复的代码，极大地增强编程语言的表达能力</p>
</li>
<li><p>泛型，注解（依靠反射实现），等实际上都是元编程的概念</p>
</li>
<li><p>编写元程序的语言称之为元语言。被操纵的程序的语言称之为「目标语言」。一门编程语言同时也是自身的元语言的能力称之为「反射」或者「自反」。</p>
</li>
</ul>
</li>
<li><p>总结下边的装饰器案例，装饰器更像一个插件，可以用作第三方库的切入点，用以提供强大的功能（类似于spring AOP）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorator首字母大写// 修饰器函数的参数随着其修饰位置的不同而变化// 修饰构造器function Logger (constructor: Function) &#123;    console.log(&#x27;logging ...&#x27;);    console.log(constructor);&#125;// 使用@函数名来部署一个修饰器@Loggerclass Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;// const pers = new Person();// console.log(pers);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>装饰器在class定义后（js发现class的构造器函数后）立即起作用，而不是实例化后起作用</strong></li>
<li><strong>类装饰器的参数是该类的类构造器方法</strong></li>
</ul>
</li>
<li><p>使用装饰器工厂</p>
<ul>
<li><p>使用装饰器工厂可以更灵活的创建装饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建修饰器function LoggerFactory (loggerText: string) &#123;    return function (constructor: Function) &#123;        console.log(loggerText);        console.log(constructor);    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@LoggerFactory(&#x27;constructor logging ...&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>功能更强大的装饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="comment">// 将参数名称设置为_是告诉ts，函数中不会用到形参，但是得有这个形参，所以就设置一个特殊的名字即可    return function (_: Function) &#123;        const element = document.getElementById(hookId)!;        element.innerHTML = template;    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@WithTemplate(&#x27;&lt;h1&gt; !!!&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>显然，此装饰器更类似于一个模板渲染的工具，如何将class的数据导入进来呢？使用构造器函数即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="comment">// 将参数名称设置为_是告诉ts，函数中不会用到形参，但是得有这个形参，所以就设置一个特殊的名字即可    return function (constructor: any) &#123;        const element = document.getElementById(hookId)!;        element.innerHTML = template;        // 注意这里比较诡异，要使用new关键字来调用构造函数，相当于创建class实例，为了避免报错，将constructor参数的        // 类型设置为any        let person = new constructor();        document.querySelector(&#x27;h1&#x27;)!.innerText = person.name;    &#125;    &#125;// 调用修饰器工厂方法返回修饰器函数的引用@WithTemplate(&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>angular这样的前端框架中就支持诸如此类的装饰器，以进行页面渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以对class同时使用多个装饰器，但是装饰器的启动顺序是怎样的？离着class越近的越先被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoggerFactory</span> (<span class="params">loggerText: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;loggerFactory start&#x27;</span>)    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_: <span class="built_in">Function</span></span>) </span>&#123;        <span class="built_in">console</span>.log(loggerText);    &#125;    &#125;<span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;templateFactory start&#x27;</span>)    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: any</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;template redering....&#x27;</span>)        <span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(hookId)!;        element.innerHTML = template;        <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title">constructor</span>(<span class="params"></span>);        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>)!.innerText = person.name;    &#125;    &#125;@LoggerFactory(<span class="string">&#x27;person class logging ...&#x27;</span>)@WithTemplate(<span class="string">&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;</span>, <span class="string">&#x27;app&#x27;</span>)<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    name = <span class="string">&#x27;lee&#x27;</span>;    <span class="title">constructor</span> (<span class="params"></span>) &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;creating Person object...&#x27;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印顺序为：<code>loggerFactory start app.ts:10 templateFactory start app.ts:12 template redering.... app.ts:28 creating Person object... app.ts:5 person class logging ...</code></li>
<li>装饰器工厂的执行顺序，就是按照执行顺序来的，尽管前边有<code>@</code>符号，但是本质上还是执行了后边的工厂方法，而装饰器的执行顺序则是离着class近的先被执行</li>
</ul>
</li>
<li><p>类属性修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类属性修饰器// 2个参数// 1. 如果是实例成员，则为类的原型；如果是静态成员，则为构造器函数// 2. 属性名function Log (target: any, propertyName: string|Symbol) &#123;    console.log(&#x27;property decorator..&#x27;);        console.log(target, propertyName);&#125;class Product &#123;    @Log    static title: string;    private _price: number;    constructor (price: number) &#123;        this._price = price;    &#125;    set setPrice (price: number) &#123;        if (price &gt; 0) &#123;            this._price = price;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例成员：</p>
<img src="http://images.demoli.xyz/20210103143843.png" style="zoom:80%;" /></li>
<li><p>静态成员</p>
<img src="http://images.demoli.xyz/20210103143927.png" style="zoom:80%;" /></li>
<li><p>关于类属性修饰器的一个案例（数据validator，实际上也是类似的注解的经典应用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用接口来定义存储结构// 此接口必须具有极大的灵活性，因为可以存储任意class中的待验证信息// 结构就是： 类名：&#123;类中属性的名字:[需要的验证规格]&#125;interface ValidatorConfig &#123;    [className: string]: &#123;        [propName: string]: string []    &#125;&#125;// 此验证器信息的存储结构在待验证class定义好之后就会被修饰器中的逻辑进行赋值const registeValidator: ValidatorConfig = &#123;&#125;;function Require (target: any, propName: string) &#123;        // 向存储结构中添加验证信息    // 使用[]来索引object中的属性或添加属性    // target.constructor指向的是class的类构造器（js原生中的类构造器）其name属性就是类构造器方法的名字也就是语法糖中class的名字    registeValidator[target.constructor.name]  = &#123;        ...registeValidator[target.constructor.name],        [propName]: [...registeValidator[target.constructor.name][propName], &#x27;require&#x27;]    &#125;;&#125;function LargerthanZero (target: any, propName: string) &#123;    // 向存储结构中添加验证信息    registeValidator[target.constructor.name] = &#123;        ...registeValidator[target.constructor.name],        [propName]: [...registeValidator[target.constructor.name][propName] , &#x27;largerthanZero&#x27;]    &#125;;&#125;function validate (object: any): boolean &#123;    //首先在全局的存储结构中找到参数obkect对应的验证信息    const validator = registeValidator[object.constructor.name];    if (!validator) &#123;        // 没有存储该class的验证信息，说明不用验证，返回true        return true;    &#125;    let isValid = true;    for (const prop in validator) &#123;        for (const valid of validator[prop]) &#123;            switch (valid) &#123;                case &#x27;require&#x27;:                     // 使用!!运算符，空字符串与null、0或undefined都转为false                     console.log(prop);                    isValid = isValid &amp;&amp; !! object[prop];                    break;                case &#x27;largerthanZero&#x27;:                    console.log(prop);                    isValid = isValid &amp;&amp; object[prop] &gt; 0;                    break;            &#125;        &#125;    &#125;    return isValid;&#125;class Course &#123;    @Require    title: string;    @LargerthanZero    price: number;    constructor (title: string, price: number) &#123;        this.title = title;        this.price = price;    &#125;&#125;const form = document.querySelector(&#x27;form&#x27;)!;form.addEventListener(&#x27;submit&#x27;, (event) =&gt; &#123;    // 防止表单提交后发出http请求    event.preventDefault();    const titleEl = document.getElementById(&#x27;title&#x27;) as HTMLInputElement;    const priceEl = document.getElementById(&#x27;price&#x27;) as HTMLInputElement;    const title = titleEl.value;    // +的作用就是将数字内容的字符串转为数字    // 如果是非数字内容的字符串的话，会得到NaN    const price = +priceEl.value;    // 显然对于用户的输入，希望title的内容与price的设置必须要经过检查    // 可以使用if-check，但是如果每一次创建一个实例都要进行判断，就过于繁琐，所以引入了基于class的使用修饰器实现的验证器    let course = new Course(title, price);    if (!validate(course)) &#123;        alert(&#x27;wrong!&#x27;);        return;    &#125;    console.log(course);&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用场景：<ul>
<li>构造class实例的数据来自于用户输入或者后台数据，需要验证数据类型的有效性</li>
</ul>
</li>
<li>设计分析<ul>
<li>应该有三个函数要定义<ul>
<li>titile属性的修饰器</li>
<li>price属性的修饰器</li>
<li><strong>验证器函数（非修饰器），因为类属性的修饰器，仅仅能获得属性的名字，不能获取属性的值，所以只能起到一个标注的作用，验证逻辑应该在验证器函数中完成</strong></li>
</ul>
</li>
<li><strong>应该有一个存储类型需要定义，此存储类型对象要存储的是类实例中的哪个属性需要什么规格的验证（此信息需要从修饰器中获得并被验证器函数利用以对参数中传入的实例进行验证）</strong></li>
</ul>
</li>
<li><strong>很复杂的修饰器实现的验证器，但是实际上一般这都是第三方库要提供的服务，使用者只需import就可以直接使用修饰器与修饰器了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>类getter与setter的修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log2</span> (<span class="params">target : any, name: string, descriptor: PropertyDescriptor</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;accessor decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, descriptor);&#125;<span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;    <span class="comment">// @Log    static title: string;    private _price: number;    constructor (price: number) &#123;            this._price = price;    &#125;    // @log2    set setPrice (price: number) &#123;        if (price &gt; 0) &#123;            this._price = price;        &#125;    &#125;    @log2    static set setTitle (title: string) &#123;        this.title = title;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类的getter与setter又被称为accessor，其修饰器的参数有三个</p>
<ul>
<li><p>与类属性修饰器的第一个参数一样，如果accessor为类成员方法就是类的原型，如果是静态方法就是构造器函数</p>
</li>
<li><p>accessor的名字</p>
</li>
<li><p>PropertyDescriptor类型（原生js提供的的内置类型（详细可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">官网</a>））的值</p>
<img src="http://images.demoli.xyz/20210103144849.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>类方法的修饰器</p>
<ul>
<li><p>与前边的accessor的修饰器实际上是一样的，只是descriptor的内部结构不太一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log3</span> (<span class="params">target : any, name: string| <span class="built_in">Symbol</span>, descriptor: PropertyDescriptor</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;method decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, descriptor);&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法参数的修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log4</span> (<span class="params">target : any, name: string| <span class="built_in">Symbol</span>, position: number</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;parameter decorator&#x27;</span>);    <span class="built_in">console</span>.log(target, name, position);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数与类方法修饰器的一样</li>
<li><strong>参数所在的方法的方法名</strong></li>
<li>参数在方法形参列表中的位置，从0开始</li>
</ul>
</li>
<li><p>修饰器的执行顺序</p>
<ul>
<li>以上所有的修饰器，都是在class定义好后就开始工作的，而不是class实例化后工作的，后边提到的修饰器函数返回值的使用案例中需要进行实例化</li>
<li><strong>对于同一个对象（class 类方法 类属性）赋予多个修饰器时，都是离得越近的修饰器越先被执行</strong></li>
</ul>
</li>
<li><p>修饰器函数的返回值</p>
<ul>
<li><p>并不是所有修饰器函数的返回值都有意义</p>
</li>
<li><p>修饰器函数能返回什么取决于此修饰器函数的类型</p>
<ul>
<li><p>类修饰器可以返回一个类构造函数用以替换被修饰器修饰的class</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WithTemplate</span> (<span class="params">template: string, hookId: string</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;templateFactory start&#x27;</span>)    <span class="comment">// 为了表示泛型T是构造器函数类型，需要对其进行类型限制，其必须有new方法，方法参数是可变数组    // new方法的返回值也必须定义好，因为下边要用到name属性，所以返回值必须有name属性    return function&lt;T extends &#123;new (...args: any[]): &#123;name: string&#125;&#125;&gt; (originalConstructor: T) &#123;        console.log(originalConstructor);            // 同样可以是class关键字这个语法糖来生成一个构造器函数并返回        // 需要注意到的是这个新的class应当继承自原有的class        return class extends originalConstructor&#123;            // 子类的构造器函数            // 并不会使用构造器参数，所以命名为_            constructor (..._: any[]) &#123;                // 使用super方法可以保留原有class的数据结构                super();                // 将渲染步骤放在构造函数中，则其必须在实例化时才能起作用                console.log(&#x27;template redering....&#x27;)                const element = document.getElementById(hookId)!;                element.innerHTML = template;                document.querySelector(&#x27;h1&#x27;)!.innerText = this.name;            &#125;        &#125;;    &#125;    &#125;@WithTemplate(&#x27;&lt;h1&gt;&lt;/h1&gt;&#x27;, &#x27;app&#x27;)class Person &#123;    name = &#x27;lee&#x27;;    constructor () &#123;        console.log(&#x27;creating Person object...&#x27;);    &#125;&#125;// 实例化后，执行修饰器返回的构造函数，并在构造函数中完成渲染let pers = new Person();</span></span><br></pre></td></tr></table></figure></li>
<li><p>类方法修饰器</p>
</li>
<li><p>accessor修饰器</p>
<ul>
<li><p>以上两个修饰器本质上都是类似的，可以返回新的PropertyDescriptor类型的对象用于替换其本来的PropertyDescriptor，下边展示关于类方法修饰器的案例展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的功能在于点击button后可以执行class内的一个成员方法function AutoBind (_: any, _2: string, desciptor: PropertyDescriptor) &#123;// 1. 在修饰器内部获取修饰的方法    const originMethod = desciptor.value;    // 2. 配置要返回的PropertyDescriptor以取代被修饰的方法的PropertyDescriptor    // 3. 在ts中PropertyDescriptor是一个接口，并且接口中的属性与方法都是可选的，所以不用写全所有的属性    const adjustDescriptor: PropertyDescriptor = &#123;        configurable: true,        enumerable: false,        // 此属性相当于是在函数调用前与addEventListener注册回调函数间添加了一个代理，addEventListener将this设置为event target后，在函数调用时执行此get方法来获得函数引用，而在get方法中，重新将        // this设置为this，这里的this会恒定指向类实例，因为这个get方法总是被方法所属的实例调用的        get () &#123;            const boundFn = originMethod.bind(this);            return boundFn;        &#125;    &#125;;    return adjustDescriptor;&#125;class Printer &#123;    private message: string = &#x27;Printer work!&#x27;;    // 可以说用此注解取代了对于bind函数的使用，这使得代码更加整洁    @AutoBind    printMessage () &#123;        console.log(this.message);    &#125;&#125;let printer = new Printer();const button = document.querySelector(&#x27;button&#x27;)!;button.addEventListener(&#x27;click&#x27;, printer.printMessage);// 注意这里只是传递函数引用而不是执行函数// 实际上点击之后，会打印undefined，这是因为在事件触发机制中，回调函数内部的this被绑定为事件对象（event target）上// 而不是实例printer// 解决办法有以下几种// 1. 使用bind函数，重新配置context（也就是this变量）// 2. 使用类方法修饰器，修饰器的目的在于使得被修饰的类方法内部的this无论在任何场景下都只会指向其所属的class实例// button.addEventListener(&#x27;click&#x27;, printer.printMessage.bind(printer));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>具体的PropertyDescriptor的各个属性的功能应该参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">官网</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>nest.js中的server端代码使用修饰器实现的注解来实现复杂功能（与Java中类似），Angular也把修饰器作为其核心部分，提供页面数据渲染等功能，修饰器真的很强大，也很重要</strong></p>
</li>
<li><p>更好用的第三方库<a target="_blank" rel="noopener" href="https://github.com/typestack/class-validator">class validator</a></p>
</li>
</ul>
<h2 id="Demo-可视化的项目管理器"><a href="#Demo-可视化的项目管理器" class="headerlink" title="Demo 可视化的项目管理器"></a>Demo 可视化的项目管理器</h2><ul>
<li><p>html文件与css文件直接复制写好的</p>
<ul>
<li>关于html的一些设计<ul>
<li>template标签默认情况下是不可见的，可由js操作是否可见，字如其意，用来做模板数据的，在需要的时候可以渲染到页面中</li>
</ul>
</li>
</ul>
</li>
<li><p>去源代码目录中查看源代码与注释即可</p>
</li>
<li><p><strong>class中public的方法应放在protected、private前面</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">关于modern browser的drag与drop</a></p>
</li>
</ul>
<h2 id="ts中的模块化"><a href="#ts中的模块化" class="headerlink" title="ts中的模块化"></a>ts中的模块化</h2><ul>
<li>上边的demo中的所有代码都写在一个文件中，显然不利于维护，有两种方式可以拆分代码到不同的文件：<ul>
<li>使用Namespace，由ts提供的语法，由ts负责处理文件依赖关系</li>
<li>ES6 Import/Export，原生js语法，由browser负责处理文件依赖关系<ul>
<li>弊端在于，需要多次HTTP请求来获取不同的js文件，因此生产中常把所有的js文件打包为一个js文件，打包工具常用的有WebPack等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drag &amp; Drop// 可被拖动的对象namespace DDInterfaces &#123;    export interface Dragable &#123;        // 开始拖动        dragStartHandler(event: DragEvent) : void        // 结束拖动        dragEndHandler(event: DragEvent) : void    &#125;    // 拖动的目的对象    export interface DragTarget &#123;        // 拖动进入        dragOverHandler(event: DragEvent): void        // 拖动进入并松开        dropHandler(event: DragEvent): void        // 拖动离开        dragLeaveHandler(event: DragEvent): void    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>内部可定义任何数据结构</p>
</li>
<li><p><strong>可以使用export暴露内部的任意数据结构，否则只能在同一命名空间下才能被访问到</strong></p>
</li>
<li><p>文件的引入方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;drag-drop-interface.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>再次强调，这是纯ts语法，与js无关，其依赖关系由ts维护</strong></p>
<ul>
<li><strong>此语法仅仅是告诉ts编译器从哪里找寻需要的类型接口等等，但是对于编译后结果，所有拆分的文件都是独立编译的，因此如此拆分实际上会出错（因为html文件实际上只引用了一个js文件，其余的虽然编译了，但是并没有引用，我们需要ts编译器将编译结果统一编译到一个js文件中）</strong><ul>
<li>在<code>tsconfig.json</code>中设置<code>&quot;outFile&quot;: &quot;./dist/bundle.js&quot;,</code>以及设置<code>&quot;module&quot;: &quot;amd&quot;,</code></li>
<li>实际上namespace这个语法的实现对应的就是js中的一个函数，可以查看js编译结果</li>
</ul>
</li>
</ul>
</li>
<li><p>上述语法的作用是把path属性对应的ts中namespace引入到本文件中，<strong>但是要访问namespace内部的结构，必须还是要把当前文件中要访问的代码放到同一namespace下，否则无法访问</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;drag-drop-interface.ts&quot; /&gt;namespace DDInterfaces &#123;  ...&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么 export的作用是？将本ts文件中的数据结构暴露出去，否则，即便别的文件使用同一namespace，但是依然无法访问到其他问价同一namespace下的数据结构</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Namespace的使用弊端</p>
<ul>
<li>拆分起来很麻烦，并且需要自己分析依赖逻辑</li>
<li>一旦依赖逻辑错误，可能没有编译错误，但是会有运行时错误</li>
</ul>
</li>
</ul>
<h3 id="ES6-Import-Export"><a href="#ES6-Import-Export" class="headerlink" title="ES6 Import/Export"></a>ES6 Import/Export</h3><ul>
<li><p>与namespace类似使用export 导出本文件中的对象</p>
</li>
<li><p>在其他文件使用import： <code>import &#123;要引用的对象,对象1,对象2&#125; from &#39;文件位置&#39;;</code></p>
<ul>
<li>需要注意文件位置中的文件名应当是<code>.js</code>后缀，因为要引入的应当是编译好的js文件，因为Import是js原生支持的语法，ts会做提示，但不会做其他的干预</li>
<li>可以先不写<code>&#123;&#125;</code>中药引入的对象，先把后边的文件位置写好，此时对象会有提示</li>
</ul>
</li>
<li><p><strong>使用此方法避免了使用namespace时，依赖是否被正确添加的提示机制，此方法中，只要在本文件中没有正确添加依赖就会报错，而不管其他文件如何添加依赖</strong></p>
</li>
<li><p>一顿操作猛如虎，最后还会报一个错误<code>Uncaught ReferenceError: define is not defined typescript</code></p>
<ul>
<li><strong>保证配置文件中target是es6以后的版本，module设置为es2015，outFile属性也要注释掉（这是namespace需要的，并不受es6 module支持）</strong><ul>
<li>基本做的就是告诉ts编译器，原封不动的输出import与export关键字，浏览器知道如何处理，不要ts做干预</li>
</ul>
</li>
</ul>
</li>
<li><p>html引入js文件的方式也需要做设置，否则会有<code>Uncaught SyntaxError: Cannot use import statement outside a module</code>，应当告诉浏览器，js代码使用module维护依赖关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;dist/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>去掉<code>defer</code>，添加type属性为module</li>
<li><strong>此时app.js作为入口文件，浏览器会迭代的去解析依赖，并且实时的去请求对应的依赖的js文件（可以通过控制台的network查看）</strong></li>
</ul>
</li>
<li><p>使用中的其他语法：</p>
<ul>
<li><p>为了避免命名冲突冲突，可以使用别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用*导入目的包的全部对象，使用as指定别名import * as Drag from &#x27;../models/drag-drop.js&#x27;;import &#123;Project&#125; from &#x27;../models/project.js&#x27;;import &#123;Component&#125; from &#x27;./base-component.js&#x27;;import &#123;AutoBind as autoBind&#125; from &#x27;../decorators/autobind.js&#x27;;// ProjectItem classexport class ProjectItem extends Component&lt;HTMLUListElement, HTMLLIElement&gt; implements Drag.Dragable&#123;  ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认export</p>
<ul>
<li><p>import时总要指定与export中同样的名字，使用默认export时则不用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">Component</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span>&gt;</span>&#123;...&#125;<span class="comment">// 不用使用&#123;&#125;指定名字，并且可以使用任意名字，不冲突即可import Cmp from &#x27;./base-component.js&#x27;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个文件只能有一个默认export</li>
<li>只有目的模块文件如此设置了才能使用这样的语法，并且如果目的模块设置了默认export，要引用模块的其他文件也<strong>必须使用</strong>这种不带{}引用的语法，当然名字也是可以任意指定的的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>使用es6 module时，同一个对象可能多次被不同的文件引用，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的状态管理器export const projectState = ProjectState.getInstance(); </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>初次引用后，后续就不会重复执行并引用了，相当于浏览器有一套缓存机制，对于之前已经import的对象，可以拿来直接用，而不用重新执行一次初始化或者声明什么的</strong></p>
</li>
<li><p><strong>无论用namespace还是用module（推荐）都要合理的设计目录，用于分放各个组件，有效管理</strong></p>
</li>
<li><p><strong>export后边直接跟一个函数调用的时候，暴露的就是函数的返回值</strong></p>
</li>
</ul>
</li>
<li><p>总的来说，使用module固然好，但是也有HTTP 请求次数过多，与浏览器兼容性问题（仅主流浏览器的最新版本支持，IE的旧版本可能不支持），所以引入第三方的打包工具–webpack</p>
</li>
<li><p><strong>需要注意的是本节中说的module是一种语法也是一种依赖治理的方式，不推荐使用这种依赖治理方式，但是export与import的语法是js es6官方原生支持的用来取代commonjs、AMD、CMD等的一种模块加载方式（同样也是ts默认支持的方式），在webpack还是可以继续使用这种语法的，只不过如果目标浏览器是旧版浏览器，需要调节编译的target，将export/import语法转为旧版的AMD模块加载语法（require）或者是目标运行环境为commonjs的nodejs，则编译为使用require方法的js代码</strong></p>
</li>
</ul>
<h2 id="ts与webpack"><a href="#ts与webpack" class="headerlink" title="ts与webpack"></a>ts与webpack</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/">webpack官方文档</a></p>
</li>
<li><p>webpack是一个前端的打包工具，可以将项目中的多个文件打包成一个文件，同时也可以自动优化代码，减小代码体积，减小HTTP请求的数量与请求体大小，除此之外，在CSS等方面也有其他功能</p>
</li>
<li><p>甚至可以做混淆加密等功能，以及开启本地服务器serve页面等功能（不用再开启lite-server了）</p>
<img src="http://images.demoli.xyz/20210106205018.png" style="zoom:80%;" /></li>
<li><p>项目中安装webpack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli webpack-dev-server typescript ts-loader --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li>ts-loader用来协助webpack执行ts文件的编译</li>
</ul>
</li>
<li><p>配置webpack</p>
<ul>
<li><p>配置ts项目的tsconfig.json</p>
<ul>
<li>target: webpack会根据此处的设定执行对应的编译工作</li>
<li>module同理(<strong>在drag项目中，此处维持es2015也没什么问题，但是当使用第三方模块时会出现无法找到模块的问题，此时应将此处更改为commonjs</strong>)</li>
<li>rootDir不用设置，webpack会接管</li>
</ul>
</li>
<li><p>在项目根目录创建<code>webpack.config.js</code></p>
<ul>
<li><p>此文件名是webpack的默认配置文件名，其js语法使用nodejs中使用的commonjs 包语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);<span class="built_in">module</span>.exports = &#123;    <span class="comment">// 设置打包模式为开发模式，这样可以使webpack做少量的优化，并给出尽量详细有用的日志信息    mode: &#x27;development&#x27;,    // 项目入口    entry: &#x27;./src/app.ts&#x27;,    output: &#123;        // 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.[contenthash].js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        publicPath: &#x27;/dist/&#x27;    &#125;,    // 声明ts支持生成sourcemap文件，webpack打包时应考虑提供sourcemap，便于debug    devtool: &#x27;inline-source-map&#x27;,    // module节点用来声明webpack处理不同类型的文件的方式，包括ts css img 等等    module: &#123;        // 对于不同类型的文件，在列表中可以有多种规则        rules: [            &#123;                // 用来筛选特定类型的文件,使用正则                test: /\.ts$/,                // 使用ts-loader组件处理ts文件                use: &#x27;ts-loader&#x27;,                // 不筛选此文件夹中的文件                exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)             &#125;        ]    &#125;,    // 依赖解析的配置    resolve: &#123;        // 依赖解析时需要解析的文件的后缀名        extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;]    &#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>webpack会从entry文件开始迭代依赖，并依此进行构建</li>
</ul>
</li>
</ul>
</li>
<li><p>项目中所有import from中的文件名的js后缀都应删除，保持无后缀即可</p>
<ul>
<li><strong>export与import语法与es6 module保持一致，只不过从浏览器解析依赖变成webpack解析依赖并进行项目构建</strong></li>
</ul>
</li>
<li><p>修改package.json，提供build命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>npm run-script build</code>进行构建</li>
</ul>
</li>
<li><p>如果要使用webpack-dev-server同样修改package.json即可：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Webpack-dev-server同时提供watch功能，可以自动编译ts文件</p>
</li>
<li><p>但是实际上执行自动编译之后并没有生效，实际上是因为更改后的编译结果并没有存储到磁盘中，可以将dist中的打包好的文件删除，再触发自动编译，可以发现没有新的文件生成，只会在内存中生成最新修改的打包文件，需要对webpack进行进一步的配置，明确打包文件的位置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;        <span class="comment">// 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        publicPath: &#x27;/dist/&#x27;    &#125;,</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开发环境下设置mode为development即可，但是生产环境下，需要做更多的设置</p>
<ul>
<li><p>创建一个专供生产环境打包的新的webpack配置文件<code>webpack.config.production.js</code>(名字任意)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);const clean = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123;    <span class="comment">// 设置打包模式为开发模式，这样可以使webpack做少量的优化，并给出尽量详细有用的日志信息    mode: &#x27;production&#x27;,    // 项目入口    entry: &#x27;./src/app.ts&#x27;,    output: &#123;        // 可以根据最终的内容哈希来命名，已解决浏览器缓存更新的问题        filename: &#x27;bundle.js&#x27;,        // webpack需要绝对路径而不是相对路径        path: path.resolve(__dirname, &#x27;dist&#x27;),        // 仅供webpack-dev-server使用，所以注释掉        // publicPath: &#x27;/dist/&#x27;    &#125;,    // 声明ts支持生成sourcemap文件，webpack打包时应考虑提供sourcemap，便于debug    devtool: false,    // module节点用来声明webpack处理不同类型的文件的方式，包括ts css img 等等    module: &#123;        // 对于不同类型的文件，在列表中可以有多种规则        rules: [            &#123;                // 用来筛选特定类型的文件,使用正则                test: /\.ts$/,                // 使用ts-loader组件处理ts文件                use: &#x27;ts-loader&#x27;,                // 不筛选此文件夹中的文件                exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)             &#125;        ]    &#125;,    // 依赖解析的配置    resolve: &#123;        // 依赖解析时需要解析的文件的后缀名        extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;]    &#125;,    // module工作在文件层面，plugin工作在workflow层面    plugins: [        new clean.CleanWebpackPlugin()    ]&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>插件安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li>此插件的作用在于每次重新构建，向目的文件夹写入新的打包文件之前，都能删除打包位置的旧文件，不用再手动删除之前打包的不用的旧文件了</li>
</ul>
</li>
<li><p>配置package.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,    <span class="attr">&quot;prodbuild&quot;</span>: <span class="string">&quot;webpack --config webpack.config.production.js&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>npm run-script probuild</code>执行编译即可</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>补充：使用了webpack后，html中引入js的方式不用再添加<code>type=module</code>因为最终打包成了一个js不用浏览器再去解析依赖了，同时最好也把<code>defer</code>加上</strong></p>
</li>
<li><p><strong>使用webpack的另外一个好处在于，使用第三方模块时，使用npm安装即可，不用引入script了，webpack会将依赖进行打包</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三方模块的引入"><a href="#第三方模块的引入" class="headerlink" title="第三方模块的引入"></a>第三方模块的引入</h2><ul>
<li>分为两类：<ul>
<li>普通js工程可以引入的第三方模块</li>
<li>只能在ts工程中使用的第三方模块</li>
</ul>
</li>
<li>注意<ul>
<li><strong>在drag项目中，tsconfig中的module处维持es2015也没什么问题，但是当使用第三方模块时会出现无法找到模块的问题，此时应将此处更改为commonjs</strong></li>
</ul>
</li>
</ul>
<h3 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h3><ul>
<li><p>纯js模块，在js工程中可以使用CDN加载也可以使用npm安装，<strong>在webpack项目中可以直接使用npm安装，就可以直接在源代码中使用import导入此模块并使用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save lodash</span><br></pre></td></tr></table></figure></li>
<li><p>在项目中引入lodash</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;<span class="built_in">console</span>.log(_.shuffle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<ul>
<li>但是，因为lodash是纯js项目，ts编译器并不能很好的将其引入到项目中，因此会报错，但是我们设置tsconfig中的noEmitOnError为false之后（不管编译是否出问题，都产出编译结果），并开启webpack-server后发现实际上是可用的</li>
</ul>
</li>
<li><p>对于纯js第三方模块理论上是可以转译成ts模块的，GitHub上的<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash">DefinitelyTyped项目</a>为众多主流js模块提供了对ts的转译</p>
<ul>
<li><p><strong>所谓的转译实际上就是提供了js原生模块的<code>.d.ts</code>文件，这些文件不提供具体的操作逻辑，只是向ts提供有关模块的一些类型，这使得ts编译器能够理解此js模块的类型，从而正确导入不会报错</strong></p>
</li>
<li><p>项目中的转译项目都可以使用npm安装到本地（前提是已经安装好了之前的纯js模块，或者以CDN形式获取了js库，比如下面的Google Map项目）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/lodash</span><br></pre></td></tr></table></figure>

<ul>
<li>所有的这些转译项目都以<code>@types</code>开头，Google中可以使用 <code>type $&#123;js模块名字&#125;</code>查询，一般就能查到对应的npm页面</li>
<li>只有在开发时会使用，因为最终都是编译成js文件，在部署后不再需要此模块</li>
</ul>
</li>
<li><p>对于自己写的js脚本，或者说一些实在没有转译版本的第三方的js库，使用<code>declare</code>将其引入到ts类型系统中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;dist/bundle.js&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        var GLOBAL = &#x27;GLOBAL!!&#x27;;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;js:declare var GLOBAL:string;console.log(GLOBAL);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>declare</code>后边是对于声明的变量的修饰符，不管其在其他js文件如何修饰，这里定义的是其在ts中的修饰符，ts会负责根据修饰符以及类型对此变量的操作进行检查</li>
<li><strong>之所以上述所说的转译或者declare可用的本质原因还是ts本身与js一样，ts的最终编译结果还是js，js可以兼容到ts中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="class-transformer"><a href="#class-transformer" class="headerlink" title="class transformer"></a>class transformer</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/typestack/class-transformer">Github</a></p>
</li>
<li><p>此模块既可以在ts中使用，也可以在js项目中使用</p>
</li>
<li><p><strong>其功能是将字面量objec与对应的class实例相互转化，或者是直接的对象的序列化于反序列化</strong></p>
</li>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install class-transformer --savenpm install reflect-metadata --save// 放在入口文件的头部位置import <span class="string">&#x27;reflect-metadata&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span>;<span class="keyword">import</span> &#123; plainToClass &#125; <span class="keyword">from</span> <span class="string">&#x27;class-transformer&#x27;</span>;<span class="keyword">import</span> &#123;Product&#125; <span class="keyword">from</span> <span class="string">&#x27;./product-model&#x27;</span>; <span class="comment">// 模拟json数据const products = [    &#123;title: &#x27;A&#x27;, price: 12&#125;,    &#123;title: &#x27;B&#x27;, price: 15&#125;,]// 手动转换products.map(product =&gt; &#123;    let p = new Product(product.title, product.price);    console.log(p.getInformation());&#125;)// 使用class transformerconst targetProducts = plainToClass(Product, products);for (const p of targetProducts) &#123;    console.log(p.getInformation());&#125;const product = new Product(&#x27;book&#x27;, 12);console.log(product.getInformation());</span></span><br></pre></td></tr></table></figure>

<h3 id="class-validator"><a href="#class-validator" class="headerlink" title="class validator"></a>class validator</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/typestack/class-validator">Github</a></p>
</li>
<li><p>此模块只能在ts中使用</p>
</li>
<li><p>注意要把tsconfig.json中的<code>&quot;experimentalDecorators&quot;: true, </code>打开</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; validate &#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;<span class="keyword">import</span> &#123;Product&#125; <span class="keyword">from</span> <span class="string">&#x27;./product-model&#x27;</span>;<span class="keyword">let</span> p = <span class="keyword">new</span> Product(<span class="string">&#x27;&#x27;</span>, -<span class="number">2</span>);<span class="comment">// 返回promisevalidate(p).then(errors =&gt; &#123;    if (errors.length &gt; 0 ) &#123;        console.log(errors);    &#125; else &#123;        console.log(p.getInformation());    &#125;&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Google-Map项目"><a href="#Google-Map项目" class="headerlink" title="Google Map项目"></a>Google Map项目</h2><ul>
<li><p>使用百度地图API与axios</p>
</li>
<li><p>axios是一个js库，但是其原生包含.d.ts声明文件，所以也可以在ts项目中使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure></li>
<li><p>在渲染地图时，尽管我们用的是CDN形式的开发库，但是还是可以在ts中使用declare来引用，但是只能为其设置any类型，为了获得更好的类型支持，使用第三方的type支持即可（获取匹配Google Map js库的声明文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/googlemaps</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="在Nodejs项目中使用ts"><a href="#在Nodejs项目中使用ts" class="headerlink" title="在Nodejs项目中使用ts"></a>在Nodejs项目中使用ts</h2><ul>
<li><p>首先明确：<strong>Nodejs不能作为ts的运行时环境（Deno可以），ts首先应该被编译为js文件才行</strong></p>
</li>
<li><p>可以使用<a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node工具</a>来直接运行使用ts编写的node工具，但是其本质上也就是先编译成js再用nodejs运行而已</p>
<ul>
<li>可以在开发时使用，但是不推荐在生产环境使用</li>
</ul>
</li>
<li><p><code>npm init</code>  <code>tsc --init</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随node版本锁支持的js版本而定&quot;target&quot;: &quot;es2018&quot;,                          /* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */&quot;module&quot;: &quot;commonjs&quot;,                     /* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */// 声明nodejs环境下的commonjs依赖管理模式，并且不再加载dom等包&quot;moduleResolution&quot;: &quot;node&quot;,&quot;outDir&quot;: &quot;./dist/&quot;,                        /* Redirect output structure to the directory. */&quot;rootDir&quot;: &quot;./src/&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>npm install --save express bodyparser nodemon</code></p>
</li>
<li><p>众所周知，nodejs使用commonjs的模块加载方式，使用require函数加载包，但是默认的ts并没有这个函数，需要安装第三方依赖<code>npm install --save-dev @types/node</code></p>
</li>
<li><p>可以顺利加载express后，发现没有任何类型提示，因为express是完全的js库，因此同样的，安装<code>npm install --save-dev @types/express</code></p>
<ul>
<li><strong>即便加载了这些包，但是如果使用commonjs的require语法的话，可以编译并执行，但是还是没有类型提示，这是因为ts默认不支持commonjs的语法，可以使用ts支持的 es6的import语法，最终编译的结果会被编译为require的方式，因为在配置文件中设置了<code>&quot;moduleResolution&quot;: &quot;node&quot;,</code></strong></li>
</ul>
</li>
<li><p>之前使用nodemon都是全局安装，可以直接在命令行中使用ndemon命令，但是如果仅在当前项目安装的话，不能直接在命令行中使用，此时使用npm脚本即可</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon dist/app.js&quot;</span>  &#125;,</span><br></pre></td></tr></table></figure></li>
<li><p><code>tsc -w</code>                <code>npm start</code></p>
</li>
<li><p><strong>可以说在nodejs项目中，ts的语法与浏览器端项目的语法一样，只不过被编译后的结果是不一样的格式</strong></p>
</li>
<li><p><strong>与webpack中一样，此时import时不用设置文件后缀名（因为node的运行机制本来就不需要识别后缀名）</strong></p>
</li>
<li><p><strong>如果要想获得nodejs后端开发中使用ts的最佳提要，去看看<a target="_blank" rel="noopener" href="https://nestjs.com/">nest.js</a>与<a target="_blank" rel="noopener" href="https://deno.land/">deno</a>吧，二者都原生支持ts的各种特性，并在框架内部充分使用了ts的特性比如修饰器等等，当然deno是与nodejs并行的另外一个js运行时环境了</strong></p>
<ul>
<li>除了上述两者之外，<a target="_blank" rel="noopener" href="https://angular.io/">Angular</a>是完全在ts的基础上开发的前端框架，有兴趣可以看看</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">vue学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-11 15:04:30 / Modified: 15:05:02" itemprop="dateCreated datePublished" datetime="2021-07-11T15:04:30+08:00">2021-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h1><ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/index.htm">Vue编码风格指南</a></li>
</ul>
<h2 id="Vue引入"><a href="#Vue引入" class="headerlink" title="Vue引入"></a>Vue引入</h2><ul>
<li><p>Vue是什么？</p>
<p><img src="http://images.demoli.xyz/image-20210107205128265.png" alt="image-20210107205128265"></p>
<ul>
<li>基于js的前端框架</li>
<li>提供交互式的响应式的前端应用（就和手机App一样）<ul>
<li>如何理解所谓的交互式与响应式呢？还是以手机App为例，与传统的网页不同，APP内充斥着丰富的交互操作，并且所有的页面与响应都无需等待加载（所有的页面都是只需要一次下载，后续没有任何界面的传输需要，只有数据的传输需要），而在传统web中，总是在等待着新的HTML界面下载得到新的界面</li>
<li>html中运行在浏览器的js可以改变这一现状，因为其可以更改dom，又可以发出HTTP请求来获取数据，也许这样，只需要一个页面（或者更少的界面），能做的事情就会很多，不用再等待界面HTML 的下载了</li>
<li>但是仅仅用js是一个巨大的工程，因此需要框架引入</li>
</ul>
</li>
</ul>
</li>
<li><p>两种使用Vue的场景</p>
<p><img src="http://images.demoli.xyz/image-20210107210923080.png" alt="image-20210107210923080"></p>
<ul>
<li><p>页面的一部分使用Vue构建，使其更加具有交互式与响应式的特定，比如页面聊天框，比如：</p>
<img src="http://images.demoli.xyz/image-20210107211102523.png" alt="image-20210107211102523" style="zoom:80%;" /></li>
<li><p>构建SPA（单页应用），服务器端只需要提供一次HTML界面，剩下的显式效果完全有HTML中包含的Vue代码操纵，后端只需要进行纯数据交互即可</p>
</li>
</ul>
</li>
<li><p>常用的三大前端框架</p>
<img src="http://images.demoli.xyz/image-20210107215857364.png" alt="image-20210107215857364" style="zoom:80%;" />

<ul>
<li>Angular 事无巨细，拥有丰富的组件选型，使用ts构建，项目组织严格分层，类型清晰，像是后端框架一样</li>
<li>React 轻薄，由社区提供众多的第三方功能</li>
<li>Vue 使用友好，功能复杂程度应该介于React与Angualr之间</li>
</ul>
</li>
</ul>
<h2 id="第一个Demo项目"><a href="#第一个Demo项目" class="headerlink" title="第一个Demo项目"></a>第一个Demo项目</h2><h3 id="使用纯JS完成"><a href="#使用纯JS完成" class="headerlink" title="使用纯JS完成"></a>使用纯JS完成</h3><ul>
<li>查看demo1项目的js-vue项目</li>
</ul>
<h3 id="使用Vue完成"><a href="#使用Vue完成" class="headerlink" title="使用Vue完成"></a>使用Vue完成</h3><ul>
<li><p>区别在于，使用纯js的时候，所有的对于DOM的操作与Data的操作是混合的，在Vue中，只需要声明Data，具体的Dom操作由Vue完成</p>
</li>
<li><p>Vue声明预期的DOM结构，具体的实现由Vue负责</p>
<ul>
<li><strong>声明式的开发是一个趋势</strong></li>
<li>所谓声明式就是声明好自己要渲染的数据位置，自己想要时间发生时要回调的函数，etc, 具体的操作由框架完成（针对vue来说）</li>
</ul>
</li>
<li><p><strong>自己实现了Vue3下的ts开发，但是没有使用webpack</strong></p>
<ul>
<li><p>```bash</p>
<h1 id="1-Install-Vue-CLI-如果尚未安装"><a href="#1-Install-Vue-CLI-如果尚未安装" class="headerlink" title="1. Install Vue CLI, 如果尚未安装"></a>1. Install Vue CLI, 如果尚未安装</h1><p>npm install –global @vue/cli@next</p>
<h1 id="2-创建一个新项目-选择-“Manually-select-features”-选项"><a href="#2-创建一个新项目-选择-“Manually-select-features”-选项" class="headerlink" title="2. 创建一个新项目, 选择 “Manually select features” 选项"></a>2. 创建一个新项目, 选择 “Manually select features” 选项</h1><p>vue create my-project-name</p>
<h1 id="3-选择choose-Vue-cersion与typescript，其余全部取消"><a href="#3-选择choose-Vue-cersion与typescript，其余全部取消" class="headerlink" title="3. 选择choose Vue cersion与typescript，其余全部取消"></a>3. 选择choose Vue cersion与typescript，其余全部取消</h1><h1 id="4-选择vue-3-x-useclass-style-component-syntax-选择y"><a href="#4-选择vue-3-x-useclass-style-component-syntax-选择y" class="headerlink" title="4. 选择vue 3.x useclass-style component syntax 选择y"></a>4. 选择vue 3.x useclass-style component syntax 选择y</h1><h1 id="5-Use-Babel-alongside-TypeScript-required-for-modern-mode-auto-detected-polyfills-transpiling-JSX-选择n"><a href="#5-Use-Babel-alongside-TypeScript-required-for-modern-mode-auto-detected-polyfills-transpiling-JSX-选择n" class="headerlink" title="5. Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? 选择n"></a>5. Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? 选择n</h1><h1 id="6-Where-do-you-prefer-placing-config-for-Babel-ESLint-etc-放在package-json中"><a href="#6-Where-do-you-prefer-placing-config-for-Babel-ESLint-etc-放在package-json中" class="headerlink" title="6. Where do you prefer placing config for Babel, ESLint, etc.? 放在package.json中"></a>6. Where do you prefer placing config for Babel, ESLint, etc.? 放在package.json中</h1><h1 id="7-可以考虑将上述的选择配置保存在一个自命名的模板配置中，此后在步骤2就可以选择了"><a href="#7-可以考虑将上述的选择配置保存在一个自命名的模板配置中，此后在步骤2就可以选择了" class="headerlink" title="7. 可以考虑将上述的选择配置保存在一个自命名的模板配置中，此后在步骤2就可以选择了"></a>7. 可以考虑将上述的选择配置保存在一个自命名的模板配置中，此后在步骤2就可以选择了</h1><h1 id="8-需要注意，可以在用户根目录下的-vuerc文件中设置是否使用淘宝镜像源"><a href="#8-需要注意，可以在用户根目录下的-vuerc文件中设置是否使用淘宝镜像源" class="headerlink" title="8. 需要注意，可以在用户根目录下的.vuerc文件中设置是否使用淘宝镜像源"></a>8. 需要注意，可以在用户根目录下的.vuerc文件中设置是否使用淘宝镜像源</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - **有的时候官方镜像源的速度比淘宝镜像源的速度快！！**</span><br><span class="line"></span><br><span class="line">  - 执行`npm run serve`，开启服务器，可以在本机端口8080访问App</span><br><span class="line"></span><br><span class="line">  - **使用import导入ts文件时，不用指定后缀名**</span><br><span class="line"></span><br><span class="line">  - **如果要使用ts语法需要单独将组件中的ts写到.ts文件中，而不要写在.vue的script标签中（不识别ts语法，而且会报错）**</span><br><span class="line"></span><br><span class="line">- 参考demo1项目的ts-vue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Vue核心概念</span><br><span class="line"></span><br><span class="line">- demo2文件夹的demo2-vue-ts项目</span><br><span class="line"></span><br><span class="line">- 创建与绑定Vue App实例</span><br><span class="line"></span><br><span class="line">  - **data属性，设置数据，此属性接受一个方法，法应返回一个对象，对象的键值对就是绑定的DOM（由vue负责管理维护）与对应的初始值（初始值可以是任何对象类型）**</span><br><span class="line">    - **data属性对应的函数返回值对象会被Vue设置为一个Vue App内部的全局对象并绑定到`this`关键字，这意味着在APP内的其他地方（比如说methods属性内定义的方法中）都可以使用this来索引返回对象中的属性**</span><br><span class="line">      - 需要注意的是不仅仅是此返回值内部的属性绑定到了this中，还有其他的一些属性也绑定了，比方说methods属性中定义的方法也会绑定到this关键字中</span><br><span class="line">  - methods属性</span><br><span class="line">    - 此属性可以定义一些事件回调方法，也可以是用作其他用途的方法</span><br><span class="line">    - 此属性接受一个对象，对象内部存储的值是函数（可以是键值对的形式（值为匿名函数），当然也可以直接设置为函数形式（函数名就是键的名字））</span><br><span class="line">    - **在此属性中定义的函数可以在interpolation中或v-bind中调用执行**</span><br><span class="line">  - methods中定义的方法与data中定义的属性一样可以在Vue App中使用this索引调用</span><br><span class="line"></span><br><span class="line">- HTML标签语法：</span><br><span class="line"></span><br><span class="line">  - Vue 的interpolation语法： 将数据绑定到DOM `&#123;&#123;&#125;&#125;`</span><br><span class="line"></span><br><span class="line">    - **注意此语法只能用在html tag内部例如`&lt;P&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;`，而不能用来渲染标签属性的值**</span><br><span class="line">    - 此大括号中可以执行简单地js expression，比如`&#123;&#123;Math.random()&#125;&#125;`或`&#123;&#123;1+1&#125;&#125;`但不能执行复杂的多行语句,当然也可以执行Vue中定义好的方法，例如`&lt;P&gt;&#123;&#123;desc()&#125;&#125;&lt;/p&gt;`**在括号内，可以指定参数，后续类似的不再说明**</span><br><span class="line">      - 注意若是在此语法中调用Vue中定义的函数，必须要加上括号，以示调用。正如下边所言**任意类型的变量的值都将转换成字符串形式渲染在此处（包括函数）**</span><br><span class="line">      - **!! 在此语法中直接调用函数有以下的弊端（也包括在v-bind和v-html中使用函数的场景，或者说HTML的Vue标签中没有与事件绑定的方法都会被重新执行一遍，以彻底渲染可能存在的函数中的变量调用）**</span><br><span class="line">        - 当其他事件触发HTML其他部位的内容改变时，Vue会只重新渲染特定部位，但是每次渲染时都会重新渲染`&#123;&#123;somefunc()&#125;&#125;`，这导致其内部的函数调用会多次重复执行，**这是因为Vue不确定函数内部是否有调用被其他事件触发而导致修改的变量，所以会默认重新渲染调用**</span><br><span class="line">        - 综上，在p标签这样的标签内部动态渲染数据的话，不太适合用函数，那么除了使用APP内设置的函数外其他的方法是？**Computed**</span><br><span class="line">    - **任意类型的变量的值都将转换成字符串形式渲染在此处**</span><br><span class="line"></span><br><span class="line">  - v-bind： **标签属性绑定，将`v-bind:`放置在标签属性名前，声明Vue绑定此属性到某一个数据变：`&lt;a v-bind:href=&#x27;content&#x27;&gt;&lt;a&gt;`将content变量的值绑定到href属性上**</span><br><span class="line"></span><br><span class="line">    - v-bind绑定的属性的属性值中可以执行简单地js expression，比如`&#123;&#123;Math.random()&#125;&#125;`或`&#123;&#123;1+1&#125;&#125;`但不能执行复杂的多行语句</span><br><span class="line">    - 当然属性之中也能调用定义好的方法，**可以带括号也可以不带括号**</span><br><span class="line">    - **注意v-bind是单向绑定，只能从Vue映射到HTML HTML的内容改变时不会使Vue的数据改变。 实际上考虑到兼容性的话，v-bind属性中甚至可以执行函数，怎么可能是双向绑定呢，包括其他可以调用函数的Vue属性都应当是如此**</span><br><span class="line">    - **v-bind可以简写为只留一个`:`即可**：`&lt;a :href=&#x27;content&#x27;&gt;&lt;/a&gt;`</span><br><span class="line"></span><br><span class="line">  - `v-html`： 渲染HTML语句，使用`v-html`，使用上述两个标签渲染内容时并不能渲染html格式的字符串，只会以纯字符串的形式展示出来，这是比较安全的做法，如果目的就是渲染HTML语句的话，可以使用v-html标签`&lt;p v-html=&#x27;content&#x27;&gt;&lt;/p&gt;`</span><br><span class="line"></span><br><span class="line">    - 同样的，这里也可以放置函数调用，与`&#123;&#123;&#125;&#125;`语法类似</span><br><span class="line">    - **需要注意的是，此vue属性会覆盖掉作用的标签内部的所有内容，包括子标签，所以使用此属性是，标签内部应为空**</span><br><span class="line">    - **不推荐使用此属性，因为会引入安全问题，[CSRF跨站请求伪造攻击](https://app.yinxiang.com/shard/s16/nl/19429360/485026a9-af01-4732-8473-967886619f89/)**</span><br><span class="line"></span><br><span class="line">  - v-on 事件监听注册 `&lt;button v-on:click=&#x27;methods属性中定义的函数名&#x27;&gt;CLick&lt;/button&gt;`</span><br><span class="line"></span><br><span class="line">    - **可以认为能放函数调用的地方都能设置简单的js语句,但是并不推荐在html中写js逻辑，哪怕就是简单的依据js expression**</span><br><span class="line"></span><br><span class="line">    - 函数如果不指定参数或者不带括号，会默认接受Event类型的参数，可以获得事件的元信息，比如`&lt;input type=&#x27;text&#x27; v-on:input=&quot;getInput&quot;&gt;  `,可以获得用户输入的值`this.name= (&lt;HTMLInputElement&gt;event.target).value;`</span><br><span class="line"></span><br><span class="line">      - **如果在事件回调函数调用中制定了自己的参数，默认的事件对象会被覆盖消失，如果既要自定义参数又要Event对象的话，可以使用`$event`这个特殊变量做形参，浏览器会将事件对象绑定到此变量**</span><br><span class="line"></span><br><span class="line">        ```js</span><br><span class="line">        &lt;input type=&#x27;text&#x27; v-on:input=&quot;setName($event, &#x27;lee&#x27;)&quot;&gt;  </span><br><span class="line">        </span><br><span class="line">          setName(event: Event, secondName: string) &#123;</span><br><span class="line">          this.name= (&lt;HTMLInputElement&gt;event.target).value + &#x27; &#x27; + secondName;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>补充：<strong>Vue内部在重新渲染html时，只会渲染更新数据的部分，而不会整个页面渲染，以提高性能</strong></p>
</li>
<li><p>补充</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showAlert(&#x27;button click&#x27;)&quot;</span>&gt;</span>show alert<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>在vue属性内部可以执行简单的js语句，但是对于alert与console.log()这样的函数而言，是不能执行的，因为在vue template环境中并不能识别alert这个全局方法或者console这个全局对象，另外在v-on属性的值中可以执行js语句方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;$emit(&#x27;delete-friend&#x27;, id)&quot;&gt;Delete&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在vue中直接调用Vue全局对象（this）下的属性与方法时都可以不加this，比如这里的<code>$emit</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>v-on:</code>标识可以简写为<code>@</code>&lt;button type=’submit’ @click=”formSubmitHandler”&gt;Click </button>`</p>
</li>
<li><p>事件修饰符</p>
<ul>
<li><p>例如表单提交事件，要阻止其默认行为，可以在事件监听回调函数中获取Event对象阻止，也可以直接在vue属性上使用事件修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;formSubmitHandler&quot;</span>&gt;</span>Click <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">formSubmitHandler (event: Event) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用事件修饰符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<form>
    <button type='submit' v-on:click.prevent="formSubmitHandler">Click </button>
  </form>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      </span><br></pre></td></tr></table></figure></li>
<li><p>例如鼠标点击事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--只有按下右键点击才能触发点击事件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.right</span>=<span class="string">&#x27;add(10)&#x27;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如键盘事件，目标是要在输入之后按下enter才能执行特定操作</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以绑定多个事件监听机制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;setName($event, &#x27;lee&#x27;)&quot;</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;confirmInput&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">setName(event: Event, secondName: string) &#123;</span><br><span class="line">      this.name= (<span class="tag">&lt;<span class="name">HTMLInputElement</span>&gt;</span>event.target).value + &#x27; &#x27; + secondName;</span><br><span class="line">&#125;,</span><br><span class="line">confirmInput() &#123;</span><br><span class="line">       this.confirmName = this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>v-once 使用此属性的标签内部的动态数据会被锁定为初始值，不会进行动态渲染，比较少用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Result: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>initial counter: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>v-model</p>
<ul>
<li><p>前边说的v-bind与v-on的事件出发都只是单向绑定的操作</p>
<ul>
<li>v-bind是由Vue的数据渲染到HTML</li>
<li>v-on是由HTML的事件触发并携带数据设置到Vue App中</li>
</ul>
</li>
<li><p>v-model可以实现双向绑定，用以将<input>, <textarea> and <select>标签（<strong>仅能用在此三个标签</strong>）的值与Vue双向绑定，从而实现互相影响动态改变，在v-model属性值中指定Vue变量名即可</p>
<ul>
<li><p>举例对于input标签来说，以下两种写法本质上一样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>    <span class="attr">v-on:input</span>=<span class="string">&quot;setName($event, &#x27;lee&#x27;)&quot;</span>    <span class="attr">v-bind:value</span>=<span class="string">&quot;name&quot;</span>  /&gt;</span>  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;resetInput&quot;</span>&gt;</span>Reset Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">input</span>    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>    <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>  /&gt;</span>  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;resetInput&quot;</span>&gt;</span>Reset Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span>resetInput () &#123;        this.name = &#x27;&#x27;;    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>computed 属性</p>
<ul>
<li><p>与methods属性类似，但是computed属性内部定义的函数放置到html中后，Vue能够分析其依赖，只有在其依赖变动时，才会重新渲染执行函数</p>
</li>
<li><p><strong>computed属性内部定义的方法名应当与属性名类似，因为其调用方法不是函数式的调用方法，而是索引属性（即使用此函数时不能加小括号，Vue负责执行此函数）</strong></p>
<ul>
<li>显然此类函数不能定义参数</li>
</ul>
</li>
<li><p>注意此属性中定义的函数一般用于<code>&#123;&#123;&#125;&#125;`语法中，至于事件绑定的函数还是用methods属性内部定义的方法

  - **在此属性内部定义的函数如果有返回值的时候（使用场景决定其肯定有返回值）必须明确返回值类型（如果有的话）否则会有莫名其妙的错误：`Property 'name' does not exist on type ComponentPublicInstance`**

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;    fullName():string &#123;      <span class="built_in">console</span>.log(<span class="string">&quot;work!&quot;</span>);      <span class="keyword">if</span> (<span class="built_in">this</span>.name === <span class="string">&quot;&quot;</span>) &#123;        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;      &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> (<span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="string">&quot;jia&quot;</span>);      &#125;    &#125;  &#125;,             <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You name: &#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

  - **computed定义的成员类型上是函数，但是使用方式是属性（与data类似），不仅仅可以在HTML中使用，也可以在Vue App中使用this来索引获取其值**

- watch属性 

  - 与computed类似，可以都是在依赖更改后，自动被Vue执行的函数，差异在于：

    - **computed用于渲染内容时使用函数**
    - **watchers用于依赖更改后执行特定的逻辑，而不是返回值用于渲染**

  - watchers内部定义的函数**应该与要绑定的依赖（属性）同名，Vue会自动绑定关系**，当属性的值变动时，自动执行watchers内部的同名方法

  - 函数可以不指定参数，使用this索引属性，获取属性的最新的值，也可以设置参数，以获得Vue传来的对应绑定属性的新值与旧值（两个参数都是可选的）

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;    <span class="keyword">return</span> &#123;      <span class="attr">counter</span>: <span class="number">0</span>,      <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,      <span class="attr">fullName</span>: <span class="string">&#x27;&#x27;</span>    &#125;;  &#125;,<span class="attr">watch</span>: &#123;    name (newValuue, oldValue) &#123;        <span class="built_in">console</span>.log(oldValue);        <span class="built_in">this</span>.fullName = newValuue + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;jia&#x27;</span>;    &#125;  &#125;,</span><br></pre></td></tr></table></figure>

  - watch可以监听属性变化，但是不如computed方便，因为computed的函数会自动分析依赖的变化（**依赖不止一个**），但是watch内部定义的函数必须对所有依赖都设定一个函数，比较麻烦

  - 因此watcher内部定义的函数适合绑定单个属性，并只做更改该属性的逻辑，**如果要与其他watch函数共同更改同一个渲染值的话，使用computed更方便（不是不可以，只是更方便）**

  - **watch可以与computed中定义的属性（虽然是方法形式，但是视作是属性）绑定，与data中的属性类似，同名即可**

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;    <span class="keyword">return</span> &#123;      <span class="attr">counter</span>: <span class="number">0</span>,    &#125;;  &#125;,  <span class="attr">watch</span>: &#123;    <span class="comment">// 仅在finalCounter返回值改变时触发执行    finalCounter() &#123;        const that = this;        setTimeout(() =&gt; &#123;            that.counter = 0;        &#125;, 5000);    &#125;  &#125;,  computed: &#123;    finalCounter(): string | number &#123;      if (this.counter &lt; 37) &#123;        return &quot;not yet&quot;;      &#125; else if (this.counter &gt; 37) &#123;        return &quot;too much&quot;;      &#125;      return 37;    &#125;,  &#125;,  methods: &#123;    add(num: number) &#123;      this.counter += num;    &#125;,  &#125;,&#125;);</span></span><br></pre></td></tr></table></figure>

    

- watch与computed与methods的区分使用

  ![image-20210110155134559](http://images.demoli.xyz/image-20210110155134559.png)

  - methods最好仅用于事件绑定
  - computed用于内容渲染
  - watch用来执行非数据更改类型的逻辑

- 动态样式

  - 两种方式

    - inline style属性 （不常用）

      <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="comment">&lt;!-- html中的几乎所有标签都能注册点击事件 --&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;borderColor: boxASelected ? &#x27;red&#x27;: &#x27;#ccc&#x27;&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;select(&#x27;A&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;borderColor: boxBSelected ? &#x27;red&#x27;: &#x27;#ccc&#x27;&#125;&quot;</span>  @<span class="attr">click</span>=<span class="string">&quot;select(&#x27;B&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;borderColor: boxCSelected ? &#x27;red&#x27;: &#x27;#ccc&#x27;&#125;&quot;</span>  @<span class="attr">click</span>=<span class="string">&quot;select(&#x27;C&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

      - 使用style属性在标签内配置样式或者通过设置class id等在css文件中全局配置样式`<div class="demo" style="border-color: red" @click="select('A')"></div>`
      - 为了使用Vue动态设置样式，使用v-bind绑定此属性，此时style属性的值可以使用特殊语法：`<div class="demo" :style="&#123;'border-color':'red'&#125;" @click="select('A')"></div>`或者`<div class="demo" :style="&#123;borderColor:'red'&#125;" @click="select('A')"></div>`推荐使用后者，此时style的值是一个样式对象，样式对象中的值可以直接使用Vue中定义的变量

    - **vue中所有类似的写法中，对象的属性名中如果有多个`-`，应该用引号括起来**

- class属性(直接赋class值)

      <figure class="highlight plaintext"><figcaption><span><!-- html中的几乎所有标签都能注册点击事件 -->  <div :class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
    - 实际上还有更方便的写法（使用boolean标识）        ```html      <template>        <!-- html中的几乎所有标签都能注册点击事件 -->        <div :class="&#123;demo: true, active: boxASelected &#125;"  @click="select('A')"></div>        <div :class="&#123;demo: true, active: boxBSelected &#125;"  @click="select('B')"></div>        <div :class="&#123;demo: true, active: boxCSelected &#125;"  @click="select('C')"></div>      </template>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **class属性接受一个对象，对象的键名是class名字，值为truthy或者falsy，表示对象的class是否被添加到此标签中**</span><br><span class="line"></span><br><span class="line">- 因为默认都有demo这个class，其并非动态的，所以可以提出来使用普通的class属性标识，Vue会自动将动态class与静态class合并</span><br><span class="line"></span><br><span class="line">    ````html</span><br><span class="line">  &lt;template&gt;  &lt;!-- html中的几乎所有标签都能注册点击事件 --&gt;  &lt;div class=&quot;demo&quot; :class=&quot;&#123;active: boxASelected &#125;&quot;  @click=&quot;select(&#x27;A&#x27;)&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;demo&quot; :class=&quot;&#123;active: boxBSelected &#125;&quot;  @click=&quot;select(&#x27;B&#x27;)&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;demo&quot; :class=&quot;&#123;active: boxCSelected &#125;&quot;  @click=&quot;select(&#x27;C&#x27;)&quot;&gt;&lt;/div&gt;&lt;/template&gt;</span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">  - 静态class与动态class也可以写在一个数组当中</span><br><span class="line"></span><br><span class="line">        ```html&lt;template&gt;  &lt;!-- html中的几乎所有标签都能注册点击事件 --&gt;  &lt;div :class=&quot;[&#x27;demo&#x27;, boxAActive]&quot;  @click=&quot;select(&#x27;A&#x27;)&quot;&gt;&lt;/div&gt;  &lt;div :class=&quot;[&#x27;demo&#x27;, boxBActive]&quot;  @click=&quot;select(&#x27;B&#x27;)&quot;&gt;&lt;/div&gt;  &lt;div :class=&quot;[&#x27;demo&#x27;,boxCActive]&quot;  @click=&quot;select(&#x27;C&#x27;)&quot;&gt;&lt;/div&gt;&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- class的值如果需要比较复杂的逻辑判断的话，可以使用computed属性</span><br><span class="line"></span><br><span class="line">      ```jsexport default defineComponent(&#123;  data() &#123;      return &#123;        boxASelected: false,        boxBSelected: false,        boxCSelected: false,      &#125;;  &#125;,  methods: &#123;      select(box:string) &#123;          switch (box) &#123;              case &#x27;A&#x27;:                 this.boxASelected = !this.boxASelected;                break;            case &#x27;B&#x27;:                this.boxBSelected = !this.boxBSelected;                break;            case &#x27;C&#x27;:                this.boxCSelected = !this.boxCSelected;                break;          &#125;      &#125;  &#125;,  computed: &#123;      boxAActive ():&#123;active: boolean&#125; &#123;        return &#123;active: this.boxASelected &#125;;      &#125;,      boxBActive ():&#123;active: boolean&#125; &#123;        return &#123;active: this.boxBSelected &#125;;      &#125;,      boxCActive ():&#123;active: boolean&#125; &#123;        return &#123;active: this.boxCSelected &#125;;      &#125;,  &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关于动态样式的小demo</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  import &#123; defineComponent &#125; from &quot;vue&quot;;// 引入css组件import &quot;./App.css&quot;;interface In &#123;    userInput1: string;    userInput2: string;    isHidden: boolean &#125;// 在vue3中将App配置对象放到函数defineComponent中以使ts正确推断出其中的类型，比如thisexport default defineComponent(&#123;  data() :In&#123;      return &#123;        userInput1: &#x27;&#x27;,        userInput2: &#x27;&#x27;,        isHidden: false      &#125;;  &#125;,  methods: &#123;      toogleP () &#123;        this.isHidden = ! this.isHidden;      &#125;  &#125;,  computed: &#123;      pClass (): string[] &#123;          return [this.userInput1, this.isHidden? &#x27;hidden&#x27;:&#x27;visible&#x27;];      &#125;  &#125;&#125;);</span><br></pre></td></tr></table></figure>

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; &lt;input type=&#x27;text&#x27; v-model=&quot;userInput1&quot;&gt; &lt;p :class=&quot;pClass&quot;&gt;   Style Me! &lt;/p&gt; &lt;button @click=&quot;toogleP&quot;&gt;Toggle Paragraph&lt;/button&gt; &lt;input type=&#x27;text&#x27; v-model=&quot;userInput2&quot;&gt; &lt;p :style=&quot;&#123;backgroundColor: userInput2&#125;&quot;&gt;   Style Me inLine! &lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; src=&#x27;./App.ts&#x27;&gt;&lt;/script&gt;&lt;!--在这里写script会报错--&gt;</span><br></pre></td></tr></table></figure>

    - 需要注意的是尽量把逻辑写在ts中而不是html中

## 条件渲染与列表渲染

- 条件渲染是交互响应式的前端APP中很常见的功能，即根据数据的状态来判断特定DOM是否存在

- 仍然从以demo入手

- 条件渲染

  - v-if，其值可以为js expression methods computed属性或者是data中定义的属性等等，只要对应的值是一个boolean的值，就可以。此属性可决定其作用的标签及其子标签在何种情况下得到渲染
  - v-else 配合v-if使用，需要注意的是v-else务必要在紧挨着v-if的下一个HTML标签中（**不能是子标签！**）使用，中间不能间隔标签
  - v-else-if 逻辑类似，**注意使用顺序，以及必须无间隔的使用**
  - v-show 
    - 与v-if的渲染作用类似，都使用逻辑判断进行条件渲染
    - 不与v-else等配合使用而是单独使用
    - 其实现机制与v-if不同
      - 当v-if逻辑判定为不渲染时，整个对应的DOM组件会被直接删除，而v-show只是添加一个style属性进行hidden，但是DOM结构本身依然存在
      - **v-if适用于更改次数比较少的场景，v-show适用于经常更改的DOM，比如频繁切换的按钮等等**

- 列表渲染

  - v-for，其可遍历值的来源同样可以是多种样式，但是最终遍历的值应该是一个可以遍历迭代的对象

    - 例如`<li v-for="goal in goals">&#123;&#123; goal &#125;&#125;&lt;/li&gt;</code></p>
<ul>
<li>支持对于对象数列的属性索引，例如<code>&lt;li v-for=&quot;goal in goals&quot;&gt;&#123;&#123; goal.name &#125;&#125;&lt;/li&gt;</code></li>
</ul>
</li>
<li><p><strong>v-for应该放在要循环的HTML标签（li）上,而不是ul上</strong></p>
</li>
<li><p>goal变量的作用于仅限于v-for作用的标签内部（<strong>包含内部的子标签</strong>）</p>
</li>
<li><p><strong>Vue渲染列表时，当列表数据变动时，只重新渲染新变动的数据，列表中原有的未变动的数据不会重新渲染，这样可以提升性能</strong></p>
<ul>
<li><strong>vue的动态渲染过程可以在Chrome控制台中的elements中观察到，变动的标签会有一个闪烁</strong></li>
</ul>
</li>
<li><p>支持获取成员的索引:<code>&lt;li v-for=&quot;(goal, index) in goals&quot;&gt;&#123;&#123; index + 1 &#125;&#125; : &#123;&#123; goal &#125;&#125;&lt;/li&gt;</code></p>
</li>
<li><p>支持对于object的遍历渲染<code>&lt;li v-for=&quot;(value, key, index) in &#123;name: &#39;lijia&#39;, age: 23&#125;&quot;&gt;&#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/li&gt;</code></p>
<ul>
<li><p>最终的渲染效果为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>name : lijia - 0<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>age : 23 - 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>支持快捷遍历自然数数组<code>&lt;li v-for=&quot;num in 10&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/li&gt;</code></p>
<ul>
<li>从1开始</li>
</ul>
</li>
<li><p>注意事项，<strong>不要在同一标签内部使用v-for与v-if，可以在v-for的子标签内部使用v-if，在子标签内部v-if同样可以使用v-for的迭代的变量</strong></p>
</li>
<li><p>奇怪的BUG</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>My course goals<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInput&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addGoal&quot;</span>&gt;</span>Add Goal<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;goals.length === 0&quot;</span>&gt;</span>    No goals have been added yet - please start adding some!  <span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-else</span>&gt;</span>    <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;deleteGoal(index)&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(goal, index) in goals&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; index + 1 &#125;&#125; : &#123;&#123; goal &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>      <span class="comment">&lt;!-- 事件修饰符，使得鼠标点击输入框时，输入框的父标签的触发事件会被终止，但是在除了输入框的其他父标签内部，都会正常触发--&gt;</span>      <span class="comment">&lt;!--因为没有要指定的触发函数，所以可直接省略--&gt;</span>      <span class="tag">&lt;<span class="name">input</span> @<span class="attr">click.stop</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span>    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>BUG在于，当有两个li，在第一个li中输入内容，之后删除第一个li，输入框中的内容会自动转移到下一个个li中，或者说每当删除列表前边的元素后，其内部的input的内容就会覆盖到紧挨着的下一个元素中，并且这种迭代是顺延的</strong></p>
<ul>
<li><p>bug的原因在于: <strong>vue为例提升性能，在列表渲染过程中，会复用被删除的列表元素中的内部的子标签（因为每个元素都有相同的子标签）,复用的过程中，对于模板语法部分<code>&#123;&#123;&#125;&#125;`会重新渲染器内容，对于普通的HTML标签，比如案例中的input标签会直接复用**
      - 解决办法是在使用v-for的时候添加`key`这个属性，此标签属性并非HTML中的属性，而是Vue引入的，此属性的值用来唯一标识列表中的每一个成员
        - **取什么值作为唯一标识内容，一般就是数据库的ID，注意不能是索引，索引是动态变化的，不与内容绑定，不能作为唯一标识**
        - 有了唯一标识后，Vue不再复用被删除的元素中的内容
        - **注意此key属性应使用v-bind绑定，所有应为`:key`**
    - **综上，使用v-for时尽量总是使用key属性以保证Vue能够区分每一个子元素，避免状态丢失**

- Demo 记录

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;h2&gt;My course goals&lt;/h2&gt;  &lt;input type=&quot;text&quot; v-model=&quot;userInput&quot; /&gt;  &lt;button @click=&quot;addGoal&quot;&gt;Add Goal&lt;/button&gt;  &lt;p v-if=&quot;goals.length === 0&quot;&gt;    No goals have been added yet - please start adding some!  &lt;/p&gt;  &lt;ul v-else :style=&quot;&#123;display: isHidden? &#x27;none&#x27;:&#x27;&#x27;&#125;&quot;&gt;    &lt;li @click=&quot;deleteGoal(index)&quot; v-for=&quot;(goal, index) in goals&quot; :key=&quot;goal&quot;&gt;      &lt;p&gt;&#123;&#123; index + 1 &#125;&#125; : &#123;&#123; goal &#125;&#125;&lt;/p&gt;      &lt;input @click.stop type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;button @click=&quot;toggleListStatus&quot;&gt;&#123;&#123;buttonStatus&#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; src=&#x27;./App.ts&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;<span class="comment">// 引入css组件import &quot;./App.css&quot;;interface In &#123;    goals: string[];    userInput: string;    isHidden: boolean&#125;// 在vue3中将App配置对象放到函数defineComponent中以使ts正确推断出其中的类型，比如thisexport default defineComponent(&#123;  data() :In&#123;      return &#123;        goals: [],        userInput: &#x27;&#x27;,        isHidden: false      &#125;;  &#125;,  methods: &#123;      addGoal(): void &#123;        if (this.userInput !== &#x27;&#x27;) &#123;            this.goals.push(this.userInput);            this.userInput = &#x27;&#x27;;        &#125;      &#125;,      deleteGoal(index: number): void &#123;          this.goals.splice(index, 1);      &#125;,      toggleListStatus() &#123;        this.isHidden = ! this.isHidden;      &#125;  &#125;,  computed: &#123;    buttonStatus (): string &#123;        return this.isHidden? &#x27;show list&#x27;: &#x27;hidden list&#x27;;    &#125;  &#125;&#125;);</span></span><br></pre></td></tr></table></figure>

  

## Attack Monster Demo

- 补充知识：**css属性是字符串值，比如`width: 100%` 并不是number类型**
- 详见源码



## Vue的内部机制

- Vue会跟踪data属性中定义的值，并且将定义的属性（以及methods中定义的函数和computed中定义的属性）绑定到一个全局对象中，并让Vue App 中的this指向此全局对象 

- Vue会将data中定义的属性包装为交互式属性，**操作方法就是使用js中的Proxy**，包装为交互式属性的作用就是，每当此属性被赋予新的值得时候，Vue都能知晓----**这是最关键的第一步，只有这样Vue才能在数据变化时尝试去更新HTML中的渲染效果**

  - js中的变量默认不是交互式的变量，比如下边的案例

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;hello&#x27;</span>;<span class="keyword">let</span> longMessage = message + <span class="string">&#x27; world&#x27;</span>;<span class="comment">// hello worldconsole.log(longMessage);message = &#x27;hello!!!&#x27;;// hello worldconsole.log(longMessage);</span></span><br></pre></td></tr></table></figure>

    - js并不会意识到message改变了，也不会因为数据的变动去重复执行字符串的拼接

  - proxy的使用

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span>,    <span class="attr">longMessage</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;<span class="keyword">const</span> handler:ProxyHandler&lt;&#123;<span class="attr">message</span>: string, <span class="attr">longMessage</span>: string&#125;&gt; = &#123;    <span class="comment">// 被代理对象的属性被修改就会触发handler中的此函数    set(target, key, value)&#123;        /*        // target是被代理的对象，注意其属性不会修改(js默认都是非交互式的变量)        console.log(target);        // 被修改的属性名        console.log(key);        // 被赋予的新的属性值        console.log(value);        // 返回值得作用暂且不知        */        // 监听一个属性，并更新另外的属性，这也是Vue最常做的事        // 注意此函数只负责监听，数据的修改需要显式完成        if (key === &#x27;message&#x27;) &#123;            target.longMessage = value + &#x27; World&#x27;;        &#125;        target.message = value;        return true;    &#125;    &#125;const proxy = new Proxy(data, handler);// 被代理的对象的属性会自动绑定在proxy对象上proxy.message = &#x27;Hello!!!&#x27;;// Hello!!! Worldconsole.log(proxy.longMessage);</span></span><br></pre></td></tr></table></figure>

    

- 同一个页面中可以绑定多个Vue App，但是需要注意的是，这些Vue App 之间是相互独立的

- 关于Template

  - 实际上Vue App挂载点所在的HTML 节点被称为Vue App 的 Template

  - template可以作为Vue App的一个配置属性，但是在ts或者js中写html是不推荐的

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;      <span class="keyword">return</span> &#123;        <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>      &#125;;    &#125;,    <span class="attr">methods</span>: &#123;          &#125;,    <span class="attr">template</span>: <span class="string">`&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;`</span>&#125;)</span><br></pre></td></tr></table></figure>

    - 实际上使用脚手架构建项目后，模板HTML可以被写在`.vue`文件中

  - 关于用户输入的另外一种获取方法

    - 目前为止，获取用户输入有两张方法

      - @input
      - v-model

    - 以上两者的做法共同点在与用户的输入与Vue属性数据是实时同步更新的，如果不要求同步更新，只是在特定情况下需要获取输入，则使用Refs

      - 使用ref属性，此标签与key属性一样都是Vue属性，不是HTML属性，可以作用在任意HTML标签

        <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">ref</span>=<span class="string">&#x27;userInput&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

        - **ref属性指定的值会被Vue缓存，以备需要时使用，注意此值不是Vue中定义的变量名，仅仅是一个id而已**
        - **不需要使用`:ref`进行绑定（并不需要为此标签属性绑定动态内容，v-bind是用来向标签属性输出动态内容的，而这里的数据流动方向完全相反）**

      - 在Vue App中获取指定id对应的HTML标签

        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;      <span class="keyword">return</span> &#123;        <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span>      &#125;;    &#125;,    <span class="attr">methods</span>: &#123;      <span class="function"><span class="title">setText</span>(<span class="params"></span>)</span> &#123;        <span class="comment">// this中的以$开头的属性即为Vue提供的内置属性        // 注意索引ID得到的是对应的HTML标签对象，也就是HTMLElement类型的对象,实际上与event.target一样        this.message = this.$ref.userInput.value;      &#125;    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

- Vue更新DOM的方法：使用Virtual DOM

  <img src="http://images.demoli.xyz/image-20210119205230894.png" />

  - Vue App中的数据连同Vue Template被渲染到Browser DOM中，与此同时Template中的Vue属性和语法会被删除
  - Vue会根据数据的变动做局部更新，而不会每次数据变动就重新渲染整个界面
    - Vue是如何做到局部更新的呢？或者说在渲染过程中提升性能的方法是？
      - Virtual DOM
        - <img src="http://images.demoli.xyz/image-20210119205856115.png" alt="image-20210119205856115" style="zoom:67%;" />
        - - Virtual DOM实际上就是把实际的DOM按照js对象的格式维护在内存中，当Vue数据发生变化时，会重新渲染一份Virtual DOM 在内存中（**实际上Vue有更多的其他的优化手段，比如这里，并非重新渲染一份完整的虚拟DOM，也只是渲染部分**），然后比较内存中的两份虚拟DOM 不同之处渲染到实际的DOM中

- Vue App Lifecycle

  - Vue实例的生命周期，Vue实例有许多生命节点，并且提供了hook，可以使用这些hook，在Vue的特定生命阶段，执行特定的代码

    <img src="http://images.demoli.xyz/image-20210119211810400.png" alt="image-20210119211810400" style="zoom:80%;" />

    - 注意在beforeMount hook处Template还没有被渲染到浏览器的DOM中，在mounted hook处，已经得到渲染
    - 同理，在beforeUpdate处更新还没有被渲染到浏览器DOM中，在update处，更新得到渲染
    - **Vue App的unmount在目前为止并未用到，可以使用`const app = createApp(vueConfig).mount('#app'); app.unmount()`进行Vue App的卸载**

  - LifeCycle Hook的使用

    - hook函数的使用很简单，在Vue App的配置对象中，直接定义同名方法即可,Vue会在到达对应的节点处回调这里定义的同名hook函数

      <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;    <span class="keyword">return</span> &#123;&#125;;  &#125;,  <span class="attr">methods</span>: &#123;      &#125;,  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;      &#125;,  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;      &#125;&#125;)</span><br></pre></td></tr></table></figure>

## Components

- 从一个demo引入为什么需要Components

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;        &lt;li v-for=&quot;friend in friendList&quot; :key=&quot;friend.id&quot;&gt;          &lt;h2&gt;&#123;&#123;friend.name&#125;&#125;&lt;/h2&gt;          &lt;button @click=&quot;showDetails&quot;&gt;Show Details&lt;/button&gt;          &lt;ul :hidden=&quot;detailsEnable&quot;&gt;            &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt; &#123;&#123;friend.phone&#125;&#125;&lt;/li&gt;            &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; &#123;&#123;friend.email&#125;&#125;&lt;/li&gt;          &lt;/ul&gt;        &lt;/li&gt;      &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

  - 实际上在前边的demo中v-for内部有这么大的一块HTML都比较少见
  - **不要混淆此处的问题与v-for循环中使用key的问题，此处是结构导致的HTML标签重复无法有效组织的问题，key是性能优化引发的HTML标签复用的问题**

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;<span class="comment">// 引入css组件import &quot;./App.css&quot;;class Friend &#123;    constructor(public name: string, public id: number, public phone: string, public email: string)&#123;&#125;;&#125;export default defineComponent (&#123;    data(): &#123;friendList: Friend[], detailsEnable: boolean&#125; &#123;        return &#123;            friendList: [new Friend(&#x27;Manuel Lorenz&#x27;, Math.random(), &#x27;01234 5678 991&#x27;, &#x27;manuel@localhost.com&#x27;), new Friend(&#x27;Julie Jones&#x27;, Math.random(), &#x27;09876 543 221&#x27;, &#x27;julie@localhost.com&#x27;)],            detailsEnable: true        &#125;;    &#125;,    methods: &#123;        showDetails () &#123;            this.detailsEnable = !this.detailsEnable;        &#125;    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

  - 问题在于渲染朋友列表的时候，有一个showDetail按钮，但是此按钮与对应的hidden属性成为了列表中每一个成员都有的标签，但是点击后的效果对所有成员生效，**如果要使用friend.id作为方法参数来确定显示效果，需要为每一个friend定义一个类似于`detailsEnable`这样的属性，friend列表来自于数据库也是动态的，所以此方法失效，其他的办法？**

- component

  - 定义components的方法

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;<span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/App/App.vue&#x27;</span>;<span class="keyword">import</span> friendsComponent <span class="keyword">from</span> <span class="string">&#x27;./components/friendList/friends.vue&#x27;</span>;<span class="keyword">const</span> app= createApp(App)<span class="comment">// Global Component：添加component// 1. 指定component名字，类似于是一个定制的HTML 标签的名字，应该是两个单词中间用-隔开，这样不会与默认已有的// HTML 标签冲突// 2. Vue config app.component(&#x27;friend-list&#x27;, friendsComponent);app.mount(&#x27;#app&#x27;)// Local component： 加载component的另一个方法是在App.vue (Main Vue App Config Object)中使用components属性来加载指定的components,此属性需要一个对象，对象成员键值对的键就是component的名字（如果使用了-需要用引号括起来），值就是component config object,或者可以将import的component config object命名为两个单词使用驼峰组合或pascal组合（所有单词大写），则component的名字自动设置为拆开后用-相连，并使用小写，此时不用再指定键名，如下案例所示import friendList from &#x27;../friendList/friends.vue&#x27;export default defineComponent (&#123;    data(): &#123;friendList: Friend[]&#125; &#123;        return &#123;            // 列表在组件中的渲染可能需要组件之间的数据交流了            friendList: [new Friend(&#x27;Manuel Lorenz&#x27;, Math.random(), &#x27;01234 5678 991&#x27;, &#x27;manuel@localhost.com&#x27;), new Friend(&#x27;Julie Jones&#x27;, Math.random(), &#x27;09876 543 221&#x27;, &#x27;julie@localhost.com&#x27;)]        &#125;;    &#125;,    components: &#123;        // friend-list        // FriendList也可以对应friend-list的components名字        friendList    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

    - components的名字**（也就是在template中使用的自定义的HTML标签的名字应该尽量使用a-b的构造，使用pascal格式也可以）**
    - **在components属性中只放一个值，就可以自动扩展为`与该值同名的键:该值`，这是由modern js引入的特性**
    - Vue component实际上就是另外一个Vue App,只不过此App依附于主App
    - 子App与父App目前来说是隔离的，各自定义相同的属性或函数等，也不会冲突

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;    &lt;!-- 在 main APP 中引入component的方法 --&gt;    &lt;friend-list&gt;&lt;/friend-list&gt;    &lt;!-- 两个组件完全隔离，互不干扰，解决了前边的问题 --&gt;    &lt;friend-list&gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;li&gt;    &lt;h2&gt;&#123;&#123; friend.name &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;showDetails&quot;&gt;Show Details&lt;/button&gt;    &lt;ul :hidden=&quot;detailsEnable&quot;&gt;      &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt; &#123;&#123; friend.phone &#125;&#125;&lt;/li&gt;      &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; &#123;&#123; friend.email &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script src=&quot;./friends.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

    

    - component是可复用的组件，**当然组件之间也可以互相通信**
    - **单Vue App 多 component与多Vue App都可以实现页面应用中控制多个HTML部分的作用，但是多Vue App之间并没有提供官方支持的数据交换方式，而多component中提供了**

## Vue CLI

- 引入components之后，发现代码变得臃肿，堆积在一个文件中，并且总是使用静态HTML文件来加载Vue 应用并不是很好
  - 对于Vue这样的前框框架开发时不需要和后端协商进行，因为完全独立了，直接在自己开发机设置服务器serve Vue App即可，至于数据完全可以mock或者使用假数据即可
- Vue CLI提供的web server可以在代码变动后自己重启加载
- VueCLI为 VS Code提供了语法支持
- Vue CLI可以使得js与css的加载全部使用 ES Module的形式，而不是HTML标签加载的形式
- 要使用Vue CLI 需要安装nodejs（提供npm）
  - 现在知道nodejs对于前端的巨大意义了，不仅仅在于让js脱离浏览器的限制，也在于为前端工程化打下了基础
- .vue文件的组成部分
  - template标签--Vue app或者是component的Template
  - script标签，Vue app config object或者component config object
    - 可以加载文件
  - style标签 Vue app的样式或者是component的样式
    - 可以单独写在css文件中，然后在js或ts文件中使用import "css文件位置"来加载
    - 样式默认是全局生效的
  - 对于.vue文件，可以在vscode中安装Vetur插件，让IDE支持.vue的语法
- components文件夹内的.vue名字一般应该与组件名相同

## Vue Components

- 前边已经使用demo尝试引入了Components，但是并未涉及Main Vue App如何向Components传递数据，以及Components之间如何交换数据，这也是Components的关键所在
- **Components的最大的特性在于其可重用性，因此一般数据不会直接定义在Components中，而是由Main Vue App通过各种方式获取并传递给Components，Componeents就是无情的可复用的渲染机器**

### Props

- **实现Main Vue App 与 Components数据交换的就是Props**

- Props就是properties的简称，可以将此概念理解为在组件标签中使用自定义属性

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--App.vue--&gt;&lt;template&gt;  &lt;ul&gt;    &lt;!-- 在 main APP 中引入component的方法 --&gt;    &lt;!--使用自定义属性向components中传递数据--&gt;    &lt;friend-list name=&quot;lee&quot; phone_number=&quot;1313&quot; email=&quot;2321@we.com&quot;&gt;&lt;/friend-list&gt;    &lt;friend-list name=&quot;dan&quot; phone_number=&quot;2134&quot; email=&quot;2134@we.com&quot;&gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

  - components接受这些自定义的属性，需要在config object中使用props属性，此属性接受一个字符串数组

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;    <span class="comment">// 注意在props列表中定义的字符串会像data中定义的属性一样被绑定到全局对象中，可以被this索引，也可以在template中引用，因为是作为属性，所以起名字不能使用-所以 自定义的属性名应在这里改写为其对应的驼峰命名，Vue可以进行关联    props:[        &#x27;name&#x27;,        &#x27;phoneNumber&#x27;,        &#x27;email&#x27;    ],    data() &#123;        return &#123;            detailsEnable: true        &#125;;    &#125;,    methods: &#123;        showDetails () &#123;            this.detailsEnable = !this.detailsEnable;        &#125;    &#125;&#125;);</span></span><br></pre></td></tr></table></figure>

    - **只有自定义属性名带-时，才需要将对应的props属性名进行更名**

      - **props在template中应尽量命名为非a-b的形式，直接使用驼峰命名法，避免由Vue进行关联（可能不小心导致错误）**

    - **更名只能更改为驼峰命名法，不能更改为pascal法**

      - **前边的加载components的命名是可以使用pascal命名法的**

    - **props中定义的变量，是只读的**

      - **这是因为默认情况下，只允许单向的数据流动（Parent -> Component）如果确实需要更改传入的数据，有两种场景以及方法**

        - Component只想在本组件内使用并改变数据的值，不对外界产生影响

          <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;    <span class="attr">props</span>:[        <span class="string">&#x27;name&#x27;</span>,        <span class="string">&#x27;phoneNumber&#x27;</span>,        <span class="string">&#x27;email&#x27;</span>    ],    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;        <span class="keyword">return</span> &#123;            <span class="attr">detailsEnable</span>: <span class="literal">true</span>,            <span class="attr">phone_number</span>: <span class="built_in">this</span>.phoneNumber        &#125;;    &#125;,    <span class="attr">methods</span>: &#123;        showDetails () &#123;            <span class="built_in">this</span>.detailsEnable = !<span class="built_in">this</span>.detailsEnable;        &#125;    &#125;&#125;);</span><br></pre></td></tr></table></figure>

          - 将props变量作为初始值传递给data属性即可

        - Component想改变传入的数据的值，并且告知Parent此改变应该是逆向的（由Component-> Parent）

          - 后续介绍，使用custom event

    - **因为props中的字符串会被绑定为全局变量的属性，因此注意其不应与data中定义的属性产生冲突**

  - 除了以字符串数组的形式提供props之外，还可以以对象的形式提供，这为props进行了限制，比方说类型限制，是否必须等等，就像是定义函数的形参，这使得vue程序可以更加健壮

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;        <span class="attr">name</span>: <span class="built_in">String</span>,        <span class="attr">phoneNumber</span>: &#123;            <span class="attr">type</span>: <span class="built_in">String</span>,            <span class="attr">required</span>: <span class="literal">true</span>        &#125;,        <span class="attr">email</span>: &#123;            <span class="attr">type</span>: <span class="built_in">String</span>,            <span class="attr">required</span>: <span class="literal">false</span>,            <span class="comment">// default: &#x27;0&#x27;             default: ():string =&gt; &#123;return &#x27;0&#x27;&#125;,            validator: (value: string): boolean =&gt; &#123;                if (value.length &gt; 10) &#123;                    return false;                &#125;                return true;            &#125;        &#125;    &#125;</span></span><br></pre></td></tr></table></figure>

    - **注意在ts中string是小写的，而在js中这里指定的数据类型就是js中原生的String构造器，包括Boolean亦是如此**

    - default在required为false时提供（不是必须的），可以直接设置默认值，也可以设置一个返回默认值的函数

    - validator用来验证数据的合法性

      - **如果是非法参数或者说没有提供必需的（required）属性或者类型不匹配的话，会在浏览器的控制台终端输出Vue Warn**

        <img src="http://images.demoli.xyz/image-20210120230506460.png" alt="image-20210120230506460" style="zoom:67%;" />![image-20210120231547007](http://images.demoli.xyz/image-20210120231547007.png)

        ![image-20210120231547007](http://images.demoli.xyz/image-20210120231547007.png)

    - 支持的type包括

      - String

      - Number

      - Boolean

      - Array

      - Object

      - Date

      - Function

      - Symbol

      - 其他构造器啊函数比如Date，或自定义class类型

      - **此处本有一个疑惑props作为HTML中的一个属性，怎么可能传如非string得数据呢，任何数据在HTML属性中都会被解析为string，但是我忽略了之前的一个vue特性 v-bind:，被bind的属性（可以是HTML的默认的属性，也可以是Vue提供的属性，比如key 也可以是自定义的props属性！！）的值可以是js expression，换句话说被bind的属性的值不会被默认当做string，而是js expression，如果要表示string，需要用单引号括起来！**

        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-else :style=&quot;&#123;display: isHidden? &#x27;none&#x27;:&#x27;&#x27;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>

        - none是string，是对象中display属性的一个可能的值

- 为props绑定动态数据

  - 即使用v-bind，此时就可以向component传递非string类型的动态数据了

  - 除了上述的特性，因为绑定了动态数据，所以可以使用v-for来渲染列表了（其实是使用v-for来渲染component）

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;    &lt;!-- 在 main APP 中引入component的方法 --&gt;    &lt;friend-list v-for=&quot;friend in friendList&quot; :key=&quot;friend.id&quot; :name=&quot;friend.name&quot; :phone-number=&quot;friend.phone&quot; :email=&quot;friend.email&quot;&gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

- Prop / Event Fallthrough

  - 此特性的意思就是对于component中没有定义的prop或事件，也可以在调用component的template中使用

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--base-button.vue--&gt;&lt;template&gt;    &lt;button&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/button&gt;&lt;/template&gt; &lt;script&gt;export default &#123;&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--App.vue--&gt;&lt;base-button type=&quot;submit&quot; @click=&quot;doSomething&quot;&gt;Click me&lt;/base-button&gt;</span><br></pre></td></tr></table></figure>

    - **尽管component中没有定义type prop与click event，但是component中的template的根节点button有这些属性，所以添加到component上的type属性与click事件会自动添加到button标签上，而不用显式的定义**
    - 可以通过`this.$attrs`来访问这些自动添加的prop

- Binding all Props

  - 在Template中使用components时可以单独的设置每一个prop

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;    &lt;friend-list v-for=&quot;friend in friendList&quot; :key=&quot;friend.id&quot; :name=&quot;friend.name&quot; :phone-number=&quot;friend.phoneNumber&quot; :email=&quot;friend.email&quot;&gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

  - 但是如果传入的所有prop都是一个对象的属性的话，可以只传递这个对象，因此可以简化代码，使用v-bind即可（**此时v-bind不在标签属性上使用，而是直接使用**）

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;    &lt;friend-list v-for=&quot;friend in friendList&quot; :key=&quot;friend.id&quot; v-bind=&quot;friend&quot;&gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

    - **需要注意的是，因为是接受一个对象并将对象的属性与component中的props绑定，所以对象的属性名应该与props中定义的属性名完全对应一致**

### 使用Custom Events从component向Main Vue APP 传递数据

- 类似于原生的HTML中，button被点击后会回调一个点击事件让用户处理，components也可以在内部执行回调方法（或者说触发一个自定义的事件），并以此告知Main Vue App （需要执行监听），某些数据需要被更改

- 使用`this.$emit`（vue内置属性）

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inner component// 触发事件// 1. 事件名称的格式应当是a-b的形式// 2. 可以添加任意数量的参数作为事件触发时携带的数据// 在component被Main App调用的template中，可以使用@click这样的属性来监听此事件 @toggle-favoritethis.$emit(&#x27;toggle-favorite&#x27;, this.id);</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--App.vue--&gt;&lt;template&gt;  &lt;ul&gt;    &lt;!-- 在 main APP 中引入component的方法 --&gt;    &lt;friend-list      v-for=&quot;friend in friendList&quot;      :id=&quot;friend.id&quot;      :key=&quot;friend.id&quot;      :name=&quot;friend.name&quot;      :phone-number=&quot;friend.phone&quot;      :email=&quot;friend.email&quot;      :is-favorite=&quot;friend.isFavorite&quot;      @toggle-favorite=&quot;changeFavorite&quot;    &gt;&lt;/friend-list&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;./App.ts&quot; lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main Vue Appexport default defineComponent (&#123;    methods: &#123;        // 这里与普通的事件回调函数不一样，前边的内置的事件回调函数，如果不指定参数会自动传递event,但是这里直接传递数据        changeFavorite(friendID: number) &#123;            const specificFriend = this.friendList.find((friend) =&gt; friend.id === friendID)!;            specificFriend.isFavorite = !specificFriend.isFavorite        &#125;    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

  - **对于上边代码中的注释的解释,实际上，此处触发函数的friendID就是`$event`，验证方式是，将触发函数的调用处，不接受默认参数，而是` @toggle-favorite="changeFavorite($event, 1)"`，此时触发函数中打印的第一个参数也就是$event就是friendID的值-----在下边的`cmp-communication-08-a-potential-problem-starting-setup`项目中这一点会更加明确**

    - 传递的参数只有1个的时候，`$event`指向的就是第一个参数，此时可以方便的向触发函数中加入自己的自定义参数，`@delete-friend="deleteFriend($event, userDefined)"`；但是如果component内事件传输的参数有多个，如何获得全部的参数？
      - 可以更改事件传递参数的形式:`<button @click="$emit('delete-friend', &#123;id: id, name: name&#125;)">Delete</button>`此时数据被包含在对象中传递给$event，进而可以在回调函数中解析使用
      - 或者使用arguments，参考[自定义事件传参问题](https://github.com/vuejs/vue/issues/5735)，**但是自己并没有搞懂如何实现。。。。。。。。。。。。。！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！1**

  - **最牛逼的在于在Main Vue App 中更改完毕的数据会被侦测到并自动重新传递给component，并重新渲染，此时数据完成了其双向的流动**

  - **与prop类似，component内部定义的event也相当于是component向外部提供的一个接口，为了保证component的可复用性，除了在component config object中使用props属性来声明数据之外，还可以使用emits属性来声明本组件会触发的事件，以供外部监听使用**

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;    <span class="comment">// props:[&#x27;name&#x27;, &#x27;phoneNumber&#x27;, &#x27;email&#x27;],    props: &#123;        id: &#123;            type: Number,            required: true        &#125;,        name: String,        phoneNumber: &#123;            type: String,            required: true        &#125;,        email: &#123;            type: String,            required: true        &#125;,        isFavorite: Boolean    &#125;,    // emits: [&#x27;toggle-favorite&#x27;],    emits: &#123;        // 事件名称作为key        // validator函数作为值        // validator函数的参数就是事件触发携带的数据参数        &#x27;toggle-favorite&#x27;: (id: number) =&gt; &#123;            if (id) &#123;                return true;            &#125; else &#123;                console.error(&#x27;id is missing&#x27;);                return false;            &#125;        &#125;    &#125;,  methods: &#123;        showDetails () &#123;            this.detailsEnable = !this.detailsEnable;        &#125;,        toggleFavorite() &#123;            this.$emit(&#x27;toggle-favorite&#x27;, this.id);        &#125;    &#125;</span></span><br></pre></td></tr></table></figure>

    

### 使用Component的Demo

- component不仅仅是一个可以复用的数据渲染机器，也可以收集用户输入的复用组件，并根据业务需求将用户输入传递给Main Vue App（数据管理的所在地，只在Main Vue App与server进行数据交互）

  - 之所以总的数据管理都放在Main Vue App中，是因为只有这个App 可以和所有component沟通，二如果放到component中，不仅与Main App沟通相对困难，与其他component甚至暂时还没有办法沟通

- **Potential Poblem章节有一个demo工程，推荐看看源码，套娃使用component，工程名字叫做`cmp-communication-08-a-potential-problem-starting-setup`**

  - **注意，在此demo中，所有的component在Main Vue App中注册，但是他们互相之间可以调用，也即意味着被调用的componet与调用者（不管是Main Vue App还是其他component）都是用相同的方式进项两个方向的沟通的（props与custom event）**

    - **父组件与子组件的关系**

    - 在demo中，`select-topic`这个事件经过了多个component的传导，而且`topics`数据也经过了多个component的传导，这实际上没有太大必要（KnowledgeBase这个组件完全没有用到topics数据）

    - 但是实际上传导过程中的中间`component`，只是进行了传导却并没有用到数据，如何避免这种不必要的传导呢

      - 使用**provide/inject特性**，这两个实际上都是Config Object的属性，配合使用

        - **只能inject父组件中provide的数据！！**

          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;export default &#123;		data () &#123;&#125;,		methods: &#123;&#125;,		provide: &#123;      // 向子组件直接提供topics这个数据      topics:  [          &#123;            id: &#x27;basics&#x27;,            title: &#x27;The Basics&#x27;,            description: &#x27;Core Vue basics you have to know&#x27;,            fullText:              &#x27;Vue is a great framework and it has a couple of key concepts: Data binding, events, components and reactivity - that should tell you something!&#x27;,          &#125;,          &#123;            id: &#x27;components&#x27;,            title: &#x27;Components&#x27;,            description:              &#x27;Components are a core concept for building Vue UIs and apps&#x27;,            fullText:              &#x27;With components, you can split logic (and markup) into separate building blocks and then combine those building blocks (and re-use them) to build powerful user interfaces.&#x27;,          &#125;,        ]  &#125;,&#125;&lt;!--另一种provide方式： 父组件，为了暴露父组件中的data属性--&gt;provide() &#123;    return &#123;      topics: this.topics    &#125;;  &#125;&lt;!--子组件--&gt;export default &#123;  // props: [&#x27;topics&#x27;],  emits: [&#x27;select-topic&#x27;],  // 注入父组件暴露的数据  inject: [&#x27;topics&#x27;]&#125;;</span><br></pre></td></tr></table></figure>

    - 事件的传导也是没有必要的

      - 与数据传导类似的，事件的传导也可以借助provide/inject机制实现点对点的传导（**函数也可以作为值传递**）

        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;li&gt;    &lt;h3&gt;&#123;&#123; topicName &#125;&#125;&lt;/h3&gt;    &lt;p&gt;&#123;&#123; description &#125;&#125;&lt;/p&gt;    &lt;!-- &lt;button @click=&quot;$emit(&#x27;select-topic&#x27;, id)&quot;&gt;Learn More&lt;/button&gt; --&gt;    &lt;button @click=&quot;selectTopic(id)&quot;&gt;Learn More&lt;/button&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;id&#x27;, &#x27;topicName&#x27;, &#x27;description&#x27;],  // emits: [&#x27;select-topic&#x27;],  // 注入回调函数  inject: [&#x27;selectTopic&#x27;]&#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

        

        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;  <span class="keyword">return</span> &#123;    <span class="attr">topics</span>: <span class="built_in">this</span>.topics,    <span class="comment">// 把回调函数的引用作为数据进行暴露    selectTopic: this.activateTopic  &#125;;&#125;,  methods: &#123;    activateTopic(topicId) &#123;      this.activeTopic = this.topics.find((topic) =&gt; topic.id === topicId);    &#125;,  &#125;,</span></span><br></pre></td></tr></table></figure>

  - 合理使用**provide/inject特性**，props与custom event仍然应当是默认的组件交流方式，只有当数据或事件经过了超过两个以上的中间组件的状态下才需要使用**provide/inject特性**

    - **为什么会有这些中间组件呢，因为组件的设计是为了复用（这些中间组件都有自己的模板与相应的功能），当组件关系确定后，底层组件如果要和最高级的组件进行沟通，可能会经过一系列无关的中间组件**

  - **上边讲述了父子组件之间的沟通方法，那么兄弟组件呢，即有共同父组件的子组件，此时应当将数据托管到父组件，通过父组件进行兄弟组件之间的数据交换**

### Diving Deeper into Components

1. component的注册方式

   1. `Global Components`

      <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;<span class="keyword">import</span> TheHeader <span class="keyword">from</span> <span class="string">&#x27;./components/TheHeader.vue&#x27;</span>;<span class="keyword">import</span> BaseBadge <span class="keyword">from</span> <span class="string">&#x27;./components/BaseBadge.vue&#x27;</span>;<span class="keyword">import</span> BadgeList <span class="keyword">from</span> <span class="string">&#x27;./components/BadgeList.vue&#x27;</span>;<span class="keyword">import</span> UserInfo <span class="keyword">from</span> <span class="string">&#x27;./components/UserInfo.vue&#x27;</span>;<span class="keyword">const</span> app = createApp(App);app.component(<span class="string">&#x27;the-header&#x27;</span>, TheHeader);app.component(<span class="string">&#x27;base-badge&#x27;</span>, BaseBadge);app.component(<span class="string">&#x27;badge-list&#x27;</span>, BadgeList);app.component(<span class="string">&#x27;user-info&#x27;</span>, UserInfo);app.mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

      1. 可以在Vue App 中的任意一个Template中使用全局注册的组件，此时组件之间也可以互相调用（调用陷阱），父子关系混乱，组件的使用灵活自由，但是容易出问题

         <img src="http://images.demoli.xyz/image-20210122135930043.png" alt="image-20210122135930043" style="zoom:50%;" />

      2. App初始化加载的时候需要下载全部的组件的代码并加载，即便部分组件暂时不会使用或者很少使用

      3. 对于被多个组件使用的组件可以注册为全剧组件

   2. Local Components

      1. 所谓的本地组件就是在component内部注册的组件，或者说是在父组件中注册的组件，此时该注册的子组件只能在当前的组件的Template中使用
      2. 仅被少数几个组件使用的组件应注册为本地组件

2. Local Style

   1. 默认的vue中使用`<style>`标签加载的样式是全局生效的，可以通过加参数`scoped`构造仅在当前component内生效的样式

      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;section &#123;  margin: 2rem auto;  max-width: 30rem;  border-radius: 12px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);  padding: 1rem;&#125;section div &#123;  display: flex;  justify-content: space-between;  align-items: center;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

      - 对于App.vue内部定义的样式一般可以设置为全局，因为往往定义注入html标签与body标签或者一些全局的样式

   2. Vue是如何实现local style的

      ![image-20210122143409264](http://images.demoli.xyz/image-20210122143409264.png)

      ![image-20210122143523011](http://images.demoli.xyz/image-20210122143523011.png)

      - 通过设置自定义属性来作为selector为特定的组件分配本地的样式

3. slots

   1. 此组件特性实际对应着一种特殊的组件用法：**包装组件**，比如卡片组件

      <img src="http://images.demoli.xyz/image-20210122144423784.png" alt="image-20210122144423784" style="zoom:80%;" />

      - 比如上述图中的卡片组件，卡片组件作为一种包装类型的组件，其内部需要嵌套其他的组件，当然这种包装类型的组件可能更多的只是只含有一些样式的组件，可以写到全局样式中，使用包装类型显然更规范，那么如何使得包装类型内部可以嵌套其他内容或组件呢（之前的组件都是独立堆叠使用的，不会嵌套包装使用）

        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseCard组件&lt;template&gt;    &lt;div&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;div &#123;  margin: 2rem auto;  max-width: 30rem;  border-radius: 12px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);  padding: 1rem;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;base-card&gt;    &lt;div&gt;      &lt;h3&gt;&#123;&#123; fullName &#125;&#125;&lt;/h3&gt;      &lt;base-badge :type=&quot;role&quot; :caption=&quot;role.toUpperCase()&quot;&gt;&lt;/base-badge&gt;    &lt;/div&gt;    &lt;p&gt;&#123;&#123; infoText &#125;&#125;&lt;/p&gt;  &lt;/base-card&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

        - **核心在于slot标签，与props属性类似，后者用来接受父组件的数据，slot标签用于接收父组件的HTML标签**

      - Slot Name

        - 对于包装组件来说，除了定义好样式之外，其模板的结构未必是单一的结构，如果其模板也有相对复杂的结构的话，就需要有多个slot，将父模板的HTML标签置入到指定的slot中去，这需要使用`slot name`进行区分

          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;div&gt;        &lt;header&gt;            &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;        &lt;/header&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;div &#123;  margin: 2rem auto;  max-width: 30rem;  border-radius: 12px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);  padding: 1rem;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

          - 如果有多个slot可以留一个slot不进行命名，作为默认slot

            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;base-card&gt;    &lt;template v-slot:header&gt;      &lt;h3&gt;&#123;&#123; fullName &#125;&#125;&lt;/h3&gt;      &lt;base-badge :type=&quot;role&quot; :caption=&quot;role.toUpperCase()&quot;&gt;&lt;/base-badge&gt;    &lt;/template&gt;    &lt;p&gt;&#123;&#123; infoText &#125;&#125;&lt;/p&gt;  &lt;/base-card&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

            - 使用包装组件时，将包装组件内部的内容按照slot进行划分，使用template+v-slot属性（**必须是template标签**）将对应的内容对应到指定名字的slot中，其余没有指定的部分被默认归置到默认slot中

              - 更好的做法是显式的将剩余部分规划到默认slot中

                <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;base-card&gt;    &lt;template v-slot:header&gt;      &lt;h2&gt;Available Badges&lt;/h2&gt;    &lt;/template&gt;    &lt;template v-slot:default&gt;      &lt;ul&gt;        &lt;li&gt;          &lt;base-badge type=&quot;admin&quot; caption=&quot;ADMIN&quot;&gt;&lt;/base-badge&gt;        &lt;/li&gt;        &lt;li&gt;          &lt;base-badge type=&quot;author&quot; caption=&quot;AUTHOR&quot;&gt;&lt;/base-badge&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/template&gt;  &lt;/base-card&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

                - **`v-slot:`的简写方式是`#`**

              - 当包装组件内部只有一个slot，或者说父组件只想使用包装组件内部的一个slot时：

                <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-card #header1&gt;      &lt;h3&gt;&#123;&#123; fullName &#125;&#125;&lt;/h3&gt;      &lt;base-badge :type=&quot;role&quot; :caption=&quot;role.toUpperCase()&quot;&gt;&lt;/base-badge&gt;  &lt;/base-card&gt;</span><br></pre></td></tr></table></figure>

                - **可以直接把`v-slot`属性写到组件标签上，并且不用再使用Template标签**

          - 关于使用slot中的样式的问题

            - 一如之前所说的style的作用范围，在包装组件的父组件中定义的样式可以影响到父组件往包装组件内部的slot传输的HTML标签的样式，但是无法影响包装组件内部slot所在的HTML标签的样式

          - slot的默认值，当父组件没有向slot中传输HTML的时候，将展示slot的默认内容

            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;div&gt;        &lt;header&gt;            &lt;slot name=&quot;header&quot;&gt;                &lt;h2&gt;The Default Content&lt;/h2&gt;            &lt;/slot&gt;        &lt;/header&gt;        &lt;slot&gt;&lt;h2&gt;The Default Content&lt;/h2&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

          - 当父组件没有使用包装组件内部的slot的时候，除了可以展示默认值之外，还可以通过`$slots`来判断父组件有没有向对应的slot传递内容，并结合`v-if`来条件渲染slot所在的标签

            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;div&gt;        &lt;header&gt;            &lt;slot name=&quot;header&quot;&gt;            &lt;/slot&gt;        &lt;/header&gt;        &lt;slot&gt;&lt;h2&gt;The Default Content&lt;/h2&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

            - 如上例所示，如果父组件没有使用header这个slot，那么实际的渲染过程中会有一个空的header被渲染出来，为了避免空标签的渲染（不是很大的问题，但是可以规范点），可以使用`$slots`进行判断

              <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent (&#123;    mounted () &#123;        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$slots.header);        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$slots.default);    &#125;&#125;)</span><br></pre></td></tr></table></figure>

              - 可以在包装组件内部使用`this.slots.slot_name`来获知该slot有没有被父组件使用，如果没有则值为undefined

                <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;div&gt;        &lt;header v-if=&quot;$slots.header&quot;&gt;            &lt;slot name=&quot;header&quot;&gt;                &lt;!-- &lt;h2&gt;The Default Content&lt;/h2&gt; --&gt;            &lt;/slot&gt;        &lt;/header&gt;        &lt;slot&gt;&lt;h2&gt;The Default Content&lt;/h2&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

          - scoped slots

            - 场景：

              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;goal in goals&quot; :key=&quot;goal&quot;&gt; &#123;&#123;goal&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent&#125; from &#x27;vue&#x27;;export default defineComponent (&#123;    data() &#123;        return &#123;            goals: [&#x27;ts&#x27;, &#x27;vue&#x27;, &#x27;java&#x27;]        &#125;    &#125;  &#125;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

              - 有如上的组件，对于便利的`&#123;&#123;goal&#125;&#125;</code>希望能</strong>让父组件为其添加独特的样式**，而不只是纯字符串输出，比如加个标签比如<code>&lt;h2&gt;&#123;&#123;goal&#125;&#125;&lt;/h2&gt;</code>.此时可以使用slot</p>
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CourseGoal组件&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;goal in goals&quot; :key=&quot;goal&quot;&gt;            &lt;slot name=&quot;goal&quot;&gt;&lt;/slot&gt;&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;父组件&lt;template&gt;    &lt;course-goals &gt;      &lt;template #goal&gt;				&lt;h2&gt;&lt;/h2&gt;			&lt;/template&gt;    &lt;/course-goals&gt;  &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

    - 此时的问题在于，遍历的goal变量只能在本组件的`v-for`内部使用，那么父组件中的定制样式如何加到这个goal变量中呢？使用scoped slot **其实就是将子组件中的变量暴露到父组件中，从而使得父组件可以将定制样式加入到这个包装组件的slot中**

      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CourseGoal组件&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;goal in goals&quot; :key=&quot;goal&quot;&gt;            &lt;slot name=&quot;goal&quot; :item=&quot;goal&quot; anotherProp=&#x27;.....&#x27;&gt;&lt;/slot&gt;&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;父组件&lt;template&gt;  &lt;div&gt;    &lt;course-goals &gt;      &lt;template #goal=&quot;goals&quot;&gt;        &lt;h2&gt;&#123;&#123;goals.item&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;&#123;&#123;goals.anotherProp&#125;&#125;&lt;/h2&gt;      &lt;/template&gt;    &lt;/course-goals&gt;  &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

      - 在子组件内部的slot中定义的属性与其值都会被加载到一个对象中并传递给父组件中`v-slot:slotName=&#39;var&#39;`的var变量中，因此在父组件中可以通过var来获得数据，并放置到定制样式中
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态Component</p>
<ul>
<li><p>场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;the-header&gt;&lt;/the-header&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;manage-goals&#x27;)&quot;&gt;Manage Goals&lt;/button&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;active-goals&#x27;)&quot;&gt;Active Goals&lt;/button&gt;    &lt;manage-goals v-if=&quot;selectedComponent === &#x27;manage-goals&#x27;&quot;&gt;&lt;/manage-goals&gt;    &lt;active-goals v-if=&quot;selectedComponent === &#x27;active-goals&#x27;&quot;&gt;&lt;/active-goals&gt;  &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>想按照按键的选择来选择性的展示某个组件，可以使用<code>v-if</code>但是当组件变得过多后，使用<code>v-if</code>比较变得很繁琐，使用动态Component来解决这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;the-header&gt;&lt;/the-header&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;manage-goals&#x27;)&quot;&gt;Manage Goals&lt;/button&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;active-goals&#x27;)&quot;&gt;Active Goals&lt;/button&gt;    &lt;component :is=&quot;selectedComponent&quot;&gt;&lt;/component&gt;  &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>component</code>标签是vue提供的标签，可以展示其is属性的值所对应的注册的组件，上边的案例等价于使用<code>v-if</code></li>
</ul>
</li>
<li><p>动态component的保活（状态维护）</p>
<ul>
<li><p>场景</p>
<ul>
<li><p>基于上述的场景，如果一个组件中有用户输入这种含状态的标签，如果用户输入完成在触发保存前，使用动态component切换后，之前的输入状态将完全丢失，因为之前的component被完全销毁了，如何维持住之前的状态呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;the-header&gt;&lt;/the-header&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;manage-goals&#x27;)&quot;&gt;Manage Goals&lt;/button&gt;    &lt;button @click=&quot;setSelectedComponent(&#x27;active-goals&#x27;)&quot;&gt;Active Goals&lt;/button&gt;    &lt;keep-alive&gt;      &lt;component :is=&quot;selectedComponent&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;      &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用keep-alive标签，在此标签内部的动态component组件在被替换时会缓存状态，而不是完全删除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用component实现自定义的提示框</p>
<ul>
<li><p>默认的alert比较丑，使用component定义自定义样式的提示框</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorAlert.vue&lt;template&gt;    &lt;dialog open&gt;        &lt;slot name=&quot;dialog&quot;&gt;&lt;/slot&gt;    &lt;/dialog&gt;&lt;/template&gt;&lt;style scoped&gt;    dialog &#123;        position: fixed;        top: 20vh;        left: 30%;        width: 40%;        background-color: white;        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);        padding: 1 rem;    &#125;&lt;/style&gt;父组件&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Manage Goals&lt;/h2&gt;    &lt;input type=&quot;text&quot; ref=&quot;goal&quot; /&gt;    &lt;button @click=&quot;addGoal&quot;&gt;add Goal&lt;/button&gt;    &lt;error-alert v-if=&quot;!isInputGoalValid&quot; #dialog&gt;        &lt;h2&gt;Input is invalid&lt;/h2&gt;        &lt;p&gt;enter some charactors&lt;/p&gt;        &lt;button @click=&quot;confirmError&quot;&gt;OK&lt;/button&gt;    &lt;/error-alert&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ErrorAlert from &#x27;./ErrorAlert.vue&#x27;export default &#123;  data() &#123;    return &#123;      isInputGoalValid: true,    &#125;;  &#125;,  components: &#123;      ErrorAlert  &#125;,  methods: &#123;    addGoal() &#123;      if (this.$refs.goal.value === &#x27;&#x27;) &#123;        this.isInputGoalValid = false;      &#125;    &#125;,    confirmError () &#123;        this.isInputGoalValid = true;    &#125;  &#125;,&#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义的提示框目前隶属于父组件的div标签，但是实际上如果此提示框组件作为一个body标签下的根组件更好（<strong>不这样设置也无所谓，但是这样设置的标签结构更合理</strong>），如何实现呢，使用<code>teleport</code>即可，与<code>keep-alive</code>标签类似，是vue提供的一个包装标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Manage Goals&lt;/h2&gt;    &lt;input type=&quot;text&quot; ref=&quot;goal&quot; /&gt;    &lt;button @click=&quot;addGoal&quot;&gt;add Goal&lt;/button&gt;    &lt;teleport to=&quot;body&quot;&gt;      &lt;error-alert v-if=&quot;!isInputGoalValid&quot; #dialog&gt;        &lt;h2&gt;Inut is invalid&lt;/h2&gt;        &lt;p&gt;enter some charactors&lt;/p&gt;        &lt;button @click=&quot;confirmError&quot;&gt;OK&lt;/button&gt;      &lt;/error-alert&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>to属性使用css selector指定要将teleport内部的标签内容渲染到什么位置，如上例，会渲染到body标签的末尾</li>
<li>使用此标签可以指定将内部的组件渲染到特定的位置，组件仍可以使用当前所在父组件的数据或者方法，但是渲染的位置由teleport决定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>component中的fragment概念</p>
<ul>
<li>在vue2中，component模板中只能有一个根标签，根标签下可以有多个子标签，但是在vue3中，没有此限制，若果没有样式限制的需求的话，完全可以有多个跟标签，这叫做fragment</li>
</ul>
</li>
</ul>
<h2 id="Learning-Resources-App-Demo-amp-Components知识整理"><a href="#Learning-Resources-App-Demo-amp-Components知识整理" class="headerlink" title="Learning Resources App Demo &amp; Components知识整理"></a>Learning Resources App Demo &amp; Components知识整理</h2><ul>
<li><p>样式是可以继承的，当我使用包装组件的时候，如果被包装的组件没有定义任何样式（<strong>必须是根本没有style标签或者有style标签但是没有scoped属性的情况，如果有style标签且为scoped，即便内容为空，也不会产生覆盖的行为</strong>），那么被包装组件中的标签会继承包装组件中对于同名标签定义的样式</p>
</li>
<li><p>Demo App的模块划分设计（<strong>不能仅仅从样式上划分模块，也要从功能，数据的分割的角度上去划分模块</strong>）</p>
<ul>
<li>App组件<ul>
<li>LearngingResources组件 专门对每一个Resource的内容做展示（<strong>对于列表中的每一项肯定是要单独做个组件出来的</strong>）<ul>
<li>使用props接受数据并渲染</li>
</ul>
</li>
<li>StoredResources组件 将for循环与ul也放到一个单独的组件，目的在于<strong>让App.vue精简，并且内部只包含全局的样式而没有其他局部样式，所以一般会把所有的HTML默认标签都移出App.vue到一个新的组件中</strong></li>
</ul>
</li>
<li>卡片组件 全局</li>
<li>Button组件 全局<ul>
<li>Button组件除了提供slot供使用者设置button的内容（甚至可以放图标）也提供了button的样式选择，<strong>这里突出的是组件的可复用性，组件就像是函数或API是提供服务用的，应该保证足够的定制化与实用性</strong></li>
</ul>
</li>
<li>TheHeader组件</li>
<li>tab组件<ul>
<li>卡片组件</li>
<li>用户输入组件<ul>
<li>带输入鉴定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Components的种类</p>
<ul>
<li>包装组件<ul>
<li>案例：<ul>
<li>比如卡片样式</li>
<li><img src="http://images.demoli.xyz/image-20210122144423784.png" alt="image-20210122144423784" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li>特性：<ul>
<li>此种组件更多包含的是卡片的样式与结构</li>
</ul>
</li>
<li>使用的Vue特性<ul>
<li>slot<ul>
<li>slot name</li>
<li>scoped slot</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据渲染组件：</p>
<ul>
<li>案例：<ul>
<li>li标签内部的数据展示，放在此组件内部</li>
</ul>
</li>
<li>Vue特性<ul>
<li>props</li>
</ul>
</li>
</ul>
</li>
<li><p>中间组件</p>
<ul>
<li>一般会调用数据渲染组件，作为App组件与数据渲染组件的中间件，一般是为了与App组件做切割保证App组件轻量而分离出的组件</li>
<li>Vue特性<ul>
<li>props</li>
</ul>
</li>
</ul>
</li>
<li><p>从功能上分：</p>
<ul>
<li>layouts<ul>
<li>TheHeader</li>
<li>TheFooter</li>
</ul>
</li>
<li>UI<ul>
<li>BaseCard</li>
<li>TheButton<ul>
<li>事件穿透</li>
</ul>
</li>
</ul>
</li>
<li>业务数据</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
